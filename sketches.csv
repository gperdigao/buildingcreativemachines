"sketch ID","title","code title","code"
"2646132","Faultline Reverie","mySketch","// Faultline Reverie  

let shards = [];
let bgHue;

function setup() {
  pixelDensity(1);
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  bgHue = random(200, 260);
  noStroke();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

class Shard {
  constructor() {
    // Spawn from a random screen edge
    const edge = floor(random(4));
    switch (edge) {
      case 0: this.pos = createVector(random(width), -20); break;
      case 1: this.pos = createVector(random(width), height + 20); break;
      case 2: this.pos = createVector(-20, random(height)); break;
      case 3: this.pos = createVector(width + 20, random(height)); break;
    }
    // Initial velocity towards center with slight scatter
    const center = createVector(width/2, height/2);
    this.vel = p5.Vector.sub(center, this.pos).rotate(random(-PI/8, PI/8)).setMag(random(1, 3));
    this.size = random(20, 80);
    this.angle = random(TWO_PI);
    this.hue = random(0, 360);
    this.life = this.maxLife = random(120, 300);
  }

  update() {
    // Glitchy jitter and drift
    this.pos.add(p5.Vector.random2D().mult(0.5));
    this.pos.add(this.vel);
    this.angle += map(sin(frameCount * 0.05), -1, 1, -0.05, 0.05);
    this.life--;
  }

  display() {
    const alpha = map(this.life, 0, this.maxLife, 0, 1);
    push();
      translate(this.pos.x, this.pos.y);
      rotate(this.angle);
      blendMode(ADD);
      fill((this.hue + frameCount) % 360, 80, 100, alpha);
      beginShape();
        vertex(-this.size/2, -this.size/4);
        vertex(0, -this.size/2);
        vertex(this.size/2, -this.size/4);
        vertex(this.size/4, 0);
        vertex(this.size/2, this.size/4);
        vertex(0, this.size/2);
        vertex(-this.size/2, this.size/4);
        vertex(-this.size/4, 0);
      endShape(CLOSE);
    pop();
  }

  isDead() {
    return this.life <= 0;
  }
}

function draw() {
  background(bgHue, 20, 10);

  // Automatic spawning
  if (frameCount % 5 === 0) {
    shards.push(new Shard());
  }

  // Mouse-triggered shards
  if (frameCount % 10 === 0 && mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
    const s = new Shard();
    s.pos = createVector(mouseX, mouseY);
    shards.push(s);
  }

  // Update and render
  for (let i = shards.length - 1; i >= 0; i--) {
    const s = shards[i];
    s.update();
    s.display();
    if (s.isDead()) {
      shards.splice(i, 1);
    }
  }
}
"
"2646130","ErrorFlux","mySketch","// ErrorFlux  
// A rare and epic p5.js sketch where ephemeral glitch-like Errors emerge, swirl, and fade away in a cosmic dance—shaped by your cursor's presence.  

let errors = [];
let bgColor;

function setup() {
  pixelDensity(1);
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1);
  bgColor = color(230, 20, 10);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

class ErrorBlob {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D().mult(random(0.5, 2));
    this.size = random(30, 100);
    this.hue = random(300, 360);
    this.life = random(80, 200);
    this.maxLife = this.life;
  }

  update() {
    // Mouse interaction: repel if close, else gentle noise drift
    let m = createVector(mouseX, mouseY);
    let dir = p5.Vector.sub(this.pos, m);
    let d = dir.mag();
    if (d < 150) {
      dir.normalize().mult((150 - d) * 0.02);
      this.vel.add(dir);
    } else {
      // subtle perlin noise influence
      let angle = noise(this.pos.x * 0.002, this.pos.y * 0.002, frameCount * 0.005) * TWO_PI * 4;
      this.vel.add(p5.Vector.fromAngle(angle).mult(0.05));
    }
    this.pos.add(this.vel);
    this.life--;
  }

  display() {
    let alpha = map(this.life, 0, this.maxLife, 0, 1);
    noStroke();
    fill(this.hue, 80, 100, alpha);
    let noiseFactor = noise(this.pos.x * 0.005, this.pos.y * 0.005, frameCount * 0.01);
    let sz = this.size * (0.5 + noiseFactor * 0.5);
    // layered drawing for depth
    for (let i = 1; i > 0; i -= 0.2) {
      ellipse(
        this.pos.x + sin(frameCount * 0.01 + i) * 5,
        this.pos.y + cos(frameCount * 0.01 + i) * 5,
        sz * i,
        sz * i * (0.8 + noiseFactor * 0.2)
      );
    }
  }

  isDead() {
    return this.life <= 0;
  }
}

function draw() {
  blendMode(BLEND);
  background(bgColor);
  blendMode(ADD);

  // spawn new errors dynamically
  if (frameCount % 4 === 0) {
    let x = random(width);
    let y = random(height);
    errors.push(new ErrorBlob(x, y));
  }

  // update & display all
  for (let i = errors.length - 1; i >= 0; i--) {
    let e = errors[i];
    e.update();
    e.display();
    if (e.isDead()) errors.splice(i, 1);
  }
}"
"2618214","Dynamic Filters II","mySketch","// Epic Colour Ripple – interactive & vibrant
let t = 0;
let paletteIndex = 0;

let palettes = [
  ['#ff5f6d', '#ffc371', '#47cacc'],
  ['#6a11cb', '#2575fc', '#ff6a00'],
  ['#e1eec3', '#f05053', '#ed4264'],
  ['#00c3ff', '#ffff1c', '#ff7e5f'],
  ['#4ca1af', '#c4e0e5', '#fbc2eb']
];

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);
  noFill();
  strokeWeight(2);
}

function draw() {
  background(0, 0, 10);

  translate(width / 2, height / 2);
  let waves = map(mouseX, 0, width, 2, 20);
  let points = 200;
  let baseR = min(width, height) * 0.25;
  let palette = palettes[paletteIndex];

  beginShape();
  for (let i = 0; i < TWO_PI; i += TWO_PI / points) {
    let offset = sin(i * waves + t) * 40;
    let r = baseR + offset;
    let x = r * cos(i);
    let y = r * sin(i);

    let cIndex = floor(map(i, 0, TWO_PI, 0, palette.length));
    stroke(palette[cIndex % palette.length]);
    vertex(x, y);
  }
  endShape(CLOSE);

  t += 0.02;

  // Overlay UI
  noStroke();
  fill(255, 200);
  textSize(14);
  textAlign(LEFT, TOP);
  text(`Click to change colour palette\nCurrent: ${paletteIndex + 1}/${palettes.length}`, 10 - width / 2, 10 - height / 2);
}

function mousePressed() {
  paletteIndex = (paletteIndex + 1) % palettes.length;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2618213","Dynamic filters","mySketch","// Epic Minimal Filters

let filters = ['BLUR', 'THRESHOLD', 'INVERT', 'GRAY', 'POSTERIZE'];
let currentFilter = 0;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noFill();
  strokeWeight(2);
  frameRate(60);
}

function draw() {
  background(0);
  translate(width / 2, height / 2);

  // wave count based on mouseX position
  let waves = map(mouseX, 0, width, 1, 10);
  let radiusBase = min(width, height) * 0.3;

  stroke(255, 200);
  beginShape();
  for (let angle = 0; angle < TWO_PI; angle += 0.02) {
    let r = radiusBase + 50 * sin(waves * angle + t);
    let x = r * cos(angle);
    let y = r * sin(angle);
    vertex(x, y);
  }
  endShape(CLOSE);

  t += 0.02;

  // apply selected filter
  switch (filters[currentFilter]) {
    case 'BLUR': filter(BLUR, 3); break;
    case 'THRESHOLD': filter(THRESHOLD, 0.5); break;
    case 'INVERT': filter(INVERT); break;
    case 'GRAY': filter(GRAY); break;
    case 'POSTERIZE': filter(POSTERIZE, 4); break;
  }

  // instruction overlay
  noStroke(); fill(255, 180);
  textSize(14);
  textAlign(LEFT, TOP);
  text(`Click to change filter (${filters[currentFilter]})\nMouse to adjust frequency`, 10, 10);
}

function mousePressed() {
  currentFilter = (currentFilter + 1) % filters.length;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2603324","Eg Bank","mySketch","// Código para OpenProcessing: estrela laranja com 4 pontas, 20 bolinhas azuis girando e luzes de Natal piscando

let starAngle = 0;  // Ângulo da estrela (gira para a esquerda)
let ballAngle = 0;  // Ângulo das bolinhas (giram para a direita)
let lights = [];    // Array para armazenar as luzes de Natal

function setup() {
  createCanvas(600, 600);
  angleMode(DEGREES);
  
  // Cria luzes de Natal em posições aleatórias
  // Vamos criar 30 luzes com tamanhos variados
  for (let i = 0; i < 30; i++) {
    lights.push({
      x: random(width),
      y: random(height),
      size: random(5, 10)
    });
  }
}

function draw() {
  background(0);  // Fundo preto para destacar os efeitos
  
  // Desenha as luzes de Natal piscantes (atrás dos elementos principais)
  let natalColors = [""#FF0000"", ""#00FF00"", ""#0000FF"", ""#FFFF00"", ""#FF00FF""];
  noStroke();
  for (let light of lights) {
    // A cada frame, a cor é escolhida aleatoriamente para efeito de piscar
    fill(natalColors[floor(random(natalColors.length))]);
    ellipse(light.x, light.y, light.size, light.size);
  }
  
  // Desenha as 20 bolinhas azuis girando em círculo ao redor do centro
  push();
  translate(width / 2, height / 2);
  for (let i = 0; i < 20; i++) {
    let angle = ballAngle + i * (360 / 20);
    let r = 100;  // Raio do círculo onde as bolinhas circulam
    let x = r * cos(angle);
    let y = r * sin(angle);
    fill(""#0000FF"");
    ellipse(x, y, 20, 20);  // Bolinhas com diâmetro 20
  }
  pop();
  
  // Desenha a estrela laranja com 4 pontas (na verdade, um polígono estrela com 8 vértices alternados)
  push();
  translate(width / 2, height / 2);
  rotate(starAngle);  // Rotaciona a estrela para a esquerda
  fill(""#FFA500"");    // Cor laranja
  noStroke();
  beginShape();
  let outerRadius = 50;
  let innerRadius = 25;
  // Cria uma estrela com 4 pontas (8 vértices, alternando entre extremos e reentradas)
  for (let i = 0; i < 8; i++) {
    let angle = i * 45;
    let r = (i % 2 === 0) ? outerRadius : innerRadius;
    vertex(r * cos(angle), r * sin(angle));
  }
  endShape(CLOSE);
  pop();
  
  // Atualiza os ângulos para a animação:
  // A estrela gira para a esquerda (reduz o ângulo)
  starAngle -= 1;
  // As bolinhas giram para a direita (aumenta o ângulo)
  ballAngle += 2;
}
"
"2601729","Core Resonance - the Infinite Pulse","mySketch","// Parâmetros globais
let particles = [];
let numParticles = 300;
let noiseScale = 0.005;
let time = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  // Cria as partículas em posições aleatórias
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }
}

function draw() {
  // Fundo semi-transparente para efeito de rastro
  background(0, 20);
  time += 0.005; // Incrementa o tempo para oscilação
  
  // Atualiza e desenha as partículas
  for (let p of particles) {
    p.update();
    p.show();
  }
  
  // Desenha um núcleo oscilante matemático no centro
  drawOscillatingCore();
  // Desenha uma espiral rotativa com vibração
  drawRotatingSpiral();
}

// Ajusta o canvas ao redimensionar a janela
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

// Classe Particle: gerencia posição, velocidade, aceleração e histórico para rastro
class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.maxSpeed = 4;
    this.history = [];
  }
  
  update() {
    // Calcula a direção baseada em um campo de ruído (simula uma força variável)
    let angle = noise(this.pos.x * noiseScale, this.pos.y * noiseScale, time) * TWO_PI * 4;
    this.acc = p5.Vector.fromAngle(angle);
    this.acc.mult(0.5);
    
    // Atualiza velocidade e posição com limitação
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    
    // Armazena o histórico para traçar o rastro
    this.history.push(this.pos.copy());
    if (this.history.length > 50) {
      this.history.splice(0, 1);
    }
    
    // Efeito de tela infinita (wrap-around)
    if (this.pos.x > width)  this.pos.x = 0;
    if (this.pos.x < 0)      this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0)      this.pos.y = height;
  }
  
  show() {
    // Desenha o rastro da partícula
    noFill();
    stroke(255, 150);
    beginShape();
    for (let v of this.history) {
      vertex(v.x, v.y);
    }
    endShape();
    
    // Desenha a partícula em si
    noStroke();
    fill(255, 200);
    ellipse(this.pos.x, this.pos.y, 3, 3);
  }
}

// Desenha um núcleo oscilante no centro usando funções trigonométricas
function drawOscillatingCore() {
  push();
  translate(width / 2, height / 2);
  let numPoints = 200;
  let baseRadius = 100;
  stroke(255, 100);
  noFill();
  beginShape();
  for (let i = 0; i < numPoints; i++) {
    let angle = map(i, 0, numPoints, 0, TWO_PI);
    // Combinação de senos e cossenos para gerar oscilações complexas
    let r = baseRadius + 50 * sin(5 * angle + time * 3) + 20 * cos(3 * angle - time * 2);
    let x = r * cos(angle);
    let y = r * sin(angle);
    vertex(x, y);
  }
  endShape(CLOSE);
  pop();
}

// Desenha uma espiral rotativa com um toque de vibração
function drawRotatingSpiral() {
  push();
  translate(width / 2, height / 2);
  let spiralPoints = 300;
  let r0 = 10;
  stroke(200, 100);
  noFill();
  beginShape();
  for (let i = 0; i < spiralPoints; i++) {
    let t = map(i, 0, spiralPoints, 0, 10 * TWO_PI);
    // Calcula o raio com uma oscilação que varia com o tempo
    let r = r0 + (i * 0.5) + 20 * sin(0.5 * t + time);
    let x = r * cos(t + time * 0.5);
    let y = r * sin(t + time * 0.5);
    vertex(x, y);
  }
  endShape();
  pop();
}
"
"2592239","Workshop Redevaerk","mySketch","function setup() {
  createCanvas(400, 400);
  // Se preferir, altere para angleMode(RADIANS) e use radianos.
  angleMode(DEGREES);
}

function draw() {
  background(220);

  // Calcula a cor das bolas: vermelho ou amarelo, alternando a cada segundo
  let tempoSegundos = floor(frameCount / 60);
  let corBolas = (tempoSegundos % 2 === 0) ? color(255, 0, 0) : color(255, 255, 0);

  // Desenha as 6 bolas ao fundo
  push();
  translate(width / 2, height / 2);
  rotate(frameCount * 0.5); // Rotaciona para a direita (sentido horário)
  fill(corBolas);
  noStroke();
  
  // Distribui 6 bolas em círculo
  for (let i = 0; i < 6; i++) {
    push();
    rotate(i * 360 / 6);
    ellipse(100, 0, 30, 30);
    pop();
  }
  pop();

  // Desenha a estrela de 5 pontas na frente
  push();
  translate(width / 2, height / 2);
  rotate(-frameCount); // Gira para a esquerda (sentido anti-horário)
  fill(0, 255, 0);
  noStroke();

  beginShape();
  // Para criar a estrela de 5 pontas, percorremos 10 pontos alternando raio maior e menor
  for (let i = 0; i < 10; i++) {
    let ang = i * 36; // 360° / 10 = 36°
    // Raio maior nos pontos pares (pontas), menor nos pontos ímpares
    let raio = (i % 2 === 0) ? 50 : 20;
    let x = raio * cos(ang);
    let y = raio * sin(ang);
    vertex(x, y);
  }
  endShape(CLOSE);
  pop();
}
"
"2589681","Living Fractal Sphere","mySketch","let DETAIL = 20;           // Number of lat/lon divisions for the sphere
let RADIUS = 200;          // Base radius of the sphere
let NOISE_SCALE = 0.8;     // Scales the noise offset
let NOISE_SPEED = 0.0015;  // Speed for noise evolution
let ROTATION_SPEED = 0.002; // Speed of overall sphere rotation

let stars = [];
let NUM_STARS = 50;       // Number of star points in the background

// Orbital bodies
let orbiters = [];
let NUM_ORBITERS = 12;     // Number of small orbiting spheres
let orbiterRadius = 12;    // Radius for each small orbiter
let orbiterDistance = 350; // Distance of orbit from center
let orbiterSpeed = 0.01;   // Orbital rotation speed

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  noStroke();
  colorMode(HSB, 360, 100, 100, 100);

  // Initialize star positions
  for (let i = 0; i < NUM_STARS; i++) {
    let angle = random(TWO_PI);
    let dist = random(200, 2000); // random distance for a star
    let x = cos(angle) * dist;
    let y = sin(angle) * dist;
    let z = random(-1500, 1500);
    stars.push({ x, y, z });
  }
  
  // Initialize orbital bodies
  for (let i = 0; i < NUM_ORBITERS; i++) {
    orbiters.push({
      angle: random(TWO_PI),
      speed: orbiterSpeed * random(0.5, 1.5), // give some variation in orbital speed
      colorOffset: random(360),
    });
  }
}

function draw() {
  background(0);
  // Mild camera rotation for a slow cosmic swirl
  rotateY(frameCount * 0.0005);
  rotateX(frameCount * 0.0002);

  // Draw the swirling starfield behind everything
  push();
  for (let i = 0; i < stars.length; i++) {
    let s = stars[i];
    push();
    // Slightly rotate each star around Y-axis to give swirling effect
    let rx = s.x * cos(frameCount * 0.0002) - s.z * sin(frameCount * 0.0002);
    let rz = s.z * cos(frameCount * 0.0002) + s.x * sin(frameCount * 0.0002);
    translate(rx, s.y, rz);
    strokeWeight(0.5);
    stroke(200, 80, 100);
    point(0, 0, 0);
    pop();
  }
  pop();

  // Some lighting for the main shape
  ambientLight(60);
  directionalLight(255, 255, 255, 0.2, 0.2, -1);

  // Rotate the ""living fractal sphere""
  push();
  rotateY(frameCount * ROTATION_SPEED);
  // Optionally, rotate around X or Z for a more dynamic effect
  rotateX(frameCount * ROTATION_SPEED * 0.5);
  drawFractalSphere(RADIUS, DETAIL);
  pop();

  // Draw orbiters around the fractal sphere
  push();
  for (let i = 0; i < orbiters.length; i++) {
    let o = orbiters[i];
    o.angle += o.speed; // update the angle of rotation
    let ox = orbiterDistance * cos(o.angle);
    let oz = orbiterDistance * sin(o.angle);
    // color shift
    let hueVal = (frameCount * 0.1 + o.colorOffset) % 360;

    push();
    translate(ox, 0, oz);
    fill(hueVal, 80, 100);
    sphere(orbiterRadius * (0.8 + 0.4 * sin(frameCount * 0.02 + i)));
    pop();
  }
  pop();
}

function drawFractalSphere(baseRadius, detail) {
  let time = frameCount * NOISE_SPEED; // controls noise evolution

  // We'll iterate over spherical coordinates: lat and lon
  for (let lat = 0; lat < detail; lat++) {
    let theta1 = map(lat, 0, detail, 0, PI);
    let theta2 = map(lat + 1, 0, detail, 0, PI);

    beginShape(TRIANGLE_STRIP);
    for (let lon = 0; lon <= detail; lon++) {
      let phi = map(lon, 0, detail, 0, TWO_PI);

      // Vertex A (lat)
      let xA = sin(theta1) * cos(phi);
      let yA = cos(theta1);
      let zA = sin(theta1) * sin(phi);
      
      // Displace radius by Perlin noise
      let rA = baseRadius + 40 * noise(
        xA * NOISE_SCALE + 100, 
        yA * NOISE_SCALE + 200, 
        zA * NOISE_SCALE + 300 + time
      );
      xA *= rA; 
      yA *= rA; 
      zA *= rA; 

      // Vertex B (lat+1)
      let xB = sin(theta2) * cos(phi);
      let yB = cos(theta2);
      let zB = sin(theta2) * sin(phi);

      let rB = baseRadius + 40 * noise(
        xB * NOISE_SCALE + 100, 
        yB * NOISE_SCALE + 200, 
        zB * NOISE_SCALE + 300 + time
      );
      xB *= rB; 
      yB *= rB; 
      zB *= rB; 

      // Color is based on the 3D noise displacement, giving swirl patterns
      let hueVal = map(rA, baseRadius, baseRadius + 40, 180, 360);
      fill(hueVal % 360, 80, 100, 100);

      vertex(xA, yA, zA);
      vertex(xB, yB, zB);
    }
    endShape();
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2586960","Workshop Pestana","mySketch","function setup() {
  createCanvas(400, 400);
  angleMode(DEGREES);
  noStroke();
}

function draw() {
  background(0);
  
  // Efeitos piscando (simples ""pontos"" coloridos aleatórios pelo fundo)
  for (let i = 0; i < 20; i++) {
    fill(random(255), random(255), random(255));
    circle(random(width), random(height), random(5, 15));
  }
  
  // Desenha a estrela verde no centro
  push();
  translate(width / 2, height / 2);
  fill(0, 255, 0);
  
  // Parte superior do hexagrama (triângulo)
  beginShape();
  vertex(0, -50);
  vertex(43.3, 25);
  vertex(-43.3, 25);
  endShape(CLOSE);
  
  // Parte inferior do hexagrama (triângulo invertido)
  beginShape();
  vertex(0, 50);
  vertex(43.3, -25);
  vertex(-43.3, -25);
  endShape(CLOSE);
  
  // Duas bolinhas rosas girando em volta da estrela
  let raio = 80;
  let angulo = frameCount * 2;

  // Primeira bolinha
  let x1 = raio * cos(angulo);
  let y1 = raio * sin(angulo);
  fill(255, 192, 203);
  circle(x1, y1, 15);
  
  // Segunda bolinha (oposta à primeira, 180 graus)
  let x2 = raio * cos(angulo + 180);
  let y2 = raio * sin(angulo + 180);
  circle(x2, y2, 15);
  
  pop();
}
"
"2575967","Centric Kaleidoscopic","mySketch","// Epic Kaleidoscopic Experience in p5.js
// A completely different visual adventure featuring evolving gradients and rotating, noise‐distorted polygons.
// Works on any screen, desktop or mobile, and is optimized for smooth performance.

let numLayers = 5;

function setup() {
  createCanvas(windowWidth, windowHeight);
  angleMode(DEGREES);
  // Use HSB to create vivid, shifting colors.
  colorMode(HSB, 360, 100, 100, 100);
  noFill();
  strokeWeight(2);
}

function draw() {
  // Smooth trailing effect with a translucent black background
  background(0, 0, 0, 20);
  
  // --- Evolving Background Gradient ---
  push();
  translate(width / 2, height / 2);
  // The background gradient circle spans most of the smaller screen dimension.
  let bgRadius = min(width, height) * 0.8;
  let gradientSteps = 50;
  for (let i = gradientSteps; i > 0; i--) {
    let inter = map(i, 0, gradientSteps, 0, 1);
    let r = bgRadius * inter;
    noStroke();
    // Slowly shifting hues with a very low opacity creates a luminous glow.
    fill((frameCount * 0.2 + i * 3) % 360, 50, 100, 10);
    ellipse(0, 0, r, r);
  }
  pop();
  
  // --- Rotating Kaleidoscope of Irregular Polygons ---
  translate(width / 2, height / 2);
  let numSymmetries = 8;
  for (let i = 0; i < numSymmetries; i++) {
    push();
    // Each symmetry segment rotates continuously.
    rotate((360 / numSymmetries) * i + frameCount * 0.3);
    
    // Draw multiple layers of noise-distorted polygons
    for (let layer = 1; layer <= numLayers; layer++) {
      // Base radius increases with each layer.
      let baseRadius = layer * 40;
      // If the mouse is pressed, amplify the effect for interactivity.
      if (mouseIsPressed) {
        baseRadius *= 1.5;
      }
      // Set stroke color with shifting hues.
      stroke((frameCount + layer * 50) % 360, 80, 100, 70);
      beginShape();
      // Create a polygon with noise-modulated vertices for organic distortion.
      let vertices = 12;
      for (let j = 0; j < vertices; j++) {
        let angle = map(j, 0, vertices, 0, 360);
        // Use noise to perturb the radius of each vertex.
        let noiseVal = noise(layer * 10, j * 0.5, frameCount * 0.01);
        let r = baseRadius + noiseVal * 30;
        let x = r * cos(angle);
        let y = r * sin(angle);
        vertex(x, y);
      }
      endShape(CLOSE);
    }
    pop();
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2575960","Centric flows","mySketch","// Epic p5.js Visual Experience for OpenProcessing
// No external files required – fully responsive and optimized for desktop and mobile

let particles = [];
let numParticles;

function setup() {
  // Create a canvas that fills the window and optimize pixel density for performance
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  colorMode(HSB, 360, 100, 100, 100);
  background(0);
  
  // Dynamically set the number of particles based on screen size (capped for performance)
  numParticles = min(1000, floor((width * height) / 2500));
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  // Draw a translucent black rectangle to gradually fade the previous frame,
  // creating smooth trails without overloading the CPU.
  noStroke();
  fill(0, 0, 0, 15);
  rect(0, 0, width, height);
  
  // Draw a central rotating epic shape for added visual impact
  push();
  translate(width / 2, height / 2);
  rotate(frameCount * 0.01);
  noFill();
  stroke(200, 80, 100);
  strokeWeight(2);
  // Draw concentric circles
  for (let i = 0; i < 10; i++) {
    ellipse(0, 0, 50 + i * 30, 50 + i * 30);
  }
  pop();
  
  // Use additive blend mode for luminous particle trails
  blendMode(ADD);
  for (let p of particles) {
    p.update();
    p.show();
  }
  blendMode(BLEND);
}

class Particle {
  constructor() {
    // Start each particle at a random location on the canvas
    this.pos = createVector(random(width), random(height));
    this.prevPos = this.pos.copy();
    // Random speed to add variety in movement
    this.speed = random(1, 3);
    // Initialize with a random hue value for vibrant trails
    this.hue = random(360);
  }
  
  update() {
    // Use Perlin noise to determine a dynamic angle for fluid motion
    let angle = noise(this.pos.x * 0.005, this.pos.y * 0.005, frameCount * 0.005) * TWO_PI * 2;
    let velocity = p5.Vector.fromAngle(angle);
    velocity.setMag(this.speed);
    this.pos.add(velocity);
    
    // If the mouse is pressed, add a subtle attraction force towards the pointer
    if (mouseIsPressed) {
      let mouseVec = createVector(mouseX, mouseY);
      let attraction = p5.Vector.sub(mouseVec, this.pos);
      attraction.setMag(0.2);
      this.pos.add(attraction);
    }
    
    // Wrap particles around screen edges to ensure continuous flow
    if (this.pos.x > width) {
      this.pos.x = 0;
      this.prevPos = this.pos.copy();
    }
    if (this.pos.x < 0) {
      this.pos.x = width;
      this.prevPos = this.pos.copy();
    }
    if (this.pos.y > height) {
      this.pos.y = 0;
      this.prevPos = this.pos.copy();
    }
    if (this.pos.y < 0) {
      this.pos.y = height;
      this.prevPos = this.pos.copy();
    }
    
    // Gradually cycle through hues for a mesmerizing color effect
    this.hue = (this.hue + 0.5) % 360;
  }
  
  show() {
    // Draw a line from the previous position to the current position for a trail effect
    stroke(this.hue, 80, 100, 50);
    strokeWeight(2);
    line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
    // Update previous position for the next frame's trail
    this.prevPos = this.pos.copy();
  }
}

function windowResized() {
  // Resize the canvas when the window size changes and clear the background
  resizeCanvas(windowWidth, windowHeight);
  background(0);
}
"
"2575953","Workshop CST","mySketch","// Declarações de variáveis globais
let angle = 0;          // Ângulo de rotação da estrela
let sparkleCount = 150; // Quantidade de bolinhas cintilantes
let sparkles = [];      // Array para armazenar as bolinhas cintilantes

function setup() {
  createCanvas(windowWidth, windowHeight);
  // Inicializa as bolinhas cintilantes em posições aleatórias
  for (let i = 0; i < sparkleCount; i++) {
    sparkles.push({
      x: random(width),
      y: random(height),
      size: random(3, 10)
    });
  }
}

function draw() {
  background(0, 255, 0); // Fundo verde (R=0, G=255, B=0)

  // Desenha as bolinhas piscantes
  noStroke();
  for (let i = 0; i < sparkles.length; i++) {
    let s = sparkles[i];
    // Varia a opacidade para criar um “brilho” aleatório
    fill(255, 255, 255, random(50, 255));
    circle(s.x, s.y, s.size);
  }

  // Translada e rotaciona o canvas para desenhar a estrela no centro
  push();
  translate(width / 2, height / 2);
  rotate(angle);
  // Aumenta o ângulo para girar para a direita
  angle += 0.01;
  
  // Desenha a estrela azul de 16 pontas
  fill(0, 0, 255); // Azul
  stroke(0, 0, 128); // Traço azul-escuro para dar mais contraste
  strokeWeight(2);
  beginShape();
  let points = 16;
  let outerRadius = min(width, height) * 0.2; // Ajusta ao tamanho da tela
  let innerRadius = outerRadius * 0.4;
  for (let i = 0; i < points; i++) {
    let angleStep = TWO_PI / points;
    // Ponta externa
    let x1 = cos(i * angleStep) * outerRadius;
    let y1 = sin(i * angleStep) * outerRadius;
    vertex(x1, y1);
    // Ponta interna
    let x2 = cos(i * angleStep + angleStep / 2) * innerRadius;
    let y2 = sin(i * angleStep + angleStep / 2) * innerRadius;
    vertex(x2, y2);
  }
  endShape(CLOSE);
  pop();
}

// Função para redimensionar a tela ao mudar de tamanho
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2574544","Workshop ISCTE","mySketch","function setup() {
  // Cria a tela ajustada ao tamanho da janela
  createCanvas(windowWidth, windowHeight);
  angleMode(DEGREES);
}

function draw() {
  // Fundo azul-escuro
  background(0, 0, 139); 

  // Translada para o centro do canvas
  translate(width / 2, height / 2);

  // Rotação para a esquerda (ângulo negativo)
  rotate(-frameCount);

  // Desenha a estrela de 5 pontas
  fill(255, 255, 0);  // Cor amarela
  noStroke();

  beginShape();
  for (let i = 0; i < 10; i++) {
    // Para criar 5 pontas, usamos 10 vértices (ponta externa e interna)
    let angle = map(i, 0, 10, 0, 360);
    let radius = i % 2 === 0 ? 80 : 35; 
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    vertex(x, y);
  }
  endShape(CLOSE);
}

// Ajusta o tamanho do canvas se a janela for redimensionada
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2523221","Magnetic Repulsion","mySketch","const sketch = (p) => {
    let particles = [];
    const gridSize = 60;
    let spatialGrid = {};
    let canvas;

    class Particle {
        constructor() {
            this.pos = p.createVector(p.width/2 + p.random(-50,50), p.height/2 + p.random(-50,50));
            this.prevPos = this.pos.copy();
            this.vel = p.createVector(p.random(-1,1), p.random(-1,1));
            this.acc = p.createVector();
            this.radius = p.random(2,4);
            this.hue = p.random(100, 300);
        }

        updatePosition() {
            const temp = this.pos.copy();
            this.vel = this.pos.copy().sub(this.prevPos);
            this.pos.add(this.vel.add(this.acc));
            this.prevPos = temp;
            this.acc.mult(0);
        }

        applyForce(f) {
            this.acc.add(f);
        }
    }

    p.setup = () => {
        canvas = p.createCanvas(p.windowWidth, p.windowHeight);
        canvas.style('display', 'block');
        p.colorMode(p.HSB, 360);
        p.noStroke();
        
        const density = p.windowWidth < 600 ? 2 : 3;
        const particleCount = Math.floor(p.width * p.height / (gridSize * gridSize * density));
        
        for(let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }
    };

    p.draw = () => {
        p.background(0, 0.1);
        buildSpatialGrid();
        
        particles.forEach(particle => {
            applyForces(particle);
            particle.updatePosition();
            handleBoundaries(particle);
            drawParticle(particle);
        });
    };

    function buildSpatialGrid() {
        spatialGrid = {};
        particles.forEach(particle => {
            const x = Math.floor(particle.pos.x / gridSize);
            const y = Math.floor(particle.pos.y / gridSize);
            const key = `${x},${y}`;
            
            if(!spatialGrid[key]) spatialGrid[key] = [];
            spatialGrid[key].push(particle);
        });
    }

    function applyForces(particle) {
        const mouse = p.createVector(p.mouseX, p.mouseY);
        const toMouse = p5.Vector.sub(mouse, particle.pos);
        const mouseDist = toMouse.mag();
        
        // Magnetic repulsion from mouse
        if(mouseDist < 150) {
            const force = toMouse.mult(-0.2 / mouseDist);
            particle.applyForce(force);
        }

        // Central gravitational pull
        const center = p.createVector(p.width/2, p.height/2);
        const toCenter = p5.Vector.sub(center, particle.pos);
        particle.applyForce(toCenter.mult(0.0001));

        // Particle interactions
        const x = Math.floor(particle.pos.x / gridSize);
        const y = Math.floor(particle.pos.y / gridSize);
        
        for(let xi = x-1; xi <= x+1; xi++) {
            for(let yi = y-1; yi <= y+1; yi++) {
                const neighbors = spatialGrid[`${xi},${yi}`] || [];
                neighbors.forEach(other => {
                    if(particle !== other) {
                        const dir = p5.Vector.sub(particle.pos, other.pos);
                        const dist = dir.mag();
                        if(dist < gridSize) {
                            const force = dir.normalize().mult(0.2 * (1 - dist/gridSize));
                            particle.applyForce(force);
                        }
                    }
                });
            }
        }
    }

    function handleBoundaries(particle) {
        if(particle.pos.x < 0 || particle.pos.x > p.width) {
            particle.pos.x = p.constrain(particle.pos.x, 0, p.width);
            particle.prevPos.x = particle.pos.x - particle.vel.x * 0.5;
        }
        if(particle.pos.y < 0 || particle.pos.y > p.height) {
            particle.pos.y = p.constrain(particle.pos.y, 0, p.height);
            particle.prevPos.y = particle.pos.y - particle.vel.y * 0.5;
        }
    }

    function drawParticle(particle) {
        const speed = particle.vel.mag();
        const alpha = p.map(speed, 0, 2, 50, 200);
        const size = p.map(speed, 0, 3, particle.radius, particle.radius*3);
        
        p.fill(particle.hue, 300, 300, alpha/360);
        p.ellipse(particle.pos.x, particle.pos.y, size);
    }

    p.windowResized = () => {
        p.resizeCanvas(p.windowWidth, p.windowHeight);
    };
};

new p5(sketch, document.body);"
"2517433","Illusoria","mySketch","/**
Illusoria - by Gonçalo Perdigão from Building Creative Machines
""Illusion"" ✨ #WCCChallenge
 */

let angleOffset = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();
}

function draw() {
  background(255);

  // Calculate quadrant sizes
  let w = width / 2;
  let h = height / 2;

  // Top-left: Rotating Snakes
  push();
  translate(0, 0);
  drawRotatingSnakes(w, h);
  pop();

  // Top-right: Hermann Grid
  push();
  translate(w, 0);
  drawHermannGrid(w, h);
  pop();

  // Bottom-left: Ponzo Illusion
  push();
  translate(0, h);
  drawPonzo(w, h);
  pop();

  // Bottom-right: Ebbinghaus Illusion
  push();
  translate(w, h);
  drawEbbinghaus(w, h);
  pop();

  // Update angle offset for Rotating Snakes
  angleOffset += 0.01;
}

//------------------ ROTATING SNAKES ILLUSION ------------------//
function drawRotatingSnakes(w, h) {
  // This illusion is inspired by the rotating snakes concept:
  // Color arcs arranged in rings can trick the eye into seeing movement.
  // We'll create multiple rings with arcs that are slightly rotated each frame.
  
  // Center the drawing in this quadrant
  push();
  translate(w / 2, h / 2);

  let maxRings = 4;      // Number of concentric rings
  let ringSpacing = min(w, h) / 10;
  let arcCount = 12;     // Number of arcs per ring

  for (let r = 1; r <= maxRings; r++) {
    let radius = r * ringSpacing;
    for (let i = 0; i < arcCount; i++) {
      let arcAngle = TWO_PI / arcCount;
      let startA = i * arcAngle + angleOffset * r;
      
      // Alternate fill colors to enhance the illusion
      fill(
        map(i % 3, 0, 2, 50, 200), 
        map(r, 1, maxRings, 50, 180), 
        map(i, 0, arcCount, 180, 50)
      );

      arc(0, 0, radius, radius, startA, startA + arcAngle / 2);
    }
  }
  pop();
}

//------------------ HERMANN GRID ILLUSION ------------------//
function drawHermannGrid(w, h) {
  // The Hermann Grid illusion makes grey spots appear, for human eye, at the intersections of a high-contrast grid.
  
  // Define how many cells across and down
  let cols = 6;
  let rows = 6;
  let cellW = w / cols;
  let cellH = h / rows;

  fill(0);
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      // Draw black squares; the white lines between them trigger the illusion
      rect(x * cellW, y * cellH, cellW * 0.9, cellH * 0.9);
    }
  }
}

//------------------ PONZO ILLUSION ------------------//
function drawPonzo(w, h) {
  // The Ponzo illusion uses converging lines to make two same-length bars appear different in size.

  // Draw converging lines
  stroke(0);
  strokeWeight(2);
  let margin = w * 0.15;
  line(margin, h * 0.1, w - margin, h * 0.9);
  line(w - margin, h * 0.1, margin, h * 0.9);

  // Bars that are actually the same width
  let barW = w * 0.4;
  let barH = h * 0.05;
  noStroke();
  fill(120);

  // Upper bar
  rectMode(CENTER);
  rect(w / 2, h * 0.3, barW, barH);

  // Lower bar
  rect(w / 2, h * 0.7, barW, barH);
}

//------------------ EBBINGHAUS ILLUSION ------------------//
function drawEbbinghaus(w, h) {
  // The Ebbinghaus illusion makes two identical circles appear to be different in size based on surrounding circles. This one is an absolute classic
  
  // Center positions for the two main circles
  let leftX = w * 0.3;
  let rightX = w * 0.7;
  let centerY = h * 0.5;
  let mainSize = min(w, h) * 0.08;

  // Left circle's large outer circles
  fill(150, 100, 200);
  let bigRingCount = 6;
  let bigRadius = mainSize * 2;
  for (let i = 0; i < bigRingCount; i++) {
    let angle = TWO_PI * i / bigRingCount;
    let x = leftX + cos(angle) * bigRadius;
    let y = centerY + sin(angle) * bigRadius;
    ellipse(x, y, mainSize * 1.4);
  }

  // Right circle's small outer circles
  fill(100, 200, 150);
  let smallRingCount = 8;
  let smallRadius = mainSize * 1.2;
  for (let i = 0; i < smallRingCount; i++) {
    let angle = TWO_PI * i / smallRingCount;
    let x = rightX + cos(angle) * smallRadius;
    let y = centerY + sin(angle) * smallRadius;
    ellipse(x, y, mainSize * 0.6);
  }

  // Main circles (identical in size)
  fill(255, 0, 0);
  ellipse(leftX, centerY, mainSize);
  ellipse(rightX, centerY, mainSize);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2499059","Happy 2025","mySketch","//2025 New Year's Celebration

let fireworks = [];
let confetti = [];
let stars = [];
let gravity;
let globalHue = 0;
let textWave = 0;
let colorShiftSpeed = 0.5; // Speed for hue shifting

// Particle for fireworks
class Particle {
  constructor(x, y, color, vel, isFirework = false) {
    this.pos = createVector(x, y);
    this.vel = vel.copy();
    this.acc = createVector(0, 0);
    this.lifespan = 255;
    this.isFirework = isFirework;
    this.color = color;
  }

  applyForce(force) {
    this.acc.add(force);
  }

  update() {
    if (!this.isFirework) {
      this.vel.mult(0.98); 
      this.lifespan -= 4;  
    }
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  done() {
    return (this.lifespan < 0);
  }

  show() {
    colorMode(HSB, 360, 100, 100, 255);
    strokeWeight(this.isFirework ? 4 : 2);
    stroke(
      (hue(this.color) + globalHue) % 360,
      saturation(this.color),
      brightness(this.color),
      this.lifespan
    );
    point(this.pos.x, this.pos.y);
  }
}

// Firework class
class Firework {
  constructor() {
    this.firework = new Particle(
      random(width),
      height + random(0, 50),
      color(random(360), 100, 100),
      createVector(0, random(-15, -12)),
      true
    );
    this.exploded = false;
    this.particles = [];
  }

  update() {
    if (!this.exploded) {
      this.firework.applyForce(gravity);
      this.firework.update();
      
      // Once the 'rocket' slows down, explode
      if (this.firework.vel.y >= 0) {
        this.exploded = true;
        this.explode();
      }
    }

    for (let i = this.particles.length - 1; i >= 0; i--) {
      this.particles[i].applyForce(gravity);
      this.particles[i].update();
      if (this.particles[i].done()) {
        this.particles.splice(i, 1);
      }
    }
  }

  explode() {
    // Generate many sparkly particles in a circular blast
    let total = random(80, 120);
    for (let i = 0; i < total; i++) {
      let angle = random(TWO_PI);
      let speed = random(2, 6);
      let vel = p5.Vector.fromAngle(angle);
      vel.mult(speed);
      let p = new Particle(
        this.firework.pos.x,
        this.firework.pos.y,
        this.firework.color,
        vel
      );
      this.particles.push(p);
    }
  }

  done() {
    return this.exploded && this.particles.length === 0;
  }

  show() {
    if (!this.exploded) {
      this.firework.show();
    }
    for (let p of this.particles) {
      p.show();
    }
  }
}

// Confetti class for swirling color chips
class Confetti {
  constructor() {
    this.x = random(width);
    this.y = random(-height, 0);
    this.size = random(5, 12);
    this.angle = random(TWO_PI);
    this.speed = random(0.5, 2);
    this.spin = random(-0.1, 0.1);
    this.hue = random(360);
  }

  update() {
    this.angle += this.spin;
    this.y += this.speed;
    if (this.y > height) {
      this.y = random(-50, 0);
      this.x = random(width);
    }
  }

  show() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);
    colorMode(HSB, 360, 100, 100);
    fill((this.hue + globalHue) % 360, 80, 90);
    noStroke();
    rectMode(CENTER);
    rect(0, 0, this.size, this.size * 1.2);
    pop();
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100);
  gravity = createVector(0, 0.15);

  // Create an initial set of fireworks
  for (let i = 0; i < 5; i++) {
    fireworks.push(new Firework());
  }

  // Create stars for the background
  for (let i = 0; i < 200; i++) {
    let star = {
      x: random(width),
      y: random(height),
      brightness: random(20, 80),
      size: random(1, 3),
      twinkleSpeed: random(0.01, 0.05),
      offset: random(TWO_PI)
    };
    stars.push(star);
  }

  // Populate confetti array
  for (let i = 0; i < 150; i++) {
    confetti.push(new Confetti());
  }
}

function draw() {
  // Translucent background for trailing
  background(0, 0, 0, 20);
  drawStars();

  // Update global hue for color shifting
  globalHue += colorShiftSpeed;
  
  // Fireworks
  for (let i = fireworks.length - 1; i >= 0; i--) {
    fireworks[i].update();
    fireworks[i].show();
    if (fireworks[i].done()) {
      fireworks.splice(i, 1);
    }
  }

  // Occasionally add new fireworks
  if (random(1) < 0.02) {
    fireworks.push(new Firework());
  }

  // Confetti swirl
  for (let c of confetti) {
    c.update();
    c.show();
  }

  // Waving ""HAPPY 2025"" text
  drawNewYearMessage();
}

function drawStars() {
  // Draw starfield
  noStroke();
  fill(255);
  for (let star of stars) {
    let twinkle = sin(frameCount * star.twinkleSpeed + star.offset) * 0.5 + 0.5;
    let alphaVal = map(twinkle, 0, 1, 50, 255);
    fill(255, alphaVal);
    ellipse(star.x, star.y, star.size, star.size);
  }
}

function drawNewYearMessage() {
  // Fun wave animation for the text
  push();
  textWave += 0.02;
  let waveOffset = sin(textWave) * 10;
  
  textAlign(CENTER, CENTER);
  textSize(min(width, height) / 8);
  fill((globalHue) % 360, 100, 100);
  stroke(0);
  strokeWeight(2);
  
  // Slight vertical wave movement
  let centerY = height / 2 + waveOffset;
  text(""HAPPY 2025"", width / 2, centerY);
  pop();
}

// Click/tap spawns fireworks
function mousePressed() {
  fireworks.push(new Firework());
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2499048","Generative Landscapes","mySketch","// ""Generative Landscapes"" ⛰️ #WCCChallenge by Gonçalo Perdigão from ""Building Creative Machines""

let NUM_LAYERS = 7;          // Number of mountain layers
let LAYER_HEIGHT_FACTOR = 0.22;  // Vertical space each layer occupies
let NOISE_SCALE = 0.0015;    // Controls horizontal noise detail
let NOISE_DETAIL = 0.001;    // Controls vertical noise detail
let colorPalettes = [];      // Array holding possible color palettes
let currentPalette = [];     // Currently chosen color palette
let seed;                    // Random seed to regenerate

let timeOffset = 0;          // Global time offset for animation
let speed = 0.08;          // Base speed for the animation
let colorShiftSpeed = 0.02; // Speed for color shifts

let baseHue = 0;             // Base hue for color transformations
let hueVariation = 60;       // Range of hue offset for each layer

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);
  initializeColorPalettes();
  regenerateLandscape();
}

function draw() {
  background(0, 0, 0);
  
  // Slowly shift the base hue to create a dynamic color environment
  baseHue += colorShiftSpeed * deltaTime;
  
  // Sky gradient (from dawn to dusk-like)
  drawSkyGradient();

  // Draw mountains from back (lightest) to front (darkest)
  for (let i = 0; i < NUM_LAYERS; i++) {
    let layerIndex = NUM_LAYERS - 1 - i; // draw from back to front
    drawMountainLayer(layerIndex);
  }
  
  timeOffset += speed * deltaTime;
}

// Draw a simple sky gradient behind the mountains
function drawSkyGradient() {
  let c1 = color(
    (baseHue + 200) % 360, 40, 30
  );
  let c2 = color(
    (baseHue + 280) % 360, 80, 70
  );
  
  for (let y = 0; y < height; y++) {
    let inter = map(y, 0, height, 0, 1);
    let c = lerpColor(c1, c2, inter);
    stroke(c);
    line(0, y, width, y);
  }
}

// Draw a single mountain layer using Perlin noise
function drawMountainLayer(layerIndex) {
  noStroke();
  
  // The further back the layer is, the lighter in color
  let paletteColor = currentPalette[layerIndex % currentPalette.length];
  
  // Additional dynamic hue shift based on baseHue
  let h = (hue(paletteColor) + baseHue) % 360;
  let s = saturation(paletteColor);
  let b = brightness(paletteColor);
  
  fill(h, s, b);
  
  beginShape();
  
  // Start from the bottom-left corner
  vertex(0, height);
  
  let layerOffset = map(layerIndex, 0, NUM_LAYERS - 1, 0, 1);
  let verticalPos = height * (1 - LAYER_HEIGHT_FACTOR * layerOffset);
  
  // Modify the vertical position with the mouse’s Y and random noise
  let mouseFactorY = map(mouseY, 0, height, -80, 80);
  
  for (let x = 0; x <= width; x += 2) {
    let noiseVal = noise(
      (x * NOISE_SCALE) + (layerIndex * 100),
      (timeOffset + layerIndex * 100) * NOISE_DETAIL
    );
    
    let yOff = map(noiseVal, 0, 1, -180, 180);
    let finalY = verticalPos + yOff + mouseFactorY * (layerIndex / NUM_LAYERS);
    vertex(x, finalY);
  }
  
  // Connect to the bottom-right corner
  vertex(width, height);
  endShape(CLOSE);
}

// Initialize some color palettes (HSB) for variety
function initializeColorPalettes() {
  colorPalettes = [
    // Earthy Tones
    [
      color(20, 80, 60),
      color(40, 80, 70),
      color(60, 80, 80),
      color(80, 80, 70),
      color(100, 80, 60),
      color(120, 80, 50)
    ],
    // Vibrant Sunset
    [
      color(5, 90, 90),
      color(25, 90, 90),
      color(45, 90, 80),
      color(65, 90, 70),
      color(85, 90, 60),
      color(105, 70, 50)
    ],
    // Cool Mountains
    [
      color(180, 40, 90),
      color(200, 40, 80),
      color(220, 40, 70),
      color(240, 40, 60),
      color(260, 40, 50),
      color(280, 40, 40)
    ],
    // Pastel Dream
    [
      color(300, 30, 95),
      color(330, 30, 85),
      color(0, 30, 75),
      color(30, 30, 65),
      color(60, 30, 55),
      color(90, 30, 45)
    ]
  ];
}

// Resets the random seed, picks a color palette randomly, etc.
function regenerateLandscape() {
  seed = floor(random(100000));
  randomSeed(seed);
  noiseSeed(seed);
  
  // Pick a random color palette
  currentPalette = random(colorPalettes);

  // Slight random shuffle of the palette (for variation)
  if (random() < 0.5) {
    currentPalette.reverse();
  }
}

// If the user clicks/taps or presses space, regenerate
function mousePressed() {
  regenerateLandscape();
}

function keyPressed() {
  if (key === ' ' || key === 'Space') {
    regenerateLandscape();
  }
}

// Make it responsive
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2490413","Emergent Swarm Biology","mySketch","let particles = [];
let numParticles = 100;
let maxForce = 0.03;
let perceptionRadius = 50;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }
}

function draw() {
  background(10, 20);
  for (let p of particles) {
    p.flock(particles);
    p.update();
    p.edges();
    p.show();
  }
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 2;
  }

  flock(particles) {
    let alignment = this.align(particles);
    let cohesion = this.cohere(particles);
    let separation = this.separate(particles);

    alignment.mult(1.0); // Tendency to align direction
    cohesion.mult(0.7);  // Attraction to others
    separation.mult(1.5); // Avoid crowding

    this.acc.add(alignment);
    this.acc.add(cohesion);
    this.acc.add(separation);
  }

  align(particles) {
    let avgVel = createVector();
    let count = 0;
    for (let other of particles) {
      let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
      if (other !== this && d < perceptionRadius) {
        avgVel.add(other.vel);
        count++;
      }
    }
    if (count > 0) {
      avgVel.div(count);
      avgVel.setMag(this.maxSpeed);
      avgVel.sub(this.vel);
      avgVel.limit(maxForce);
    }
    return avgVel;
  }

  cohere(particles) {
    let center = createVector();
    let count = 0;
    for (let other of particles) {
      let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
      if (other !== this && d < perceptionRadius) {
        center.add(other.pos);
        count++;
      }
    }
    if (count > 0) {
      center.div(count);
      let desired = p5.Vector.sub(center, this.pos);
      desired.setMag(this.maxSpeed);
      let steer = p5.Vector.sub(desired, this.vel);
      steer.limit(maxForce);
      return steer;
    }
    return createVector();
  }

  separate(particles) {
    let steer = createVector();
    let count = 0;
    for (let other of particles) {
      let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
      if (other !== this && d < perceptionRadius / 2) {
        let diff = p5.Vector.sub(this.pos, other.pos);
        diff.div(d);
        steer.add(diff);
        count++;
      }
    }
    if (count > 0) {
      steer.div(count);
      steer.setMag(this.maxSpeed);
      steer.sub(this.vel);
      steer.limit(maxForce);
    }
    return steer;
  }

  update() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  edges() {
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }

  show() {
    fill(255, 150);
    ellipse(this.pos.x, this.pos.y, 5, 5);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2490412","Chaotic Quaternion Attractors","mySketch","let particles = [];
let numParticles = 500;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  noFill();
  strokeWeight(1);
  
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  background(10);
  rotateX(sin(t * 0.002) * PI / 4);
  rotateY(cos(t * 0.002) * PI / 4);
  
  stroke(255, 150);
  
  for (let p of particles) {
    p.update();
    p.show();
  }
  
  t += 0.5;
}

class Particle {
  constructor() {
    this.pos = createVector(random(-1, 1), random(-1, 1), random(-1, 1)).mult(100);
    this.vel = createVector();
  }

  update() {
    let q = quaternionAttractor(this.pos, t * 0.001);
    this.vel.set(q.x, q.y, q.z).mult(0.1);
    this.pos.add(this.vel);

    // Wrap around if out of bounds
    let bounds = 300;
    if (this.pos.mag() > bounds) {
      this.pos.set(random(-1, 1), random(-1, 1), random(-1, 1)).mult(100);
    }
  }

  show() {
    point(this.pos.x, this.pos.y, this.pos.z);
  }
}

function quaternionAttractor(p, time) {
  let a = sin(time) * 1.5;
  let b = cos(time * 1.3) * 0.8;
  let c = sin(time * 0.7) * 1.2;
  let d = cos(time * 1.1) * 0.9;

  // Quaternion rotation-based attractor equations
  let x = p.x * (a + b * p.z) + c * p.y * p.z - d * p.y;
  let y = p.y * (b + c * p.x) - a * p.x * p.z + d * p.z;
  let z = p.z * (c + d * p.y) - b * p.x * p.y + a * p.x;

  return createVector(x, y, z).mult(0.005);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2490410","Dynamic Apollonian Flows","mySketch","let particles = [];
let circles = [];
let maxCircles = 10;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noFill();
  strokeWeight(1.5);

  for (let i = 0; i < maxCircles; i++) {
    let r = random(20, height / 4);
    circles.push(new Circle(random(width), random(height), r));
  }
  for (let i = 0; i < 300; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  background(10, 20);

  // Draw circles
  stroke(255, 50);
  for (let c of circles) {
    c.show();
  }

  // Update and show particles
  stroke(255, 200);
  for (let p of particles) {
    p.update(circles);
    p.show();
  }
}

class Circle {
  constructor(x, y, r) {
    this.x = x;
    this.y = y;
    this.r = r;
  }
  show() {
    ellipse(this.x, this.y, this.r * 2);
  }
}

class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = p5.Vector.random2D().mult(random(1, 3));
  }

  update(circles) {
    this.pos.add(this.vel);

    // Reflect off edges
    if (this.pos.x < 0 || this.pos.x > width) this.vel.x *= -1;
    if (this.pos.y < 0 || this.pos.y > height) this.vel.y *= -1;

    // Reflect off circles
    for (let c of circles) {
      let d = dist(this.pos.x, this.pos.y, c.x, c.y);
      if (d < c.r) {
        let normal = createVector(this.pos.x - c.x, this.pos.y - c.y).normalize();
        this.vel.reflect(normal);
        break;
      }
    }
  }

  show() {
    point(this.pos.x, this.pos.y);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2490408","Hypercomplex Möbius Transformations","mySketch","let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noFill();
  strokeWeight(1);
}

function draw() {
  background(10, 20);
  translate(width / 2, height / 2);
  
  let points = 400; // Number of points for the transformation
  let scaleFactor = min(width, height) * 0.35;
  
  stroke(255, 200);
  beginShape();
  for (let i = 0; i < points; i++) {
    let theta = map(i, 0, points, 0, TWO_PI);
    let z = createVector(cos(theta), sin(theta));

    // Apply hypercomplex Möbius transformation
    let transformed = mobiusTransform(z, t);
    let x = transformed.x * scaleFactor;
    let y = transformed.y * scaleFactor;

    vertex(x, y);
  }
  endShape(CLOSE);

  t += 0.01;
}

// Möbius transformation function: hypercomplex dynamic flow
function mobiusTransform(z, t) {
  let a = createVector(sin(t) * 0.5, cos(t) * 0.5); // Varying 'a' parameter
  let b = createVector(cos(t) * 0.5, -sin(t) * 0.5); 
  let c = createVector(sin(t * 0.5) * 0.3, cos(t * 0.5) * 0.3); 
  let d = createVector(cos(t * 0.5) * 0.3, -sin(t * 0.5) * 0.3);
  
  // Möbius transformation: (a*z + b) / (c*z + d)
  let numerator = complexAdd(complexMult(a, z), b);
  let denominator = complexAdd(complexMult(c, z), d);
  return complexDiv(numerator, denominator);
}

// Complex multiplication
function complexMult(c1, c2) {
  return createVector(c1.x * c2.x - c1.y * c2.y, c1.x * c2.y + c1.y * c2.x);
}

// Complex addition
function complexAdd(c1, c2) {
  return createVector(c1.x + c2.x, c1.y + c2.y);
}

// Complex division
function complexDiv(c1, c2) {
  let denom = c2.x * c2.x + c2.y * c2.y;
  return createVector(
    (c1.x * c2.x + c1.y * c2.y) / denom,
    (c1.y * c2.x - c1.x * c2.y) / denom
  );
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2490406","Quaternion Fractal Waveforms","mySketch","let points = [];
let angle = 0;
let scaleFactor;

function setup() {
  createCanvas(windowWidth, windowHeight);
  scaleFactor = min(width, height) * 0.4;
  generateFractalPoints(6, 0, 0, scaleFactor);
  strokeWeight(1);
}

function draw() {
  background(10);
  translate(width / 2, height / 2);
  rotate(angle);

  stroke(255, 200);
  noFill();

  beginShape();
  for (let p of points) {
    let x = p.x * cos(angle) - p.y * sin(angle);
    let y = p.x * sin(angle) + p.y * cos(angle);
    vertex(x, y);
  }
  endShape(CLOSE);

  angle += 0.005;
}

function generateFractalPoints(depth, x, y, size) {
  if (depth == 0) {
    points.push(createVector(x, y));
    return;
  }

  let s = size / 2;
  generateFractalPoints(depth - 1, x - s, y - s, s);
  generateFractalPoints(depth - 1, x + s, y - s, s);
  generateFractalPoints(depth - 1, x - s, y + s, s);
  generateFractalPoints(depth - 1, x + s, y + s, s);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  points = [];
  scaleFactor = min(width, height) * 0.4;
  generateFractalPoints(6, 0, 0, scaleFactor);
}
"
"2490404","Superellipse Patterns","mySketch","let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noFill();
  strokeWeight(2);
}

function draw() {
  background(0, 20);
  translate(width / 2, height / 2);

  let n = map(sin(t * 0.01), -1, 1, 2, 8); // Superellipse power evolves dynamically
  let a = width * 0.3;
  let b = height * 0.3;

  stroke(255, 200);
  for (let k = 1; k < 8; k++) {
    beginShape();
    for (let angle = 0; angle < TWO_PI; angle += 0.01) {
      let cosPart = pow(abs(cos(angle)), 2 / n) * (cos(angle) > 0 ? 1 : -1);
      let sinPart = pow(abs(sin(angle)), 2 / n) * (sin(angle) > 0 ? 1 : -1);
      let x = a * cosPart * k * 0.15;
      let y = b * sinPart * k * 0.15;
      vertex(x, y);
    }
    endShape(CLOSE);
  }

  t += 1;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2490402","Gravity Orbits","mySketch","let particles = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  for (let i = 0; i < 50; i++) {
    particles.push(new Particle());
  }
  strokeWeight(1.5);
}

function draw() {
  background(0, 10);
  translate(width / 2, height / 2);

  for (let p of particles) {
    p.update();
    p.show();
  }
}

class Particle {
  constructor() {
    this.angle = random(TWO_PI);
    this.radius = random(width * 0.05, width * 0.4);
    this.speed = sqrt(2000 / this.radius); // Physics-based orbital speed
    this.x = cos(this.angle) * this.radius;
    this.y = sin(this.angle) * this.radius;
    this.trail = [];
  }

  update() {
    this.angle += this.speed / this.radius;
    this.x = cos(this.angle) * this.radius;
    this.y = sin(this.angle) * this.radius;

    this.trail.push(createVector(this.x, this.y));
    if (this.trail.length > 50) this.trail.shift();
  }

  show() {
    stroke(255, 100);
    noFill();
    beginShape();
    for (let pos of this.trail) {
      vertex(pos.x, pos.y);
    }
    endShape();
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2490401","Chaotic Colorful Lissajous","mySketch","let t = 0;
let colors = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  noFill();
  strokeWeight(2);
  generateColors();
}

function draw() {
  background(0, 15);
  translate(width / 2, height / 2);
  let a = 3;
  let b = 2;

  for (let i = 0; i < colors.length; i++) {
    stroke(colors[i]);
    beginShape();
    for (let j = 0; j < TWO_PI; j += 0.01) {
      let x = cos(a * j + t * i * 0.01) * (width / 3 - i * 10);
      let y = sin(b * j + t * i * 0.01) * (height / 3 - i * 10);
      vertex(x, y);
    }
    endShape(CLOSE);
  }

  t += 0.05;
}

function generateColors() {
  for (let i = 0; i < 10; i++) {
    colors.push(color(random(255), random(255), random(255), 150));
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2488930","Winter Cycle","mySketch","// ""Winter"" ❄ #WCCChallenge
// by Gonçalo Perdigão www.buildingcreativemachines.com

let font;
let points = [];
let snowflakes = [];
const NUM_SNOWFLAKES = 2500; // Total number of snowflakes
const TARGET_POINTS = []; // Points forming the word ""Winter""
const word = ""WINTER"";
let phase = ""building""; // Current phase: 'building' or 'exploding'
let explosionTimer = 0; // Timer for explosion phase
const explosionDuration = 120; // Frames to wait during explosion (e.g., 120 frames = 2 seconds at 60 FPS)
let fontSize;
let wordBounds;
let centerOffset;

function preload() {
  font = loadFont('https://cdnjs.cloudflare.com/ajax/libs/topcoat/0.8.0/font/SourceCodePro-Regular.otf');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  frameRate(60);
  noStroke();
  
  // Define font size based on canvas size
  fontSize = min(width, height) / 5;
  
  // Get the bounding box of the word to center it
  wordBounds = font.textBounds(word, 0, 0, fontSize);
  
  centerOffset = createVector(
    -wordBounds.x + (width / 2) - (wordBounds.w / 2),
    -wordBounds.y + (height / 2) - (wordBounds.h / 2)
  );
  
  // Get points for the word ""Winter""
  points = font.textToPoints(word, 0, 0, fontSize, {
    sampleFactor: 0.2, // Adjust for point density
    simplifyThreshold: 0
  });
  
  // Shift points to center the word
  for (let pnt of points) {
    let shifted = createVector(pnt.x, pnt.y).add(centerOffset);
    TARGET_POINTS.push(shifted);
  }
  
  // Initialize snowflakes and assign each to a target point
  for (let i = 0; i < NUM_SNOWFLAKES; i++) {
    let target;
    if (i < TARGET_POINTS.length) {
      target = TARGET_POINTS[i];
    } else {
      // Extra snowflakes have random targets near the word
      target = createVector(random(width / 2 - wordBounds.w, width / 2 + wordBounds.w),
                           random(height / 2 - wordBounds.h, height / 2 + wordBounds.h));
    }
    let flake = new Snowflake(target);
    snowflakes.push(flake);
  }
}

function draw() {
  setGradient(0, 0, width, height, color(20, 24, 82), color(135, 206, 235), 'Y_AXIS');
  
  for (let flake of snowflakes) {
    flake.update();
    flake.display();
  }
  
  // Check phase transitions
  if (phase === ""building"") {
    // Check if all snowflakes have reached their targets
    let allAtTargets = snowflakes.every(flake => flake.atTarget);
    if (allAtTargets) {
      phase = ""exploding"";
      explosionTimer = explosionDuration;
      
      // Trigger explosion for all snowflakes
      for (let flake of snowflakes) {
        flake.explode();
      }
    }
  } else if (phase === ""exploding"") {
    explosionTimer--;
    if (explosionTimer <= 0) {
      // Reset snowflakes to start building again
      phase = ""building"";
      for (let flake of snowflakes) {
        flake.reset();
      }
    }
  }
}

// Snowflake class definition
class Snowflake {
  constructor(target) {
    this.initialPosition = createVector(random(width), random(-height, 0));
    this.pos = this.initialPosition.copy();
    this.target = target.copy();
    this.vel = createVector(0, 0);
    this.size = random(2, 5);
    this.opacity = random(150, 255);
    this.atTarget = false;
    this.exploded = false;
  }
  
  update() {
    if (phase === ""building"" && !this.atTarget) {
      // Move towards target with easing
      let force = p5.Vector.sub(this.target, this.pos);
      force.setMag(0.1); // Adjust the magnitude for speed
      this.vel.add(force);
      this.vel.limit(2); // Limit maximum speed
      this.pos.add(this.vel);
      
      // Check if reached target
      if (p5.Vector.dist(this.pos, this.target) < 1) {
        this.pos = this.target.copy();
        this.atTarget = true;
        this.vel.mult(0);
      }
    } else if (phase === ""exploding"") {
      // Explosion phase: snowflakes have velocity from explosion
      this.pos.add(this.vel);
      
      // Optional: Add slight gravity or wind effects during explosion
      // this.vel.y += 0.05; // Gravity
    }
  }
  
  display() {
    fill(255, this.opacity);
    ellipse(this.pos.x, this.pos.y, this.size);
  }
  
  explode() {
    if (!this.exploded) {
      // Calculate direction away from the center of the word
      let center = createVector(width / 2, height / 2);
      let direction = p5.Vector.sub(this.pos, center);
      direction.normalize();
      direction.mult(random(2, 5)); // Explosion speed
      
      this.vel = direction;
      this.exploded = true;
    }
  }
  
  reset() {
    // Reset position to initial and clear state
    this.pos = this.initialPosition.copy();
    this.atTarget = false;
    this.exploded = false;
    this.vel = createVector(0, 0);
  }
}

// Function to create a vertical or horizontal gradient
function setGradient(x, y, w, h, c1, c2, axis) {
  noFill();

  if (axis === 'Y_AXIS') {  // Top to bottom gradient
    for (let i = y; i <= y + h; i++) {
      let inter = map(i, y, y + h, 0, 1);
      let c = lerpColor(c1, c2, inter);
      stroke(c);
      line(x, i, x + w, i);
    }
  } else if (axis === 'X_AXIS') {  // Left to right gradient
    for (let i = x; i <= x + w; i++) {
      let inter = map(i, x, x + w, 0, 1);
      let c = lerpColor(c1, c2, inter);
      stroke(c);
      line(i, y, i, y + h);
    }
  }
}

// Adjust canvas size when the window is resized
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  
  // Recalculate font size and center offset
  fontSize = min(width, height) / 5;
  wordBounds = font.textBounds(word, 0, 0, fontSize);
  centerOffset = createVector(
    -wordBounds.x + (width / 2) - (wordBounds.w / 2),
    -wordBounds.y + (height / 2) - (wordBounds.h / 2)
  );
  
  // Update target points and reassign to snowflakes
  TARGET_POINTS.length = 0; // Clear existing points
  points = font.textToPoints(word, 0, 0, fontSize, {
    sampleFactor: 0.2, // Adjust for point density
    simplifyThreshold: 0
  });
  
  for (let pnt of points) {
    let shifted = createVector(pnt.x, pnt.y).add(centerOffset);
    TARGET_POINTS.push(shifted);
  }
  
  for (let i = 0; i < snowflakes.length; i++) {
    if (i < TARGET_POINTS.length) {
      snowflakes[i].target = TARGET_POINTS[i].copy();
    } else {
      // Extra snowflakes have random targets near the word
      snowflakes[i].target = createVector(random(width / 2 - wordBounds.w, width / 2 + wordBounds.w),
                                         random(height / 2 - wordBounds.h, height / 2 + wordBounds.h));
    }
  }
}
"
"2488927","Generative Circular City","mySketch","let citySketch = function(p) {
  // --- Global Variables ---
  let buildings = [];
  let baseRegionSize;
  const maxBuildings = 200; // Maximum number of buildings to maintain performance
  const clickThreshold = 50; // Distance threshold in world units for selecting a building

  // --- Setup Function ---
  p.setup = function() {
    p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
    p.noSmooth();
    p.strokeWeight(1);
    p.stroke(0);
    p.fill(200);

    // Define the base region where buildings can be placed
    baseRegionSize = p.min(p.width, p.height) * 0.8;

    // Initialize with a few buildings for initial interest
    for (let i = 0; i < 10; i++) {
      buildings.push(generateBuilding());
    }
  };

  // --- Draw Function ---
  p.draw = function() {
    p.background(220);
    p.orbitControl();

    // Set up an orthographic camera for a clean, architectural perspective
    p.ortho(-p.width / 2, p.width / 2, -p.height / 2, p.height / 2, 0, 5000);

    // Slightly tilt the scene for better visualization
    p.rotateX(p.PI / 3);
    p.rotateZ(p.frameCount * 0.001);

    // Draw a subtle ground plane as a reference
    p.push();
    p.stroke(0);
    p.noFill();
    p.translate(0, 0, -1);
    p.rectMode(p.CENTER);
    p.rect(0, 0, baseRegionSize, baseRegionSize);
    p.pop();

    // Render all buildings
    for (let b of buildings) {
      drawBuilding(b);
    }
  };

  // --- Mouse Pressed Function ---
  p.mousePressed = function() {
    // Map mouse position to world coordinates
    let worldPos = screenToWorld(p.mouseX, p.mouseY);
    let worldX = worldPos.x;
    let worldY = worldPos.y;

    let nearestIndex = -1;
    let nearestDist = Infinity;

    // Iterate through all buildings to find the nearest one to the mapped world position
    for (let i = 0; i < buildings.length; i++) {
      let b = buildings[i];
      let d = p.dist(worldX, worldY, b.x, b.y);
      if (d < nearestDist) {
        nearestDist = d;
        nearestIndex = i;
      }
    }

    // If the nearest building is within the threshold, reconstruct it
    if (nearestDist < clickThreshold && nearestIndex >= 0) {
      buildings[nearestIndex] = generateBuilding(buildings[nearestIndex].x, buildings[nearestIndex].y);
    } else {
      // Otherwise, add a new building if under the maximum limit
      if (buildings.length < maxBuildings) {
        buildings.push(generateBuilding());
      } else {
        // If maximum buildings reached, randomly reconstruct an existing one
        let idx = p.floor(p.random(buildings.length));
        buildings[idx] = generateBuilding(buildings[idx].x, buildings[idx].y);
      }
    }
  };

  // --- Helper Function: Convert Screen to World Coordinates ---
  function screenToWorld(mx, my) {
    // Calculate aspect ratio
    let aspect = p.width / p.height;

    // Orthographic projection parameters
    let left = -p.width / 2;
    let right = p.width / 2;
    let top = -p.height / 2;
    let bottom = p.height / 2;

    // Map mouseX and mouseY to world coordinates
    let worldX = p.map(mx, 0, p.width, left, right);
    let worldY = p.map(my, 0, p.height, top, bottom);

    // Adjust for the scene's rotation (rotateX and rotateZ)
    // Since the scene is rotated, we need to apply the inverse rotation to the world coordinates
    let rotZ = p.frameCount * 0.001;
    let rotX = p.PI / 3;

    // Create a vector for the mouse position in world space
    let v = p.createVector(worldX, worldY, 0);

    // Apply inverse rotations
    v.rotate(-rotZ);
    // For rotateX, we'll project the y and z
    let sinX = p.sin(rotX);
    let cosX = p.cos(rotX);
    let y = v.y * cosX - v.z * sinX;
    let z = v.y * sinX + v.z * cosX;
    v.y = y;
    v.z = z;

    return { x: v.x, y: v.y };
  }

  // --- Generate Building Function ---
  function generateBuilding(x = null, y = null) {
    if (x === null || y === null) {
      x = p.random(-baseRegionSize / 2, baseRegionSize / 2);
      y = p.random(-baseRegionSize / 2, baseRegionSize / 2);
    }

    // Create a random polygon footprint
    let sides = p.floor(p.random(12, 24));
    let radius = p.random(20, 80);
    let angleOffset = p.random(p.TWO_PI);

    let footprint = [];
    for (let i = 0; i < sides; i++) {
      let ang = angleOffset + p.TWO_PI * i / sides;
      let vx = x + p.cos(ang) * radius;
      let vy = y + p.sin(ang) * radius;
      footprint.push({ x: vx, y: vy });
    }

    let height = p.random(30, 200);

    return {
      x: x,
      y: y,
      footprint: footprint,
      height: height
    };
  }

  // --- Draw Building Function ---
  function drawBuilding(b) {
    p.push();
    // Position the building so that its base sits on the ground
    p.translate(0, 0, b.height / 2);

    // Draw the top face of the building
    p.beginShape();
    for (let pnt of b.footprint) {
      p.vertex(pnt.x, pnt.y, b.height / 2);
    }
    p.endShape(p.CLOSE);

    // Draw the bottom face of the building
    p.beginShape();
    for (let pnt of b.footprint) {
      p.vertex(pnt.x, pnt.y, -b.height / 2);
    }
    p.endShape(p.CLOSE);

    // Draw the side walls of the building
    for (let i = 0; i < b.footprint.length; i++) {
      let p1 = b.footprint[i];
      let p2 = b.footprint[(i + 1) % b.footprint.length];
      p.beginShape();
      p.vertex(p1.x, p1.y, -b.height / 2);
      p.vertex(p1.x, p1.y, b.height / 2);
      p.vertex(p2.x, p2.y, b.height / 2);
      p.vertex(p2.x, p2.y, -b.height / 2);
      p.endShape(p.CLOSE);
    }

    p.pop();
  }

  // --- Window Resized Function ---
  p.windowResized = function() {
    p.resizeCanvas(p.windowWidth, p.windowHeight);
    baseRegionSize = p.min(p.width, p.height) * 0.8;
  };
};

// Create a new p5 instance with the citySketch
new p5(citySketch);
"
"2485790","Pixel Panties","mySketch","let particles = [];
let blockSize;
let hoverRadius = 50;
let springStrength = 0.08;
let damping = 0.92;
let repelStrength = 1.2;
let particleSpacing = 3; // spacing between particles within each pixel block

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();
  initializeParticles();
}

function initializeParticles() {
  particles = []; // Reset particles array to handle window resizing

  // Define the shape as a 2D array
  let shape = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // Top waistband
    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], // Second row
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], // Third row
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], // Fourth row
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], // Fifth row
    [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], // Sixth row
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], // Seventh row
    [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], // Eighth row
  ];

  // Calculate blockSize based on both width and height
  let designWidth = 16; // Number of columns in the widest row
  let designHeight = shape.length; // Number of rows in the design

  // Calculate blockSize to fit within 80% of both width and height
  let maxBlockSizeWidth = (width * 0.8) / designWidth;
  let maxBlockSizeHeight = (height * 0.8) / designHeight;
  blockSize = min(maxBlockSizeWidth, maxBlockSizeHeight);

  // Center the shape on the screen
  let startY = (height - designHeight * blockSize) / 2;
  let centerX = width / 2;

  // Create particles based on the shape
  let currentY = startY;
  for (let row of shape) {
    let rowWidth = row.length * blockSize;
    let startX = centerX - rowWidth / 2;
    for (let col = 0; col < row.length; col++) {
      if (row[col] === 1) {
        // Create particles within this ""pixel block""
        let blockX = startX + col * blockSize;
        createParticlesInBlock(blockX, currentY);
      }
    }
    currentY += blockSize;
  }
}

function createParticlesInBlock(blockX, blockY) {
  // Fill a block with a grid of particles
  for (let px = blockX; px < blockX + blockSize; px += particleSpacing) {
    for (let py = blockY; py < blockY + blockSize; py += particleSpacing) {
      particles.push(new Particle(px, py));
    }
  }
}

function draw() {
  background(255);

  let mx = mouseX;
  let my = mouseY;
  if (touches.length > 0) {
    mx = touches[0].x;
    my = touches[0].y;
  }

  // Update and draw particles
  for (let p of particles) {
    p.applyForces(mx, my);
    p.update();
    p.show();
  }
}

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.ox = x; // original position
    this.oy = y;
    this.vx = 0;
    this.vy = 0;
    this.r = particleSpacing * 0.5; // radius of particle
  }

  applyForces(mx, my) {
    // Spring force to return to original position
    let dx = this.ox - this.x;
    let dy = this.oy - this.y;
    this.vx += dx * springStrength;
    this.vy += dy * springStrength;

    // Repel if near the mouse
    let distSq = (mx - this.x) ** 2 + (my - this.y) ** 2;
    if (distSq < hoverRadius ** 2) {
      let d = sqrt(distSq);
      let ux = (this.x - mx) / d;
      let uy = (this.y - my) / d;
      this.vx += ux * repelStrength;
      this.vy += uy * repelStrength;
    }

    // Damping to reduce velocity over time
    this.vx *= damping;
    this.vy *= damping;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
  }

  show() {
    fill(0);
    ellipse(this.x, this.y, this.r * 2);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  initializeParticles(); // Recalculate layout on resize
}
"
"2485762","Pomodoro-style focus timer","mySketch.js",""
"2485762","Pomodoro-style focus timer","style.css","html,
body {
	margin: 0;
	padding: 0;
}"
"2485762","Pomodoro-style focus timer","index.html","<!DOCTYPE html>
<html lang=""en"">
<head>
<meta charset=""UTF-8"" />
<meta name=""viewport"" content=""width=device-width, initial-scale=1.0""/>
<title>Productivity Station</title>
<style>
  body, html {
    margin: 0; padding: 0;
    font-family: 'Helvetica Neue', sans-serif;
    overflow: hidden;
    color: #ffffff;
  }

  #overlayUI {
    position: absolute;
    top: 0; left:0; right:0;
    padding: 20px;
    display: flex; 
    flex-wrap: wrap; 
    gap: 20px;
    pointer-events: none;
    box-sizing: border-box;
  }

  .panel {
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
    padding: 15px;
    pointer-events: auto;
    max-width: 300px;
  }

  #timerPanel {
    flex: 1 1 200px;
  }

  #quotePanel {
    flex: 1 1 200px;
  }

  #notesPanel {
    flex: 1 1 300px;
  }

  h2, h3 {
    margin: 0 0 10px 0; 
    padding:0;
  }

  #timerDisplay {
    font-size: 3em;
    margin: 10px 0;
    text-align: center;
  }

  .timer-controls button {
    background: #ffffff22; 
    border: none;
    padding: 5px 10px; 
    border-radius: 5px;
    color: #fff;
    cursor: pointer;
    margin: 5px;
    font-size: 1em;
  }

  #quoteText {
    font-size:1.1em;
    font-style:italic;
    margin-bottom:10px;
    text-align:center;
  }

  #noteArea {
    width: 100%;
    height: 150px;
    border-radius: 5px;
    border: none;
    padding: 10px;
    box-sizing: border-box;
  }

  #saveNotes {
    background: #ffffff22; 
    border: none; 
    padding: 5px 10px;
    border-radius: 5px;
    color: #fff; 
    cursor: pointer;
    margin-top: 10px;
    display: inline-block;
  }
</style>
</head>
<body>
<div id=""overlayUI"">
  <div id=""timerPanel"" class=""panel"">
    <h2>Focus Timer</h2>
    <div id=""timerDisplay"">25:00</div>
    <div class=""timer-controls"" style=""text-align:center;"">
      <button id=""startTimer"">Start</button>
      <button id=""pauseTimer"">Pause</button>
      <button id=""resetTimer"">Reset</button>
    </div>
  </div>

  <div id=""quotePanel"" class=""panel"">
    <h2>Daily Inspiration</h2>
    <div id=""quoteText"">Loading quote...</div>
  </div>

  <div id=""notesPanel"" class=""panel"">
    <h2>Daily Notes</h2>
    <textarea id=""noteArea"" placeholder=""Write your notes here...""></textarea>
    <button id=""saveNotes"">Save Notes</button>
  </div>
</div>

<script src=""https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js""></script>
<script>
/**
 * Productivity Station:
 *  - Pomodoro-style focus timer
 *  - Local random quotes
 *  - Local storage notes
 *  - Animated geometric background
 */

// -------------------------------------
// Global Variables
// -------------------------------------
let timerSeconds = 1500; // 25 min * 60 = 1500 seconds
let timerRunning = false;
let timerInterval;

// Sample quotes array (local, no external API)
const quotes = [
  ""Productivity is being able to do things that you were never able to do before."",
  ""Focus on being productive instead of busy."",
  ""Your mind is for having ideas, not holding them."",
  ""If you spend too much time thinking about a thing, you'll never get it done."",
  ""The way to get started is to quit talking and begin doing."",
  ""Well done is better than well said."",
  ""Action is the foundational key to all success."",
  ""Simplicity boils down to two steps: Identify the essential. Eliminate the rest.""
];

// Randomly select a quote once per day and store it
function getDailyQuote() {
  let storedDate = localStorage.getItem('quoteDate');
  let storedQuote = localStorage.getItem('dailyQuote');
  let today = new Date().toDateString();

  if (storedDate === today && storedQuote) {
    return storedQuote;
  } else {
    let q = random(quotes);
    localStorage.setItem('dailyQuote', q);
    localStorage.setItem('quoteDate', today);
    return q;
  }
}

// -------------------------------------
// Setup and p5 Draw
// -------------------------------------
function setup() {
  createCanvas(windowWidth, windowHeight);
  noFill();
  angleMode(DEGREES);

  // Set quote
  document.getElementById('quoteText').textContent = getDailyQuote();

  // Load notes
  let savedNotes = localStorage.getItem('dailyNotes');
  if (savedNotes) {
    document.getElementById('noteArea').value = savedNotes;
  }

  // Event listeners for timer buttons
  document.getElementById('startTimer').addEventListener('click', startTimer);
  document.getElementById('pauseTimer').addEventListener('click', pauseTimer);
  document.getElementById('resetTimer').addEventListener('click', resetTimer);

  // Save notes event
  document.getElementById('saveNotes').addEventListener('click', saveNotes);

  // Update timer display initially
  updateTimerDisplay();
}

function draw() {
  // Animated gradient background
  let c1 = color((frameCount * 0.1) % 360, 40, 70);
  let c2 = color(((frameCount * 0.1) + 120) % 360, 40, 40);
  setGradient(c1, c2);

  // Draw some geometric lines and arcs as background patterns
  stroke(255, 150);
  strokeWeight(1);
  let step = 50;
  for (let x = 0; x < width; x += step) {
    line(x + (frameCount % step), 0, x, height);
  }

  // Arcs at random positions
  noFill();
  strokeWeight(2);
  for (let i = 0; i < 5; i++) {
    let cx = (width / 2) + sin(frameCount + i * 40) * width/3;
    let cy = (height / 2) + cos(frameCount + i * 40) * height/3;
    stroke(255, 100);
    arc(cx, cy, 100, 100, frameCount + i * 20, frameCount + i*20 + 180);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

// -------------------------------------
// Utility Functions
// -------------------------------------
function setGradient(c1, c2) {
  colorMode(HSB);
  for (let y = 0; y < height; y++) {
    let inter = map(y, 0, height, 0, 1);
    let col = lerpColor(c1, c2, inter);
    stroke(col);
    line(0, y, width, y);
  }
  colorMode(RGB);
}

// Timer functions
function updateTimerDisplay() {
  let min = floor(timerSeconds / 60);
  let sec = timerSeconds % 60;
  document.getElementById('timerDisplay').textContent = nf(min,2) + "":"" + nf(sec,2);
}

function startTimer() {
  if (!timerRunning) {
    timerRunning = true;
    timerInterval = setInterval(() => {
      if (timerSeconds > 0) {
        timerSeconds--;
        updateTimerDisplay();
      } else {
        clearInterval(timerInterval);
        timerRunning = false;
        // Optional: notify user time is up
      }
    }, 1000);
  }
}

function pauseTimer() {
  if (timerRunning) {
    clearInterval(timerInterval);
    timerRunning = false;
  }
}

function resetTimer() {
  pauseTimer();
  timerSeconds = 1500; // reset to 25:00
  updateTimerDisplay();
}

// Save notes
function saveNotes() {
  let notes = document.getElementById('noteArea').value;
  localStorage.setItem('dailyNotes', notes);
}
</script>
</body>
</html>
"
"2485755","Your desktop","mySketch.js","function setup() {
	createCanvas(windowWidth, windowHeight);
	background(100);
}

function draw() {
	circle(mouseX, mouseY, 20);
}"
"2485755","Your desktop","style.css","html,
body {
	margin: 0;
	padding: 0;
}"
"2485755","Your desktop","index.html","<!DOCTYPE html>
<html lang=""en"">
<head>
<meta charset=""UTF-8"" />
<meta name=""viewport"" content=""width=device-width, initial-scale=1.0""/>
<title>Daily Dashboard</title>
<style>
  body, html {
    margin: 0; padding: 0;
    font-family: 'Helvetica Neue', sans-serif;
    overflow: hidden;
  }
  #overlayUI {
    position: absolute; 
    top: 0; left: 0; right: 0; 
    padding: 20px;
    color: #ffffff; 
    text-shadow: 0 0 5px rgba(0,0,0,0.5);
    display: flex; 
    flex-wrap: wrap; 
    justify-content: space-between; 
    align-items: flex-start;
    pointer-events: none;
  }
  
  .panel {
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    pointer-events: auto;
  }
  
  #timePanel {
    flex: 1 1 200px;
    max-width: 300px;
  }
  
  #weatherPanel {
    flex: 1 1 300px;
    max-width: 350px;
    margin-left: 20px;
  }
  
  #todosPanel {
    flex: 1 1 300px; 
    max-width: 300px;
    margin-left: 20px;
  }
  
  h1, h2, h3, h4 {
    margin: 0; padding: 0;
  }
  
  #timeText {
    font-size: 3em;
    margin-bottom: 10px;
  }
  
  #dateText {
    font-size: 1.2em;
  }

  #weatherInfo {
    margin-top: 10px;
    font-size: 1.1em;
  }
  
  #refreshWeather {
    background: #ffffff22; 
    border: none; 
    padding: 5px 10px; 
    border-radius: 5px; 
    color: #fff; 
    cursor: pointer; 
    margin-top: 10px;
  }
  
  #todoInput {
    width: 80%;
    padding: 5px;
    border-radius: 5px;
    border: none;
  }
  
  #addTodo {
    background: #ffffff22;
    border: none;
    padding: 5px 10px;
    border-radius: 5px;
    color: #fff; 
    cursor: pointer;
    margin-left: 5px;
  }
  
  #todoList {
    margin-top: 10px;
    list-style: none;
    padding-left: 0;
  }
  
  #todoList li {
    background: #00000033;
    margin-bottom: 5px;
    padding: 5px 10px;
    border-radius: 5px;
    display: flex; 
    justify-content: space-between;
    align-items: center;
  }
  
  .deleteTodo {
    background: none;
    border: none;
    color: #ffdddd;
    cursor: pointer;
    font-weight: bold;
    font-size: 1.1em;
  }
</style>
</head>
<body>
<div id=""overlayUI"">
  <div id=""timePanel"" class=""panel"">
    <div id=""timeText"">Loading...</div>
    <div id=""dateText""></div>
  </div>
  <div id=""weatherPanel"" class=""panel"">
    <h3>Weather</h3>
    <div>
      City: <input type=""text"" id=""cityInput"" value=""New York"" style=""padding:3px; border-radius:3px; border:none;""/>
      <button id=""refreshWeather"">Refresh</button>
    </div>
    <div id=""weatherInfo"">Loading weather...</div>
  </div>
  <div id=""todosPanel"" class=""panel"">
    <h3>To-Do List</h3>
    <div style=""margin-bottom:10px;"">
      <input type=""text"" id=""todoInput"" placeholder=""Add a task..."">
      <button id=""addTodo"">+</button>
    </div>
    <ul id=""todoList""></ul>
  </div>
</div>

<script src=""https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js""></script>
<script>
/** 
 * Daily Dashboard with Animated Background, Weather, Time, and To-Do
 * Replace 'YOUR_OPENWEATHERMAP_API_KEY' with a valid OpenWeatherMap API key.
 */

let particles = [];
let hueOffset = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();
  
  // Initialize particles
  for (let i = 0; i < 80; i++) {
    particles.push({
      x: random(width),
      y: random(height),
      vx: random(-0.5, 0.5),
      vy: random(-0.5, 0.5),
      size: random(2, 5)
    });
  }
  
  // Setup event listeners for weather and todo
  document.getElementById('refreshWeather').addEventListener('click', fetchWeather);
  document.getElementById('addTodo').addEventListener('click', addTodo);
  
  // Load stored todos
  loadTodos();
  
  // Initial fetch of weather and start clock
  fetchWeather();
  setInterval(updateTime, 1000);
  updateTime();
}

function draw() {
  // Animated gradient background
  let c1 = color((hueOffset + frameCount * 0.2) % 360, 70, 50);
  let c2 = color((hueOffset + frameCount * 0.2 + 60) % 360, 70, 30);
  setGradient(c1, c2);
  
  // Draw subtle particles
  fill(255, 255, 255, 150);
  for (let p of particles) {
    ellipse(p.x, p.y, p.size, p.size);
    p.x += p.vx;
    p.y += p.vy;
    if (p.x < 0) p.x = width;
    if (p.x > width) p.x = 0;
    if (p.y < 0) p.y = height;
    if (p.y > height) p.y = 0;
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

// Gradient function
function setGradient(c1, c2) {
  for (let y = 0; y < height; y++) {
    let inter = map(y, 0, height, 0, 1);
    let col = lerpColor(c1, c2, inter);
    stroke(col);
    line(0, y, width, y);
  }
}

// Update time UI
function updateTime() {
  let now = new Date();
  let hours = nf(now.getHours(),2);
  let mins = nf(now.getMinutes(),2);
  let secs = nf(now.getSeconds(),2);
  document.getElementById('timeText').textContent = `${hours}:${mins}:${secs}`;
  
  let dayNames = [""Sun"", ""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat""];
  let monthNames = [""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"", 
                    ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""];
  let day = dayNames[now.getDay()];
  let date = now.getDate();
  let month = monthNames[now.getMonth()];
  let year = now.getFullYear();
  
  document.getElementById('dateText').textContent = `${day}, ${month} ${date}, ${year}`;
}

// Fetch weather data
async function fetchWeather() {
  let city = document.getElementById('cityInput').value.trim();
  if (!city) city = ""New York"";
  
  const apiKey = ""YOUR_OPENWEATHERMAP_API_KEY"";
  const url = `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&units=metric&appid=${apiKey}`;
  
  document.getElementById('weatherInfo').textContent = ""Loading weather..."";
  
  try {
    let res = await fetch(url);
    if(!res.ok) throw new Error(""City not found"");
    let data = await res.json();
    
    let temp = data.main.temp.toFixed(1);
    let desc = data.weather[0].description;
    let icon = data.weather[0].icon;
    let iconUrl = `http://openweathermap.org/img/wn/${icon}@2x.png`;
    
    document.getElementById('weatherInfo').innerHTML = `
      <div style=""display:flex; align-items:center;"">
        <img src=""${iconUrl}"" style=""width:50px; height:50px; margin-right:10px;"">
        <div>
          <div style=""font-size:1.2em; font-weight:bold;"">${temp}°C</div>
          <div style=""text-transform:capitalize;"">${desc}</div>
        </div>
      </div>
    `;
  } catch (err) {
    document.getElementById('weatherInfo').textContent = ""Error loading weather. Check city or API key."";
  }
}

// To-Do list functionality
let todos = [];

function loadTodos() {
  let stored = localStorage.getItem('dailyDashboardTodos');
  if (stored) {
    todos = JSON.parse(stored);
  } else {
    todos = [];
  }
  renderTodos();
}

function saveTodos() {
  localStorage.setItem('dailyDashboardTodos', JSON.stringify(todos));
}

function renderTodos() {
  let list = document.getElementById('todoList');
  list.innerHTML = '';
  for (let i = 0; i < todos.length; i++) {
    let li = document.createElement('li');
    li.textContent = todos[i];
    let btn = document.createElement('button');
    btn.textContent = '×';
    btn.className = 'deleteTodo';
    btn.addEventListener('click', () => {
      todos.splice(i, 1);
      saveTodos();
      renderTodos();
    });
    li.appendChild(btn);
    list.appendChild(li);
  }
}

function addTodo() {
  let input = document.getElementById('todoInput');
  let val = input.value.trim();
  if (val.length > 0) {
    todos.push(val);
    input.value = '';
    saveTodos();
    renderTodos();
  }
}
</script>
</body>
</html>
"
"2484941","3D bezier curves","mySketch","
let particles;
let baseAngles, smoothAngles;
let rayDirFromMouse, normalOfPlane, originOfPlane, mousePos3D;
let intersectPoint, laTrans;
let dragging;
let pickedIndex, pCount;
let closestDist, psiVal;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  frameRate(60);
  noCursor();
  strokeCap(PROJECT);
  smooth();
  colorMode(HSB, 255);
  
  psiVal = (7.0/12.0)*PI;
  pCount = 7;
  
  intersectPoint = createVector();
  baseAngles = createVector(0, 0, 0);
  smoothAngles = createVector(0, 0, 0);
  dragging = false;
  
  laTrans = createVector(width/2.0, height*0.8, -1500);
  
  // Initialize particles (control points)
  particles = [
    new Particle(700, -500),
    new Particle(500, -600),
    new Particle(250, 300),
    new Particle(150, -350),
    new Particle(-200, -100),
    new Particle(-700, -400),
    new Particle(-550, -650)
  ];
}

function draw() {
  background((frameCount * 0.5) % 255, 200, 40);
  
  // Custom camera
  camera(width/2.0, height/2.8, (height/2.0) / tan(PI/6.0), 
         width/2.0, height/2.0, 0, 
         300, 1, 0);
         
  mousePos3D = createVector(mouseX, mouseY, 0);
  rayDirFromMouse = createVector(mouseX - width/2.0, mouseY - height/2.0, -height/(2.0*tan(PI/6.0)));

  // Compute normal of plane by applying the same transformation logic
  push();
  rotateZ(PI/2);
  normalOfPlane = localToGlobalNoTranslate(createVector(0,0,100));
  pop();

  // Lights
  lights();
  directionalLight(255, 255, 255, -0.2, -0.4, -1);
  spotLight(255, 100, 255, width/2.0, height, 800, -0.5, -0.5, -1, PI/3, 6000);

  // Compute origin of plane after transformations
  originOfPlane = localToGlobal(createVector(0,0,0));

  // Draw volumetric rotating bezier structures
  push();
  translate(laTrans.x, laTrans.y, laTrans.z);
  applyRotation();
  for (let i = 1; i < 100; i++) {
    push();
    rotateX(TWO_PI / 100 * i);
    drawBezierChains();
    pop();
  }
  pop();

  // Draw draggable particles
  for (let i = 0; i < pCount; i++) {
    particles[i].show();
  }

  // If dragging a particle, update its global position toward intersection
  if (mouseIsPressed && mouseButton === LEFT) {
    if (!dragging) {
      intersectPoint = rayPlaneIntersection(mousePos3D, rayDirFromMouse, originOfPlane, normalOfPlane);
      pickedIndex = pCount;
      closestDist = 999999;
      for (let i = 0; i < pCount; i++) {
        let d = p5.Vector.dist(intersectPoint, particles[i].globalPos);
        if (d < closestDist) {
          closestDist = d;
          pickedIndex = i;
        }
      }
      if (pickedIndex < pCount && closestDist < 80) {
        dragging = true;
      }
    }
    if (dragging) {
      intersectPoint = rayPlaneIntersection(mousePos3D, rayDirFromMouse, originOfPlane, normalOfPlane);
      particles[pickedIndex].globalPos = mixVectors(0.95, particles[pickedIndex].globalPos, 0.05, intersectPoint);
      particles[pickedIndex].updateLocal();
      particles[pickedIndex].show();
    }
  }
}

// Draw two connected bezier chains
function drawBezierChains() {
  noFill();
  let timeHue = (frameCount * 0.5) % 255;
  stroke((timeHue + 60) % 255, 150, 255);
  bezierChain(particles[0].localPos, particles[1].localPos, particles[2].localPos, particles[3].localPos);

  stroke((timeHue + 120) % 255, 180, 255);
  bezierChain(particles[3].localPos, particles[4].localPos, particles[5].localPos, particles[6].localPos);
}

function bezierChain(a, b, c, d) {
  bezier(a.x, a.y, a.z, b.x, b.y, b.z, c.x, c.y, c.z, d.x, d.y, d.z);
}

// On mouse drag, update rotation angles
function mouseDragged() {
  if (mouseButton === LEFT) {
    baseAngles.x += (mouseY - pmouseY)*0.007;
    baseAngles.y -= (mouseX - pmouseX)*0.007;
    smoothAngles = mixVectors(0.94, smoothAngles, 0.06, baseAngles);
    for (let i = 0; i < pCount; i++) {
      particles[i].updateGlobal();
    }
  }
}

function mouseReleased() {
  dragging = false;
}

// Applies the main rotation as defined in original code
function applyRotation() {
  rotateX(-smoothAngles.x + 0.2*PI);
  rotateY(-smoothAngles.y);
  rotateZ(smoothAngles.z + PI);
}

// The opposite rotation
function applyRotationInverse() {
  rotateZ(-smoothAngles.z - PI);
  rotateY(smoothAngles.y);
  rotateX(smoothAngles.x - 0.2*PI);
}

// Rename the vector blending function to avoid name conflicts with p5.js blend()
function mixVectors(a1, v1, a2, v2) {
  let x = v1.x * a1 + v2.x * a2;
  let y = v1.y * a1 + v2.y * a2;
  let z = v1.z * a1 + v2.z * a2;
  return createVector(x, y, z);
}

// Intersection of ray and plane
function rayPlaneIntersection(pd, ved, pp, ven) {
  let difpos = p5.Vector.sub(pd, pp);
  let lambda = (difpos.dot(ven)) / (ved.dot(ven));
  let vv = mixVectors(-1, difpos, lambda, ved);
  return p5.Vector.sub(originOfPlane, vv);
}

// Transform a local vector to global coords (including rotation and translation)
function localToGlobal(v) {
  let rotated = applyCustomRotation(v, -smoothAngles.x+0.2*PI, -smoothAngles.y, smoothAngles.z+PI);
  rotated.add(laTrans);
  return rotated;
}

// Transform a global vector to local coords (inverse rotation and translation)
function globalToLocal(v) {
  let translated = createVector(v.x - laTrans.x, v.y - laTrans.y, v.z - laTrans.z);
  translated = applyCustomRotation(translated, -(smoothAngles.x-0.2*PI), smoothAngles.y, -(smoothAngles.z+PI));
  return translated;
}

// Transform a local vector to global coords without translation
function localToGlobalNoTranslate(v) {
  let rotated = applyCustomRotation(v, -smoothAngles.x+0.2*PI, -smoothAngles.y, smoothAngles.z+PI);
  return rotated; 
}

// Apply custom rotations in order (X, Y, Z)
function applyCustomRotation(v, ax, ay, az) {
  // RotateX
  let cosa = cos(ax), sina = sin(ax);
  let vyx = v.y * cosa - v.z * sina;
  let vzx = v.y * sina + v.z * cosa;
  let vxx = v.x;
  let vyy = vyx;
  let vzz = vzx;

  // RotateY
  let cosb = cos(ay), sinb = sin(ay);
  let vzb = vzz * cosb - vxx * sinb;
  let vxb = vzz * sinb + vxx * cosb;
  vxx = vxb; vzz = vzb;

  // RotateZ
  let cosc = cos(az), sinc = sin(az);
  let vxc = vxx * cosc - vyy * sinc;
  let vyc = vxx * sinc + vyy * cosc;
  
  return createVector(vxc, vyc, vzz);
}

// Particle class represents control points
class Particle {
  constructor(x, y) {
    this.localPos = createVector(x, y, 0);
    this.updateGlobal();
  }
  
  updateGlobal() {
    this.globalPos = localToGlobal(this.localPos);
  }
  
  updateLocal() {
    this.localPos = globalToLocal(this.globalPos);
  }
  
  show() {
    push();
    translate(this.globalPos.x, this.globalPos.y, this.globalPos.z);
    applyRotation();
    fill((frameCount*2)%255, 255, 255);
    noStroke();
    sphere(25);
    pop();
  }
}
"
"2483348","Infinite Vectors","mySketch","class SegmentAgent {
  constructor(x, y, r, initialDir = null) {
    this.loc = createVector(x, y);
    this.radius = r;
    this.direction = initialDir ? initialDir : this.randomDirection();
  }

  randomDirection() {
    let v = createVector(globalBaseSpeed, 0);
    v.rotate(random(TWO_PI));
    return v;
  }

  step() {
    // Move forward and add slight directional jitter
    this.loc.add(this.direction);
    this.direction.rotate(random(angleJitter[0], angleJitter[1]));
  }

  boundaryCheck() {
    // Keep agent within a circular domain
    if (!this.isInsideDomain(centerX, centerY, domainRadius)) {
      // If outside, reset to a random spawn point
      let dir = p5.Vector.random2D().mult(domainRadius * spawnRange);
      let pos = createVector(centerX, centerY).add(dir);
      this.loc.set(pos.x, pos.y);
      this.direction = p5.Vector.random2D().mult(globalBaseSpeed);
    }
  }

  isInsideDomain(cx, cy, rad) {
    return dist(cx, cy, this.loc.x, this.loc.y) <= rad + this.radius;
  }

  overlapDist(other) {
    let d = this.loc.dist(other.loc);
    let sumR = this.radius + other.radius;
    return sumR - d;
  }

  interactWith(other) {
    let penetration = this.overlapDist(other);
    if (abs(penetration) < minRad * touchThreshold) {
      // Slight rotation if just touching
      this.direction.rotate(radians(0.1));
    } else if (penetration > 0) {
      // Repel if overlapping
      let repel = this.loc.copy().sub(other.loc).setMag(globalBaseSpeed);
      this.direction = repel;
    }
  }

  displaySelf() {
    push();
    stroke(agentLineColor);
    strokeWeight(agentLineWidth);
    let p = this.loc.copy();
    let q = p.copy().add(this.direction.copy().setMag(this.radius * 2));
    line(p.x, p.y, q.x, q.y);
    pop();
  }
}

// Global variables and configuration
let agentCount = 300;
let globalBaseSpeed = 0.5;
let touchThreshold = 0.1;
let connectThreshold = 3;
let spawnRange = 0.8;
let colorScalePow = 0.5;
let angleJitter = [0, 0.05];

let displayMode = ""network"";
let areaRatio = 20;

let centerX, centerY, domainRadius;
let agents = [];
let minRad, maxRad;

// Rendering parameters
let backgroundColor = 0;
let agentLineColor;
let agentLineWidth = 1;
let connectionLineColor;
let lastSurprise = 0; 
let surpriseInterval = 5000; // milliseconds
let hueShift = 0;
let frameStart;

function randomAgent() {
  let direction = p5.Vector.random2D().mult(globalBaseSpeed);
  let posOffset = direction.copy().setMag(random(domainRadius * spawnRange));
  let spawnPos = createVector(centerX, centerY).add(posOffset);
  let r = random(minRad, maxRad);
  return new SegmentAgent(spawnPos.x, spawnPos.y, r, direction);
}

function initializeCanvas() {
  createCanvas(windowWidth, windowHeight);
  frameStart = millis();
  resetScene();
}

function resetScene() {
  domainRadius = min(width, height) / 2;
  let domainArea = PI * domainRadius ** 2;

  agentCount = floor(random(100, 400));
  areaRatio = random(2, 30);
  let avgArea = domainArea / agentCount;
  let minCircleArea = (2 * avgArea) / (areaRatio + 1);
  minRad = sqrt(minCircleArea) / PI;
  maxRad = sqrt(minCircleArea * areaRatio) / PI;

  centerX = width / 2;
  centerY = height / 2;

  agents = [];
  for (let i = 0; i < agentCount; i++) {
    agents.push(randomAgent());
  }

  backgroundColor = 0;
  agentLineColor = color(255);
  connectionLineColor = color(255, 20);
  background(backgroundColor);
}

function keyPressed() {
  // Toggle mode
  displayMode = (displayMode === ""elements"") ? ""network"" : ""elements"";
  background(backgroundColor);
}

function mouseClicked() {
  resetScene();
}

function renderFrame() {
  if (millis() - lastSurprise > surpriseInterval) {
    applySurprise();
    lastSurprise = millis();
  }

  noStroke();
  fill(0, 20);
  rect(0, 0, width, height);

  updateSimulation();
  if (displayMode === ""elements"") {
    displayAllAgents();
  } else {
    displayNetwork();
  }
}

function updateSimulation() {
  for (let ag of agents) {
    ag.step();
    ag.boundaryCheck();
  }

  // Interactions
  let count = agents.length;
  for (let i = 0; i < count; i++) {
    for (let j = i + 1; j < count; j++) {
      agents[i].interactWith(agents[j]);
      agents[j].interactWith(agents[i]);
    }
  }
}

function displayAllAgents() {
  // Just draw each agent as lines
  for (let ag of agents) {
    ag.displaySelf();
  }
}

function displayNetwork() {
  push();
  strokeWeight(1);
  let cMin = (2 * minRad) ** colorScalePow;
  let cMax = (2 * maxRad) ** colorScalePow;

  for (let i = 0; i < agentCount; i++) {
    let a = agents[i];
    for (let j = i + 1; j < agentCount; j++) {
      let b = agents[j];
      if (abs(a.overlapDist(b)) < minRad * connectThreshold) {
        let val = ((a.radius + b.radius) ** colorScalePow);
        let colVal = map(val, cMin, cMax, 0, 255);
        stroke(colVal, colVal * 0.5 + 20);
        line(a.loc.x, a.loc.y, b.loc.x, b.loc.y);
      }
    }
  }
  pop();

  // Also display the agents on top
  displayAllAgents();
}

function applySurprise() {
  hueShift = random(360);
  
  let newHue = hueShift;
  agentLineColor = color(newHue, 100, 100);
  connectionLineColor = color(newHue, 50, 100, 50);

  agentLineWidth = random(0.5, 2);

  // Slightly nudge all agents in a random direction for a surprising swirl
  let swirlAngle = random(-PI/4, PI/4);
  for (let ag of agents) {
    ag.direction.rotate(swirlAngle * 0.1); // subtle change for smoothness
  }

  // Possibly adjust speed for a new dynamic
  globalBaseSpeed = random(0.3, 0.7);
}

// Setup and draw aliases
window.setup = initializeCanvas;
window.draw = renderFrame;
"
"2482086","Crystal Deflector","mySketch","let crystalPos;
let shieldAngle = 0;
let comets = [];
let gameOver = false;
let lastSpawnTime = 0;

let lives = 10;
let livesGiven = 0; // how many extra lives have been granted so far
let startTime;
let finalScore = 0;
let lastShieldHitTime = -1000; // Time when the arc last deflected a comet

function setup() {
  createCanvas(windowWidth, windowHeight);
  crystalPos = createVector(width/2, height/2);
  angleMode(RADIANS);
  noStroke();
  textFont('sans-serif');
  startTime = millis();
}

function draw() {
  if (!gameOver) {
    updateGame();
    renderGame();
  } else {
    renderGameOver();
  }
}

function updateGame() {
  let elapsed = (millis() - startTime) / 1000;

  let extraLives = floor(elapsed / 10);
  // If we've reached a new 10-second milestone (extraLives is greater than livesGiven),
  // then give one life now, and update livesGiven.
  if (extraLives > livesGiven) {
    lives++;
    livesGiven = extraLives;
  }
	
  // Increase difficulty over time
  let difficultyFactor = millis() * 0.0001;
  let spawnInterval = max(800 - difficultyFactor * 50, 100);

  if (millis() - lastSpawnTime > spawnInterval) {
    spawnComet(difficultyFactor);
    lastSpawnTime = millis();
  }

  // Update comets
  for (let c of comets) {
    if (!c.deflected && !c.hitCrystal) {
      // Homing only if not deflected or hit
      let desired = p5.Vector.sub(crystalPos, c.pos);
      desired.setMag(2 + difficultyFactor * 0.5);
      c.vel = p5.Vector.lerp(c.vel, desired, 0.05);
    }
    c.pos.add(c.vel);
  }

  // Check collisions with the shield boundary (white circle radius 50)
  // The arc is just a segment of this circle
  for (let c of comets) {
    let distToCrystal = p5.Vector.dist(c.pos, crystalPos);
    if (distToCrystal <= 50) {
      // At this boundary, check arc
      let angleToComet = atan2(c.pos.y - crystalPos.y, c.pos.x - crystalPos.x);
      let rawDiff = angleToComet - shieldAngle;
      let angleDiff = atan2(sin(rawDiff), cos(rawDiff));
      
      let shieldArc = 0.26; // about ±15 degrees
      if (abs(angleDiff) < shieldArc) {
        // Inside arc: deflect
        c.deflected = true;
        let outDir = p5.Vector.sub(c.pos, crystalPos).normalize().mult(c.vel.mag() * 1.5);
        c.vel = outDir;
        // Arc turns red for 1 second
        lastShieldHitTime = millis();
      } else {
        // Outside arc: lose a life
        lives--;
        c.destroy = true; // remove this comet
        if (lives <= 0) {
          gameOver = true;
          finalScore = floor((millis() - startTime)/1000);
        }
      }
    }
  }

  // Remove destroyed and out-of-bounds comets
  comets = comets.filter(c => {
    if (c.destroy) return false;
    if (c.pos.x < -200 || c.pos.x > width + 200 || c.pos.y < -200 || c.pos.y > height + 200) return false;
    return true;
  });

  // Check deflected comet vs comet collisions (optional feature)
  for (let i = 0; i < comets.length; i++) {
    for (let j = i+1; j < comets.length; j++) {
      let c1 = comets[i];
      let c2 = comets[j];
      let d = p5.Vector.dist(c1.pos, c2.pos);
      if (d < 10 && (c1.deflected || c2.deflected)) {
        c1.destroy = true;
        c2.destroy = true;
      }
    }
  }

  // Remove comets destroyed in collisions
  comets = comets.filter(c => !c.destroy);
}

function renderGame() {
  // Background gradient
  setGradientBackground(color(10,0,30), color(0,0,0));
  
  // Draw crystal (inner decoration)
  let pulse = 5*sin(millis()*0.002)+45;
  fill(180, 100, 255);
  ellipse(crystalPos.x, crystalPos.y, pulse, pulse);

  // Draw shield circle (white) and arc
  push();
  translate(crystalPos.x, crystalPos.y);
  rotate(shieldAngle);
  // White circle
  stroke(255);
  strokeWeight(4);
  noFill();
  ellipse(0,0,100,100); // radius 50

  // Arc color: red if recently hit, else yellow
  let shieldHitDuration = 1000; // ms
  let arcColor = (millis() - lastShieldHitTime < shieldHitDuration) ? color(255,0,0) : color(255,255,0);
  stroke(arcColor);
  strokeWeight(15);
  arc(0,0,100,100,-0.26,0.26); 
  pop();
  
  // Draw comets
  noStroke();
  for (let c of comets) {
    if (c.deflected) {
      fill(100, 255, 150); 
    } else {
      fill(255, 200, 100);
    }
    ellipse(c.pos.x, c.pos.y, 8,8);
  }

  // HUD
  fill(255);
  textSize(24);
  textAlign(LEFT,TOP);
  let elapsed = floor((millis()-startTime)/1000);
  text(""Lives: "" + lives, 10,10);
  text(""Time Survived: "" + elapsed + ""s"", 10,40);
}

function renderGameOver() {
  setGradientBackground(color(30,0,10), color(0,0,0));
  
  fill(255);
  textSize(32);
  textAlign(CENTER,CENTER);
  text(""Game Over\nTime Survived: "" + finalScore + ""s\nClick or Press any key to Restart"", width/2, height/2);
}

function spawnComet(difficultyFactor) {
  let angle = random(TWO_PI);
  let distFromCenter = max(width,height)*0.6;
  let startPos = p5.Vector.fromAngle(angle).mult(distFromCenter).add(crystalPos);

  let speed = 2 + difficultyFactor*0.5; 
  let vel = p5.Vector.sub(crystalPos, startPos).setMag(speed);
  
  let c = {
    pos: startPos,
    vel: vel,
    deflected: false,
    destroy: false
  };
  comets.push(c);
}

// Control shield with mouse movement
function mouseMoved() {
  let dx = mouseX - width/2;
  let dy = mouseY - height/2;
  shieldAngle = atan2(dy,dx);
}

// On touch devices
function touchMoved() {
  if (touches.length > 0) {
    let dx = touches[0].x - width/2;
    let dy = touches[0].y - height/2;
    shieldAngle = atan2(dy,dx);
  }
  return false;
}

function mousePressed() {
  if (gameOver) {
    restartGame();
  }
}

function keyPressed() {
  if (gameOver) {
    restartGame();
  }
}

function restartGame() {
  gameOver = false;
  comets = [];
  lives = 10;
  startTime = millis();
  lastSpawnTime = 0;
  finalScore = 0;
  lastShieldHitTime = -1000;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  crystalPos.set(width/2, height/2);
}

function setGradientBackground(c1, c2) {
  noFill();
  for (let y=0; y<height; y++) {
    let inter = y/(height-1);
    let c = lerpColor(c1,c2,inter);
    stroke(c);
    line(0,y,width,y);
  }
}
"
"2482080","Lemming Cloud","mySketch","// Infinite Pastel Bubbles
// A calming, pastel puzzle game where you guide falling bubbles into a basket by placing limited ""cloud platforms.""

// --- Matter.js Setup ---
let Engine = Matter.Engine,
    World = Matter.World,
    Bodies = Matter.Bodies,
    Events = Matter.Events;

let engine, world;

// Game Variables
let currentLevel = 1;
let gameLost = false;
let gameWon = false;
let score = 0;

let availableBubbles;  // Bubbles left to drop
let bubblesToSave;     // How many must be saved this level
let cloudsAvailable;   // How many cloud platforms can be placed

let bubbles = [];
let clouds = [];
let basketBody;
let startPoint;

let topWall, bottomWall, leftWall, rightWall;

function setup() {
  createCanvas(windowWidth, windowHeight);

  engine = Engine.create();
  world = engine.world;
  
  textFont('sans-serif');
  
  initializeLevel(currentLevel);
  createWalls();
  createBasket();
  
  // Collision events
  Events.on(engine, 'collisionStart', handleCollisions);
  
  noStroke();
}

function draw() {
  // Pastel gradient background: top (light pink) to bottom (light blue)
  setGradientBackground(color(255, 220, 240), color(200, 230, 255));

  Engine.update(engine);

  // Check conditions
  if (!gameWon && !gameLost) {
    if (availableBubbles === 0 && areBubblesStill() && score < bubblesToSave) {
      gameLost = true;
    }
    if (score >= bubblesToSave) {
      gameWon = true;
    }
  }

  if (gameWon) {
    displayMessage(`Level ${currentLevel} Complete!\nClick or press any key to continue`);
    return;
  }
  if (gameLost) {
    displayMessage(`Game Over at Level ${currentLevel}\nClick or press any key to restart`);
    return;
  }

  displayHUD();

  // Spawn bubbles gradually
  if (frameCount % 30 === 0 && availableBubbles > 0 && !gameWon && !gameLost) {
    spawnBubble();
  }

  renderBubbles();
  renderClouds();
  
  // Show start point as a subtle pastel marker (like a pastel circle)
  fill(255, 200, 210, 150);
  ellipse(startPoint.x, startPoint.y, 30, 30);

  renderBasket();
}

// --- Level Management ---
function initializeLevel(level) {
  // Each level: more bubbles required, fewer resources
  bubblesToSave = level;
  availableBubbles = max(200 - (level-1)*10, 50);
  cloudsAvailable = max(100 - (level-1)*5, 10);
  
  score = 0;
  bubbles = [];
  clouds = [];
  
  gameWon = false;
  gameLost = false;
}

function nextLevel() {
  currentLevel++;
  initializeLevel(currentLevel);
  World.clear(world, false);
  createWalls();
  createBasket();
  loop();
}

function restartGame() {
  currentLevel = 1;
  initializeLevel(currentLevel);
  World.clear(world, false);
  createWalls();
  createBasket();
  loop();
}

// --- Walls & Basket ---
function createWalls() {
  topWall = Bodies.rectangle(width/2, -10, width, 20, { isStatic: true });
  bottomWall = Bodies.rectangle(width/2, height+10, width, 20, { isStatic: true, label: 'bottom' });
  leftWall = Bodies.rectangle(-10, height/2, 20, height, { isStatic: true });
  rightWall = Bodies.rectangle(width+10, height/2, 20, height, { isStatic: true });
  World.add(world, [topWall, bottomWall, leftWall, rightWall]);
}

function createBasket() {
  let basketRadius = 50; 
  let basketPosX = random(60, width-60);
  
  // A soft funnel shape (basket)
  let funnelHeight = 100;
  let funnelVertices = [
    { x: -basketRadius, y: 0 },
    { x: -basketRadius/2, y: -funnelHeight },
    { x: basketRadius/2, y: -funnelHeight },
    { x: basketRadius, y: 0 }
  ];

  basketBody = Bodies.fromVertices(basketPosX, height-10, funnelVertices, {
    isStatic: true,
    label: 'basket'
  }, true);

  World.add(world, basketBody);

  startPoint = { x: generateNonAlignedX(basketPosX), y: 150 };
}

function generateNonAlignedX(basketX, minDistance = 100) {
  let newX;
  do {
    newX = random(60, width - 60);
  } while (abs(newX - basketX) < minDistance);
  return newX;
}

// --- Bubbles ---
function spawnBubble() {
  let bubble = Bodies.circle(startPoint.x, startPoint.y, 7.5, {
    friction: 0.001,
    restitution: 0.5,
    label: 'bubble'
  });
  World.add(world, bubble);
  bubbles.push(bubble);
  availableBubbles--;
}

function renderBubbles() {
  // Soft pastel bubbles (semi-transparent)
  for (let bubble of bubbles) {
    fill(255, 180, 200, 150);
    noStroke();
    let bubbleSize = isMobileDevice() ? width * 0.03 : 15;
    ellipse(bubble.position.x, bubble.position.y, bubbleSize, bubbleSize);
  }
}

function areBubblesStill() {
  for (let b of bubbles) {
    let v = b.velocity;
    if (abs(v.x)>0.5 || abs(v.y)>0.5) {
      return false;
    }
  }
  return true;
}

// --- Clouds (Platforms) ---
function placeCloud() {
  if (cloudsAvailable > 0 && !gameWon && !gameLost) {
    // Cloud platform: soft pastel bar
    let cloud = Bodies.rectangle(mouseX, mouseY, 60, 10, {
      isStatic: true,
      label: 'cloud'
    });
    World.add(world, cloud);
    clouds.push(cloud);
    cloudsAvailable--;
  }
}

function renderClouds() {
  // Soft pastel cloud platforms (light gray-white)
  fill(255,255,255,180);
  noStroke();
  for (let c of clouds) {
    push();
    translate(c.position.x, c.position.y);
    rotate(c.angle);
    rectMode(CENTER);
    rect(0,0,60,10);
    pop();
  }
}

// --- Basket ---
function renderBasket() {
  // A subtle woven basket color: a light brown/pastel tone
  fill(225,200,160);
  noStroke();
  beginShape();
  for (let v of basketBody.vertices) {
    vertex(v.x, v.y);
  }
  endShape(CLOSE);
}

// --- Collisions ---
function handleCollisions(event) {
  let pairs = event.pairs;
  for (let i=0; i<pairs.length; i++) {
    let bodyA = pairs[i].bodyA;
    let bodyB = pairs[i].bodyB;

    // If bubble hits bottom (missed basket)
    if ((bodyA === bottomWall && bodyB.label === 'bubble') ||
        (bodyB === bottomWall && bodyA.label === 'bubble')) {
      let bubbleBody = bodyA.label === 'bubble' ? bodyA : bodyB;
      removeBubble(bubbleBody);
    }

    // If bubble enters basket
    if ((bodyA.label === 'basket' && bodyB.label === 'bubble') ||
        (bodyB.label === 'basket' && bodyA.label === 'bubble')) {
      score++;
      let bubbleBody = bodyA.label === 'bubble' ? bodyA : bodyB;
      removeBubble(bubbleBody);
    }
  }
}

function removeBubble(bubbleBody) {
  World.remove(world, bubbleBody);
  for (let i=0; i<bubbles.length; i++) {
    if (bubbles[i] === bubbleBody) {
      bubbles.splice(i,1);
      break;
    }
  }
}

// --- UI and Messages ---
function displayHUD() {
  // Light semi-transparent overlay
  fill(255,255,255,150);
  rect(0,0,width,50);

  fill(50);
  textSize(isMobileDevice()?14:16);
  textAlign(LEFT, CENTER);
  let hudText = `Level: ${currentLevel}   Goal: ${bubblesToSave}   Saved: ${score}   Bubbles Left: ${max(0, availableBubbles)}   Clouds: ${cloudsAvailable}`;
  text(hudText, 10, 25);
}

function displayMessage(msg) {
  fill(50);
  textAlign(CENTER,CENTER);
  textSize(24);
  text(msg, width/2, height/2);
}

// --- Input Handling ---
function mousePressed() {
  if (gameWon) {
    nextLevel();
  } else if (gameLost) {
    restartGame();
  } else {
    placeCloud();
  }
}

function touchStarted() {
  if (gameWon) {
    nextLevel();
  } else if (gameLost) {
    restartGame();
  } else {
    placeCloud();
  }
  return false;
}

function keyPressed() {
  if (gameWon) {
    nextLevel();
  } else if (gameLost) {
    restartGame();
  }
}

// --- Utilities ---
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  // Rebuild walls
  World.remove(world, [topWall,bottomWall,leftWall,rightWall]);
  createWalls();
  
  // Constrain startPoint within screen
  startPoint.x = constrain(startPoint.x,60,width-60);
}

// Draw a vertical gradient
function setGradientBackground(c1, c2) {
  noFill();
  for (let y=0; y<height; y++) {
    let inter = y/(height-1);
    let c = lerpColor(c1,c2,inter);
    stroke(c);
    line(0,y,width,y);
  }
}
"
"2482072","Chaos Rider","mySketch","// Chaos Rider
// A fractal-inspired arcade collecting game using p5.js only.
// Inspired by the Clifford Attractor and a basic game scenario.
// Move your ship with arrow keys or WASD to collect orbs before they vanish.
// Enjoy the swirling fractal background and aim for a high score.

// ---------------------------------------
// GLOBALS
// ---------------------------------------
let shipX, shipY;
let shipSpeed = 30;
let score = 0;
let gameOver = false;
let timeLimit = 60; // seconds
let startTime;

let orbs = [];
let orbSpawnInterval = 2000; // ms
let lastOrbSpawn = 0;
let orbLifetime = 10000; // ms

let attractorPoints = [];
let attractorSamples = 50000;
let attractorScale = 200;
let attractorFade = 20;
let a = -1.4;
let b = 1.6;
let c = 1.0;
let d = 0.7;

// For subtle attractor-based forces on the player
let fieldStrength = 0.02;

// Player movement input
let moveUp = false;
let moveDown = false;
let moveLeft = false;
let moveRight = false;

// ---------------------------------------
// SETUP
// ---------------------------------------
function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);
  noStroke();
  
  // Initialize ship position in center
  shipX = width/2;
  shipY = height/2;
  
  // Generate attractor points once
  // We'll animate their colors over time instead of re-generating
  let x = random(-1,1);
  let y = random(-1,1);
  for (let i = 0; i < attractorSamples; i++) {
    let x1 = sin(a * y) + c * cos(a * x);
    let y1 = sin(b * x) + d * cos(b * y);
    x = x1;
    y = y1;
    attractorPoints.push({x: x, y: y});
  }

  startTime = millis();
}

// ---------------------------------------
// DRAW LOOP
// ---------------------------------------
function draw() {
  if (gameOver) {
    drawGameOver();
    return;
  }

  let elapsed = (millis() - startTime)/1000;
  if (elapsed >= timeLimit) {
    gameOver = true;
    return;
  }

  // Draw fractal background
  background(0,0,0,100);
  push();
  translate(width/2, height/2);
  scale(attractorScale);
  noStroke();
  let hueOffset = (frameCount * 0.1) % 360;
  for (let i = 0; i < attractorPoints.length; i++) {
    let p = attractorPoints[i];
    // Color shifts slowly over time
    let h = (hueOffset + i*0.001) % 360;
    fill(h, 60, 80, 5);
    rect(p.x, p.y, 0.002, 0.002);
  }
  pop();

  // Handle orbs
  spawnOrbs();
  updateOrbs();
  drawOrbs();

  // Update player
  updateShip();
  drawShip();

  // HUD
  drawHUD(elapsed);

  // Check collisions with orbs
  checkCollisions();
}

// ---------------------------------------
// SHIP FUNCTIONS
// ---------------------------------------
function updateShip() {
  // Attractor-based subtle influence on movement
  // Convert ship position to attractor coords
  let ax = (shipX - width/2)/attractorScale;
  let ay = (shipY - height/2)/attractorScale;

  // Compute ""force"" from attractor gradient (simple approximation)
  // We'll pick the closest attractor point and nudge the ship slightly.
  // This is just a simple trick, not a real gradient calc.
  let nearestDist = Infinity;
  let nearestP = null;
  for (let i = 0; i < 20; i++) {
    let idx = floor(random(attractorPoints.length));
    let p = attractorPoints[idx];
    let dx = p.x - ax;
    let dy = p.y - ay;
    let dd = dx*dx+dy*dy;
    if (dd < nearestDist) {
      nearestDist = dd;
      nearestP = p;
    }
  }
  // Apply a small force pulling the ship toward the nearest attractor point
  if (nearestP) {
    let dx = ((nearestP.x*attractorScale + width/2)-shipX)*fieldStrength;
    let dy = ((nearestP.y*attractorScale + height/2)-shipY)*fieldStrength;
    shipX += dx;
    shipY += dy;
  }

  // Player input movement
  let vx = 0;
  let vy = 0;
  if (moveUp) vy -= shipSpeed;
  if (moveDown) vy += shipSpeed;
  if (moveLeft) vx -= shipSpeed;
  if (moveRight) vx += shipSpeed;

  shipX += vx;
  shipY += vy;

  // Keep ship within screen bounds
  shipX = constrain(shipX, 0, width);
  shipY = constrain(shipY, 0, height);
}

function drawShip() {
  fill(120,100,100);
  noStroke();
  push();
  translate(shipX, shipY);
  ellipse(0,0,20,20);
  pop();
}

// ---------------------------------------
// ORBS FUNCTIONS
// ---------------------------------------
function spawnOrbs() {
  let now = millis();
  // Spawn orbs at intervals
  if (now - lastOrbSpawn > orbSpawnInterval) {
    lastOrbSpawn = now;
    let ox = random(40, width-40);
    let oy = random(100, height-100);
    orbs.push({x: ox, y: oy, born: now});
  }
}

function updateOrbs() {
  let now = millis();
  // Remove old orbs
  orbs = orbs.filter(o => now - o.born < orbLifetime);
}

function drawOrbs() {
  let now = millis();
  for (let o of orbs) {
    let age = now - o.born;
    let lifeRatio = 1 - age/orbLifetime;
    let orbSize = 20 * (0.5 + 0.5*lifeRatio);
    let orbHue = map(lifeRatio,0,1,0,120);
    fill(orbHue,100,100);
    noStroke();
    ellipse(o.x, o.y, orbSize, orbSize);
  }
}

function checkCollisions() {
  // Check if ship touches an orb
  for (let i = orbs.length-1; i >= 0; i--) {
    let o = orbs[i];
    let distSq = (o.x - shipX)*(o.x - shipX)+(o.y - shipY)*(o.y - shipY);
    if (distSq < 20*20) {
      // collected
      orbs.splice(i,1);
      score++;
    }
  }
}

// ---------------------------------------
// HUD, GAME OVER, ETC
// ---------------------------------------
function drawHUD(elapsed) {
  fill(0,0,100);
  textSize(20);
  textAlign(LEFT,TOP);
  text(""Score: ""+score, 10,10);
  let remaining = max(0,floor(timeLimit - elapsed));
  text(""Time: ""+remaining, 10, 40);
}

function drawGameOver() {
  background(0);
  fill(0,0,100);
  textAlign(CENTER,CENTER);
  textSize(32);
  text(""GAME OVER\nScore: ""+score+""\nPress any key to restart"", width/2, height/2);
}

// ---------------------------------------
// INPUT HANDLING
// ---------------------------------------
function keyPressed() {
  if (gameOver) {
    restartGame();
    return;
  }
  if (key === 'W' || keyCode === UP_ARROW) moveUp = true;
  if (key === 'S' || keyCode === DOWN_ARROW) moveDown = true;
  if (key === 'A' || keyCode === LEFT_ARROW) moveLeft = true;
  if (key === 'D' || keyCode === RIGHT_ARROW) moveRight = true;
}

function keyReleased() {
  if (key === 'W' || keyCode === UP_ARROW) moveUp = false;
  if (key === 'S' || keyCode === DOWN_ARROW) moveDown = false;
  if (key === 'A' || keyCode === LEFT_ARROW) moveLeft = false;
  if (key === 'D' || keyCode === RIGHT_ARROW) moveRight = false;
}

function restartGame() {
  score = 0;
  gameOver = false;
  startTime = millis();
  orbs = [];
  shipX = width/2;
  shipY = height/2;
}
  
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  // Keep ship on screen
  shipX = constrain(shipX,0,width);
  shipY = constrain(shipY,0,height);
}
"
"2482029","Lunatic Fractal Corridor","mySketch","// A Surreal Infinite Fractal Corridor in p5.js
// Raymarching a fractal structure with infinite repetition and dynamic coloring
// No user interaction, no external input.

let shaderProgram;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  noStroke();
  shaderProgram = createShader(vertShader, fragShader);
}

function draw() {
  background(0);
  shader(shaderProgram);

  shaderProgram.setUniform('u_time', millis()/1000.0);
  shaderProgram.setUniform('u_resolution', [width, height]);

  // Render a plane covering the entire viewport
  plane(width, height);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

// Vertex Shader
const vertShader = `
  precision mediump float;

  attribute vec3 aPosition;
  attribute vec2 aTexCoord;

  varying vec2 vTexCoord;

  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;

  void main() {
    vTexCoord = aTexCoord;
    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition,1.0);
  }
`;

// Fragment Shader
const fragShader = `
  precision highp float;

  varying vec2 vTexCoord;

  uniform float u_time;
  uniform vec2 u_resolution;

  // --- Utility Functions ---

  // Convert HSB to RGB
  vec3 hsb2rgb(vec3 c){
    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),
                             6.0)-3.0)-1.0,
                     0.0,
                     1.0);
    // softening
    rgb = rgb*rgb*(3.0-2.0*rgb);
    return c.z * mix(vec3(1.0), rgb, c.y);
  }

  // Background color function
  vec3 backgroundColor(vec3 rd) {
    float v = 0.5*(rd.y+1.0);
    return mix(vec3(0.02,0.01,0.05), vec3(0.15,0.1,0.2), v);
  }

  // Shading function
  vec3 shade(vec3 p, vec3 n, vec3 ro, vec3 rd) {
    float time = u_time;
    
    // Light direction
    vec3 lightDir = normalize(vec3(sin(time*0.5), 0.4, cos(time*0.5)));
    float diff = max(dot(n, lightDir),0.0);

    // Animate color over position and time
    float hue = fract(0.1*p.x + 0.1*p.z + time*0.05);
    float sat = 0.9;
    float val = diff*0.8 + 0.2;
    vec3 col = hsb2rgb(vec3(hue, sat, val));

    // Rim lighting for detail
    float rim = pow(1.0 - dot(n, -rd), 2.0);
    col += 0.2 * rim;

    return col;
  }

  // SDF for scene
  float sdBox(vec3 p, vec3 b) {
    vec3 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);
  }

  vec3 repeatXZ(vec3 p, float repeatScale) {
    p.x = mod(p.x, repeatScale)-0.5*repeatScale;
    p.z = mod(p.z, repeatScale)-0.5*repeatScale;
    return p;
  }

  float mapScene(vec3 p) {
    float dist = 1e9;
    float scale = 5.0;

    // fractal-like repetition
    for (int i=0; i<3; i++) {
      vec3 pr = repeatXZ(p, scale);
      float d1 = sdBox(pr, vec3(0.2,0.8,0.2));
      float d2 = sdBox(pr + vec3(1.0, 0.0, 0.0), vec3(0.1,0.5,0.1));
      float d3 = sdBox(pr + vec3(-1.0, 0.0, 0.0), vec3(0.1,0.5,0.1));
      float d4 = sdBox(pr + vec3(0.0, 0.0, 1.0), vec3(0.1,0.5,0.1));
      float d5 = sdBox(pr + vec3(0.0, 0.0, -1.0), vec3(0.1,0.5,0.1));
      float cellDist = min(d1, min(min(d2,d3),min(d4,d5)));
      dist = min(dist, cellDist);
      scale *= 0.5;
    }

    // floor and ceiling
    float floorDist = p.y + 0.7;
    float ceilingDist = -(p.y - 0.7);
    dist = min(dist, min(floorDist, ceilingDist));
    return dist;
  }

  vec3 getNormal(vec3 p) {
    float eps = 0.001;
    float d = mapScene(p);
    vec3 n = vec3(
      mapScene(vec3(p.x+eps,p.y,p.z))-d,
      mapScene(vec3(p.x,p.y+eps,p.z))-d,
      mapScene(vec3(p.x,p.y,p.z+eps))-d
    );
    return normalize(n);
  }

  vec3 raymarch(vec3 ro, vec3 rd) {
    float t = 0.0;
    for (int i=0; i<100; i++) {
      vec3 pos = ro + rd*t;
      float d = mapScene(pos);
      if (d < 0.001) {
        vec3 n = getNormal(pos);
        return shade(pos,n,ro,rd);
      }
      t += d;
      if (t>100.0) break;
    }
    return backgroundColor(rd);
  }

  void main(){
    vec2 uv = vTexCoord * 2.0 - 1.0;
    float aspect = u_resolution.x/u_resolution.y;
    uv.x *= aspect;

    float time = u_time;
    vec3 ro = vec3(0.0, 0.0, time*2.0);
    vec3 target = vec3(0.0,0.0, ro.z+1.0);
    vec3 ww = normalize(target - ro);
    vec3 uu = normalize(cross(vec3(0,1,0),ww));
    vec3 vv = cross(ww,uu);

    vec3 rd = normalize(uv.x*uu + uv.y*vv + ww);

    vec3 color = raymarch(ro, rd);

    gl_FragColor = vec4(color,1.0);
  }
`;
"
"2482025","Fractal Raymarching","mySketch","// Main p5.js sketch
let shaderProgram;
let cameraAngleX = 0;
let cameraAngleY = 0;
let zoom = 5.0;
let lastMouseX, lastMouseY;
let rotating = false;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  noStroke();

  // Define the shader
  shaderProgram = createShader(vertShader, fragShader);
}

function draw() {
  background(0);

  // Use the custom shader
  shader(shaderProgram);

  // Pass uniforms to the shader
  shaderProgram.setUniform('u_time', millis() / 1000.0);
  shaderProgram.setUniform('u_resolution', [width, height]);
  shaderProgram.setUniform('u_mouse', [mouseX, mouseY]);
  shaderProgram.setUniform('u_cameraAngleX', cameraAngleX);
  shaderProgram.setUniform('u_cameraAngleY', cameraAngleY);
  shaderProgram.setUniform('u_zoom', zoom);

  // Render a plane that covers the entire screen
  plane(width, height);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function mouseDragged() {
  if (mouseIsPressed) {
    let dx = mouseX - (lastMouseX || mouseX);
    let dy = mouseY - (lastMouseY || mouseY);
    cameraAngleX += dx * 0.01;
    cameraAngleY += dy * 0.01;
  }
  lastMouseX = mouseX;
  lastMouseY = mouseY;
}

function mouseWheel(event) {
  zoom += event.delta * 0.01;
  zoom = max(0.5, min(zoom, 20.0));
}

// Vertex Shader
const vertShader = `
  precision mediump float;

  // Vertex attributes
  attribute vec3 aPosition;
  attribute vec2 aTexCoord;

  // Varying to pass texture coordinates to the fragment shader
  varying vec2 vTexCoord;

  // Uniforms for transformation matrices
  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;

  void main() {
    // Pass the texture coordinates to the fragment shader
    vTexCoord = aTexCoord;

    // Apply the model-view and projection transformations
    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
  }
`;

// Fragment Shader
const fragShader = `
  precision highp float;

  // Uniforms
  uniform float u_time;
  uniform vec2 u_resolution;
  uniform vec2 u_mouse;
  uniform float u_cameraAngleX;
  uniform float u_cameraAngleY;
  uniform float u_zoom;

  // Varying from the vertex shader
  varying vec2 vTexCoord;

  // Functions to rotate a vector around axes
  mat3 rotateX(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat3(
      1.0, 0.0, 0.0,
      0.0, c, -s,
      0.0, s, c
    );
  }

  mat3 rotateY(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat3(
      c, 0.0, -s,
      0.0, 1.0, 0.0,
      s, 0.0, c
    );
  }

  // Distance Estimator (DE) for a Mandelbulb fractal
  float mandelbulb(vec3 p, float power) {
    vec3 z = p;
    float dr = 1.0;
    float r = 0.0;

    // Reduced iterations for performance
    for (int i = 0; i < 64; i++) {
      r = length(z);
      if (r > 2.0) break;

      // Convert to spherical coordinates
      float theta = acos(z.z / r);
      float phi = atan(z.y, z.x);

      // Scale and rotate the point
      dr =  pow(r, power - 1.0) * power * dr + 1.0;
      float zr = pow(r, power);
      theta = theta * power;
      phi = phi * power;

      // Convert back to cartesian coordinates
      z = zr * vec3(
        sin(theta) * cos(phi),
        sin(phi) * sin(theta),
        cos(theta)
      );
      z += p;
    }
    return 0.5 * log(r) * r / dr;
  }

  vec3 calcNormal(vec3 p, float power) {
    float eps = 0.0005;
    float d = mandelbulb(p, power);
    vec3 n = vec3(
      mandelbulb(vec3(p.x+eps, p.y, p.z), power) - d,
      mandelbulb(vec3(p.x, p.y+eps, p.z), power) - d,
      mandelbulb(vec3(p.x, p.y, p.z+eps), power) - d
    );
    return normalize(n);
  }

  void main() {
    vec2 uv = vTexCoord * 2.0 - 1.0;

    // Adjust for aspect ratio
    float aspect = u_resolution.x / u_resolution.y;
    uv.x *= aspect;

    // Mouse-driven fractal power (range around 8 but varies)
    float power = 8.0 + (u_mouse.y/u_resolution.y - 0.5)*4.0;

    // Camera setup
    vec3 ro = vec3(0.0, 0.0, -u_zoom);
    vec3 rd = normalize(vec3(uv, 1.5));

    // Time-based and mouse-based camera rotation
    mat3 rotY = rotateY(u_time * 0.1 + u_cameraAngleX);
    mat3 rotX = rotateX(u_cameraAngleY);
    mat3 rotation = rotX * rotY;

    ro = rotation * ro;
    rd = rotation * rd;

    // Ray marching
    float totalDistance = 0.0;
    bool hit = false;
    vec3 p;

    for (int i = 0; i < 100; i++) {
      p = ro + rd * totalDistance;
      float distance = mandelbulb(p, power);
      if (distance < 0.001) {
        hit = true;
        break;
      }
      totalDistance += distance;
      if (totalDistance > 100.0) break;
    }

    if (hit) {
      // Calculate normal for lighting
      vec3 n = calcNormal(p, power);

      // Light direction
      vec3 lightDir = normalize(vec3(0.5, 1.0, -0.5));

      // Lambertian shading
      float diff = max(dot(n, lightDir), 0.0);

      // Additional color variation over time and normal
      float hue = mod(u_time*0.1 + n.x + n.y + n.z, 1.0);
      float saturation = 0.7;
      float brightness = diff * 0.9 + 0.1;

      // Convert HSB to RGB
      vec3 k = vec3(1.0, 2.0/3.0, 1.0/3.0);
      vec3 p2 = abs(fract(vec3(hue, hue, hue) + k) * 6.0 - 3.0);
      vec3 baseColor = clamp(p2 - 1.0, 0.0, 1.0);
      vec3 color = baseColor * brightness * saturation;

      gl_FragColor = vec4(color, 1.0);
    } else {
      // Background gradient
      float t = uv.y * 0.5 + 0.5;
      vec3 bg = mix(vec3(0.0, 0.05, 0.15), vec3(0.0,0.0,0.0), t);
      gl_FragColor = vec4(bg, 1.0);
    }
  }
`;
"
"2477879","Algorithm G","index.html","<!DOCTYPE html>
<html lang=""en"">
<head>
<meta charset=""UTF-8"" />
<meta name=""viewport"" content=""width=device-width, initial-scale=1.0""/>
<title>Logotype Particle Animation</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #fff;
    height: 100%;
    width: 100%;
    font-family: sans-serif;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>

<canvas id=""myCanvas""></canvas>

<script>

// Global variables
let canvas, ctx;
let w, h;
let offscreenCanvas, offscreenCtx;
let particles = [];
let particleCount = 0;
let imgSize = 200;
let mousePos = {x: null, y: null};
let mouseRadius = 100; // radius of interaction
let isTouching = false;

window.addEventListener('load', init);
window.addEventListener('resize', resizeCanvas);
window.addEventListener('mousemove', (e) => {
  mousePos.x = e.clientX;
  mousePos.y = e.clientY;
  isTouching = true;
  clearTimeout(mouseTimeout);
  mouseTimeout = setTimeout(()=>{ isTouching=false; }, 200);
});

window.addEventListener('touchmove', (e) => {
  let touch = e.touches[0];
  mousePos.x = touch.clientX;
  mousePos.y = touch.clientY;
  isTouching = true;
  clearTimeout(mouseTimeout);
  mouseTimeout = setTimeout(()=>{ isTouching=false; }, 200);
});

window.addEventListener('touchstart', (e) => {
  let touch = e.touches[0];
  mousePos.x = touch.clientX;
  mousePos.y = touch.clientY;
  isTouching = true;
});
window.addEventListener('touchend', () => {
  isTouching = false;
});

let mouseTimeout = null;

function init() {
  canvas = document.getElementById('myCanvas');
  ctx = canvas.getContext('2d');
  resizeCanvas();
  createOffscreenImage();
  createParticles();
  animate();
}

function resizeCanvas() {
  w = window.innerWidth;
  h = window.innerHeight;
  canvas.width = w;
  canvas.height = h;
}

// Draw the ""G"" on an offscreen canvas to retrieve pixel data
function createOffscreenImage() {
  offscreenCanvas = document.createElement('canvas');
  offscreenCanvas.width = imgSize;
  offscreenCanvas.height = imgSize;
  offscreenCtx = offscreenCanvas.getContext('2d');

  offscreenCtx.fillStyle = ""#fff"";
  offscreenCtx.fillRect(0, 0, imgSize, imgSize);

  // Draw border
  offscreenCtx.lineWidth = 10;
  offscreenCtx.strokeStyle = ""#000"";
  offscreenCtx.strokeRect(5, 5, imgSize-10, imgSize-10);

  // Draw the letter G
  offscreenCtx.fillStyle = ""#000"";
  offscreenCtx.font = (imgSize * 0.6) + ""px sans-serif"";
  offscreenCtx.textAlign = ""center"";
  offscreenCtx.textBaseline = ""middle"";
  offscreenCtx.fillText(""G"", imgSize/2, imgSize/2 + imgSize*0.05);

  let imgData = offscreenCtx.getImageData(0,0,imgSize,imgSize);
  let data = imgData.data;

  // To store pixel coordinates of black pixels
  let points = [];
  for (let y = 0; y < imgSize; y++) {
    for (let x = 0; x < imgSize; x++) {
      let idx = (y * imgSize + x)*4;
      let r = data[idx];
      let g = data[idx+1];
      let b = data[idx+2];
      // if pixel is black
      if(r<50 && g<50 && b<50) {
        points.push({x:x, y:y});
      }
    }
  }

  // We'll store these points globally for particle creation
  pixelPoints = points;
}

let pixelPoints = [];

function createParticles() {
  // Scale the ""G"" image to fit nicely on screen
  // We'll keep it in a square that fits the smaller dimension of the screen
  let minDim = Math.min(w,h);
  let scale = minDim*0.5/imgSize; // the ""G"" will occupy half of the smaller dimension

  let centerX = w/2;
  let centerY = h/2;

  pixelPoints.forEach(p => {
    let px = centerX + (p.x - imgSize/2)*scale;
    let py = centerY + (p.y - imgSize/2)*scale;
    particles.push(new Particle(px, py));
  });

  particleCount = particles.length;
}

function animate() {
  requestAnimationFrame(animate);
  ctx.clearRect(0,0,w,h);

  // Update and draw all particles
  for (let p of particles) {
    p.behaviors();
    p.update();
    p.show(ctx);
  }
}

// Particle class
class Particle {
  constructor(x,y) {
    this.target = {x:x, y:y};
    this.pos = {x: Math.random()*w, y: Math.random()*h};
    let angle = Math.random()*Math.PI*2;
    let speed = Math.random()*3+2;
    this.vel = {x: Math.cos(angle)*speed, y: Math.sin(angle)*speed};
    this.acc = {x:0, y:0};
    this.maxspeed = 10;
    this.maxforce = 1;
  }

  behaviors() {
    let arriveForce = this.arrive(this.target);
    let wanderForce = this.wander();

    // If mouse or touch is around, apply a repel force
    let repelForce = {x:0, y:0};
    if (isTouching && mousePos.x !== null && mousePos.y !== null) {
      repelForce = this.repel(mousePos);
    }

    arriveForce.x *= 1;
    arriveForce.y *= 1;
    wanderForce.x *= 0.4;
    wanderForce.y *= 0.4;
    repelForce.x *= 2; // stronger force to push away from the pointer
    repelForce.y *= 2;

    this.applyForce(arriveForce);
    this.applyForce(wanderForce);
    this.applyForce(repelForce);
  }

  applyForce(f) {
    this.acc.x += f.x;
    this.acc.y += f.y;
  }

  update() {
    this.vel.x += this.acc.x;
    this.vel.y += this.acc.y;
    let magVel = Math.sqrt(this.vel.x*this.vel.x + this.vel.y*this.vel.y);
    if (magVel > this.maxspeed) {
      this.vel.x = (this.vel.x/magVel)*this.maxspeed;
      this.vel.y = (this.vel.y/magVel)*this.maxspeed;
    }
    this.pos.x += this.vel.x;
    this.pos.y += this.vel.y;
    this.acc.x = 0;
    this.acc.y = 0;
  }

  show(ctx) {
    ctx.fillStyle = ""#000"";
    ctx.beginPath();
    ctx.arc(this.pos.x, this.pos.y, 2, 0, Math.PI*2);
    ctx.fill();
  }

  arrive(target) {
    let desired = {x: target.x - this.pos.x, y: target.y - this.pos.y};
    let d = Math.sqrt(desired.x*desired.x + desired.y*desired.y);
    let speed = this.maxspeed;
    if (d<50) {
      speed = (d/50)*this.maxspeed;
    }
    let magDes = Math.sqrt(desired.x*desired.x + desired.y*desired.y);
    if (magDes > 0) {
      desired.x = (desired.x/magDes)*speed;
      desired.y = (desired.y/magDes)*speed;
    }
    let steer = {x: desired.x - this.vel.x, y: desired.y - this.vel.y};
    let magSteer = Math.sqrt(steer.x*steer.x + steer.y*steer.y);
    if (magSteer > this.maxforce) {
      steer.x = (steer.x/magSteer)*this.maxforce;
      steer.y = (steer.y/magSteer)*this.maxforce;
    }
    return steer;
  }

  wander() {
    // simple random jitter force
    let wanderTheta = Math.random()*Math.PI*2;
    let wanderRadius = 25;
    // Use velocity direction to define wander center
    let vmag = Math.sqrt(this.vel.x*this.vel.x + this.vel.y*this.vel.y);
    let wanderCenter = {x:0,y:0};
    if (vmag>0) {
      wanderCenter.x = (this.vel.x/vmag)*50;
      wanderCenter.y = (this.vel.y/vmag)*50;
    }
    let wx = wanderCenter.x + wanderRadius*Math.cos(wanderTheta);
    let wy = wanderCenter.y + wanderRadius*Math.sin(wanderTheta);
    let magW = Math.sqrt(wx*wx+wy*wy);
    if (magW>this.maxforce*0.5) {
      wx = (wx/magW)*this.maxforce*0.5;
      wy = (wy/magW)*this.maxforce*0.5;
    }
    return {x:wx, y:wy};
  }

  repel(mouse) {
    let desired = {x: this.pos.x - mouse.x, y: this.pos.y - mouse.y};
    let d = Math.sqrt(desired.x*desired.x + desired.y*desired.y);
    if (d < mouseRadius) {
      // repulsion force
      let strength = (mouseRadius - d)/mouseRadius;
      let magD = Math.sqrt(desired.x*desired.x + desired.y*desired.y);
      if (magD > 0) {
        desired.x = (desired.x/magD)*this.maxspeed*strength;
        desired.y = (desired.y/magD)*this.maxspeed*strength;
      }
      let steer = {x: desired.x - this.vel.x, y: desired.y - this.vel.y};
      let magSteer = Math.sqrt(steer.x*steer.x + steer.y*steer.y);
      if (magSteer > this.maxforce) {
        steer.x = (steer.x/magSteer)*this.maxforce;
        steer.y = (steer.y/magSteer)*this.maxforce;
      }
      return steer;
    }
    return {x:0,y:0};
  }
}

</script>

</body>
</html>
"
"2472587","Line Particle Loop","mySketch","let particles = [];
let explosion = false;
let timer = 0;
let assembleTime = 3000; // 3 seconds
let explosionTime = 5000; // 5 seconds
let lineSpeed = 10;
let colors;

function setup() {
  createCanvas(displayWidth, displayHeight); // Mobile screen size
  colors = [random(255), random(255), random(255)];
  for (let i = 0; i < 50; i++) {
    particles.push(new Particle(width / 2, height / 2));
  }
}

function draw() {
  background(0);
  timer += deltaTime;

  if (explosion) {
    for (let p of particles) {
      p.explode();
    }
    if (timer > assembleTime) {
      explosion = false;
      timer = 0;
      resetParticles();
      setRandomColors();
    }
  } else {
    if (timer > explosionTime) {
      explosion = true;
      timer = 0;
      for (let p of particles) {
        p.initiateExplosion();
      }
    } else {
      for (let i = 0; i < particles.length; i++) {
        let leader = i === 0 ? null : particles[i - 1];
        particles[i].moveAsQueue(leader);
      }
    }
  }

  for (let p of particles) {
    p.display();
  }
}

function resetParticles() {
  let startX = random(width * 0.1, width * 0.9);
  let startY = random(height * 0.1, height * 0.9);
  let gap = width / particles.length * 0.5;

  for (let i = 0; i < particles.length; i++) {
    particles[i].x = startX - i * gap;
    particles[i].y = startY;
    particles[i].tx = startX - i * gap;
    particles[i].ty = startY;
  }
}

function setRandomColors() {
  colors = [random(255), random(255), random(255)];
}

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.tx = x;
    this.ty = y;
    this.explosionVector = createVector(0, 0);
    this.speed = lineSpeed;
  }

  moveAsQueue(leader) {
    if (leader) {
      this.tx = leader.x;
      this.ty = leader.y;
    } else {
      this.tx += random(-this.speed, this.speed);
      this.ty += random(-this.speed, this.speed);
    }

    this.tx = constrain(this.tx, 0, width);
    this.ty = constrain(this.ty, 0, height);

    this.x = lerp(this.x, this.tx, 0.1);
    this.y = lerp(this.y, this.ty, 0.1);
  }

  initiateExplosion() {
    this.explosionVector = p5.Vector.random2D().mult(random(50, 150));
  }

  explode() {
    this.x += this.explosionVector.x * 0.1;
    this.y += this.explosionVector.y * 0.1;
  }

  display() {
    noStroke();
    fill(colors[0], colors[1], colors[2]);
    ellipse(this.x, this.y, 10);
  }
}

function windowResized() {
  resizeCanvas(displayWidth, displayHeight);
}"
"2471243","More Tiles and Balls","mySketch","// Include Matter.js library before this script
// In p5.js editor, add the Matter.js library as explained above

let Engine, World, Bodies, Body, Runner; // Declare variables for Matter.js modules
let engine;
let world;
let runner;

let tileSize = 100;
let gridCols, gridRows;
let tiles = [];
let walls = [];
let balls = [];
let palette = ['#FF5733', '#3498DB', '#2ECC71', '#F1C40F'];
let ballGenerationInterval;

// Preload function to initialize Matter.js modules
function preload() {
  Engine = Matter.Engine;
  World = Matter.World;
  Bodies = Matter.Bodies;
  Body = Matter.Body;
  Runner = Matter.Runner;
}

// Setup function
function setup() {
  createCanvas(windowWidth, windowHeight);

  // Initialize Matter.js engine and world
  engine = Engine.create();
  world = engine.world;
  engine.gravity.y = 1.2; // Slightly stronger gravity

  // Initialize Runner
  runner = Runner.create();
  Runner.run(runner, engine);

  // Calculate grid size
  gridCols = floor(width / tileSize);
  gridRows = floor(height / tileSize);

  // Create boundary walls
  let boundaryOptions = { isStatic: true, restitution: 0.6 };
  World.add(world, [
    Bodies.rectangle(width / 2, -25, width, 50, boundaryOptions), // Top
    Bodies.rectangle(width / 2, height + 25, width, 50, boundaryOptions), // Bottom
    Bodies.rectangle(-25, height / 2, 50, height, boundaryOptions), // Left
    Bodies.rectangle(width + 25, height / 2, 50, height, boundaryOptions) // Right
  ]);

  // Generate tiles and walls
  for (let i = 0; i < gridCols; i++) {
    tiles[i] = [];
    for (let j = 0; j < gridRows; j++) {
      let x = i * tileSize + tileSize / 2;
      let y = j * tileSize + tileSize / 2;
      let type = random(['A', 'B', 'C']);
      let rotation = floor(random(4)) * HALF_PI;
      tiles[i][j] = { type, rotation, x, y, walls: [] };
      createTileWalls(i, j);
    }
  }

  // Start ball generation at 5 per second
  ballGenerationInterval = setInterval(generateBall, 200); // 200ms interval
}

// Draw function
function draw() {
  background(230);

  // Draw tiles
  for (let i = 0; i < gridCols; i++) {
    for (let j = 0; j < gridRows; j++) {
      let tile = tiles[i][j];
      push();
      translate(tile.x, tile.y);
      rotate(tile.rotation);
      drawTile(tile.type, tileSize);
      pop();
    }
  }

  // Draw balls
  noStroke();
  for (let i = balls.length - 1; i >= 0; i--) {
    let ball = balls[i];
    fill(ball.color);
    ellipse(ball.body.position.x, ball.body.position.y, ball.radius * 2);

    // Remove balls that reach the bottom
    if (ball.body.position.y > height + 20) {
      World.remove(world, ball.body);
      balls.splice(i, 1);
    }
  }
}

// Function to draw a single tile
function drawTile(type, size) {
  stroke(100);
  strokeWeight(1.5);
  noFill();

  // Simplified and polished designs
  switch (type) {
    case 'A':
      line(-size / 2, -size / 2, size / 2, size / 2);
      line(-size / 2, size / 2, size / 2, -size / 2);
      break;
    case 'B':
      line(0, -size / 2, 0, size / 2);
      line(-size / 2, 0, size / 2, 0);
      break;
    case 'C':
      arc(0, 0, size, size, HALF_PI, PI);
      arc(0, 0, size, size, -PI, -HALF_PI);
      break;
  }
}

// Function to create walls for a specific tile
function createTileWalls(i, j) {
  let tile = tiles[i][j];
  let size = tileSize;
  let x = tile.x;
  let y = tile.y;
  let rotation = tile.rotation;
  let wallThickness = 8;

  // Define walls based on tile type
  let wallDefs = [];
  switch (tile.type) {
    case 'A':
      wallDefs.push({ x1: -size / 2, y1: -size / 2, x2: size / 2, y2: size / 2 });
      wallDefs.push({ x1: -size / 2, y1: size / 2, x2: size / 2, y2: -size / 2 });
      break;
    case 'B':
      wallDefs.push({ x1: -size / 2, y1: 0, x2: size / 2, y2: 0 });
      wallDefs.push({ x1: 0, y1: -size / 2, x2: 0, y2: size / 2 });
      break;
    case 'C':
      wallDefs.push({ x1: -size / 2, y1: 0, x2: 0, y2: size / 2 });
      wallDefs.push({ x1: 0, y1: -size / 2, x2: size / 2, y2: 0 });
      break;
  }

  for (let def of wallDefs) {
    let length = dist(def.x1, def.y1, def.x2, def.y2);
    let angle = atan2(def.y2 - def.y1, def.x2 - def.x1);
    let wallX = x + (def.x1 + def.x2) / 2 * cos(rotation) - (def.y1 + def.y2) / 2 * sin(rotation);
    let wallY = y + (def.x1 + def.x2) / 2 * sin(rotation) + (def.y1 + def.y2) / 2 * cos(rotation);
    let wall = Bodies.rectangle(wallX, wallY, length, wallThickness, {
      isStatic: true,
      angle: rotation + angle,
      restitution: 0.5,
      friction: 0.1
    });
    World.add(world, wall);
    tile.walls.push(wall);
    walls.push(wall);
  }
}

// Function to generate a new ball
function generateBall() {
  let x = random(tileSize / 2, width - tileSize / 2);
  let y = -20;
  let radius = 15; // Increased radius for bigger balls
  let ball = Bodies.circle(x, y, radius, {
    restitution: 0.4,
    friction: 0.02,
    frictionAir: 0.001
  });
  ball.color = random(palette);
  World.add(world, ball);
  balls.push({ body: ball, radius: radius, color: ball.color });
}

// Function to handle mouse clicks
function mousePressed() {
  let i = floor(mouseX / tileSize);
  let j = floor(mouseY / tileSize);

  if (i >= 0 && i < gridCols && j >= 0 && j < gridRows) {
    let tile = tiles[i][j];

    // Remove existing walls for this tile
    for (let wall of tile.walls) {
      World.remove(world, wall);
      let wallIndex = walls.indexOf(wall);
      if (wallIndex > -1) {
        walls.splice(wallIndex, 1);
      }
    }
    tile.walls = [];

    // Change tile type randomly
    tile.type = random(['A', 'B', 'C']);

    // Rotate tile
    tile.rotation = floor(random(4)) * HALF_PI;

    // Create new walls based on new type and rotation
    createTileWalls(i, j);
  }
}

// Function to handle window resize
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2471230","Layers of complexity","mySketch","let maze;
let particles = [];
let numParticles = 200;
let angleOffset = 0;
let buildingMaze = true;
let buildStep = 0;
let buildSpeed = 100; // Adjust to control maze building speed

function setup() {
  createCanvas(800, 800);
  angleMode(DEGREES);
  maze = new CircularMaze(10, 30); // Adjust rings and sectors for complexity
  maze.initMaze();
  initializeParticles();
}

function draw() {
  background(0);
  translate(width / 2, height / 2);
  rotate(angleOffset);
  angleOffset += 0.1; // Control rotation speed

  if (buildingMaze) {
    maze.buildMaze(buildStep);
    buildStep += buildSpeed;
    if (buildStep >= maze.totalCells) {
      buildingMaze = false;
      maze.prepareMaze();
    }
  } else {
    maze.display();
    updateParticles();
  }
}

function initializeParticles() {
  for (let i = 0; i < numParticles; i++) {
    let startCell = maze.cells[maze.rings - 1][floor(random(maze.sectors))];
    particles.push(new Particle(startCell));
  }
}

function updateParticles() {
  for (let particle of particles) {
    particle.update();
    particle.display();
  }
}

// Circular Maze Class
class CircularMaze {
  constructor(rings, sectors) {
    this.rings = rings;
    this.sectors = sectors;
    this.cells = [];
    this.stack = [];
    this.totalCells = rings * sectors;
    this.buildOrder = [];
    this.currentBuildIndex = 0;
  }

  initMaze() {
    // Initialize cells
    for (let r = 0; r < this.rings; r++) {
      this.cells[r] = [];
      for (let s = 0; s < this.sectors; s++) {
        this.cells[r][s] = new Cell(r, s, this.rings, this.sectors);
      }
    }

    // Randomize build order for maze generation
    let allCells = [];
    for (let r = 0; r < this.rings; r++) {
      for (let s = 0; s < this.sectors; s++) {
        allCells.push(this.cells[r][s]);
      }
    }
    this.buildOrder = shuffle(allCells);
  }

  buildMaze(steps) {
    for (let i = 0; i < steps && this.currentBuildIndex < this.buildOrder.length; i++) {
      let cell = this.buildOrder[this.currentBuildIndex];
      cell.visited = true;
      let neighbors = cell.getNeighbors(this.cells);

      if (neighbors.length > 0) {
        let neighbor = random(neighbors);
        cell.removeWalls(neighbor);
      }

      this.currentBuildIndex++;
    }

    // Display partially built maze
    for (let r = 0; r < this.rings; r++) {
      for (let s = 0; s < this.sectors; s++) {
        this.cells[r][s].displayPartial();
      }
    }
  }

  prepareMaze() {
    // After building, reset visited status
    for (let r = 0; r < this.rings; r++) {
      for (let s = 0; s < this.sectors; s++) {
        this.cells[r][s].visited = false;
      }
    }
  }

  display() {
    for (let r = 0; r < this.rings; r++) {
      for (let cell of this.cells[r]) {
        cell.display();
      }
    }
  }
}

// Cell Class
class Cell {
  constructor(r, s, rings, sectors) {
    this.r = r; // ring index
    this.s = s; // sector index
    this.rings = rings;
    this.sectors = sectors;
    this.visited = false;
    this.walls = [true, true, true, true]; // [inner, right, outer, left]
  }

  getNeighbors(cells) {
    let neighbors = [];

    // Inner neighbor
    if (this.r > 0) {
      let innerNeighbor = cells[this.r - 1][this.s];
      if (!innerNeighbor.visited) neighbors.push(innerNeighbor);
    }

    // Outer neighbor
    if (this.r < this.rings - 1) {
      let outerNeighbor = cells[this.r + 1][this.s];
      if (!outerNeighbor.visited) neighbors.push(outerNeighbor);
    }

    // Right neighbor
    let rightS = (this.s + 1) % this.sectors;
    let rightNeighbor = cells[this.r][rightS];
    if (!rightNeighbor.visited) neighbors.push(rightNeighbor);

    // Left neighbor
    let leftS = (this.s - 1 + this.sectors) % this.sectors;
    let leftNeighbor = cells[this.r][leftS];
    if (!leftNeighbor.visited) neighbors.push(leftNeighbor);

    return neighbors;
  }

  removeWalls(next) {
    let dr = next.r - this.r;
    let ds = next.s - this.s;

    if (dr === 1 || dr === -this.rings + 1) {
      // Next is outer neighbor
      this.walls[2] = false;
      next.walls[0] = false;
    } else if (dr === -1 || dr === this.rings - 1) {
      // Next is inner neighbor
      this.walls[0] = false;
      next.walls[2] = false;
    } else if (ds === 1 || ds === -this.sectors + 1) {
      // Next is right neighbor
      this.walls[1] = false;
      next.walls[3] = false;
    } else if (ds === -1 || ds === this.sectors - 1) {
      // Next is left neighbor
      this.walls[3] = false;
      next.walls[1] = false;
    }
  }

  display() {
    let angleStep = 360 / this.sectors;
    let innerRadius = (this.r * (width / 2) / this.rings);
    let outerRadius = ((this.r + 1) * (width / 2) / this.rings);
    let startAngle = this.s * angleStep;
    let endAngle = (this.s + 1) * angleStep;

    stroke(255);
    strokeWeight(2);

    // Draw walls
    if (this.walls[0]) {
      // Inner wall
      arc(0, 0, innerRadius * 2, innerRadius * 2, startAngle, endAngle);
    }
    if (this.walls[2]) {
      // Outer wall
      arc(0, 0, outerRadius * 2, outerRadius * 2, startAngle, endAngle);
    }
    if (this.walls[1]) {
      // Right wall
      line(
        innerRadius * cos(endAngle),
        innerRadius * sin(endAngle),
        outerRadius * cos(endAngle),
        outerRadius * sin(endAngle)
      );
    }
    if (this.walls[3]) {
      // Left wall
      line(
        innerRadius * cos(startAngle),
        innerRadius * sin(startAngle),
        outerRadius * cos(startAngle),
        outerRadius * sin(startAngle)
      );
    }
  }

  displayPartial() {
    // Display only the built parts of the maze during construction
    if (this.visited) {
      this.display();
    }
  }
}

// Particle Class
class Particle {
  constructor(cell) {
    this.currentCell = cell;
    this.path = [cell];
    this.step = 0;
    this.findPath();
  }

  findPath() {
    // Random walk to create a path within the maze
    let steps = 100;
    for (let i = 0; i < steps; i++) {
      let neighbors = this.getAvailableNeighbors(this.currentCell);
      if (neighbors.length > 0) {
        this.currentCell = random(neighbors);
        this.path.push(this.currentCell);
      } else {
        break;
      }
    }
  }

  getAvailableNeighbors(cell) {
    let neighbors = [];
    let cells = maze.cells;
    let r = cell.r;
    let s = cell.s;

    // Inner neighbor
    if (!cell.walls[0]) {
      neighbors.push(cells[r - 1][s]);
    }

    // Outer neighbor
    if (!cell.walls[2]) {
      neighbors.push(cells[r + 1][s]);
    }

    // Right neighbor
    let rightS = (s + 1) % maze.sectors;
    if (!cell.walls[1]) {
      neighbors.push(cells[r][rightS]);
    }

    // Left neighbor
    let leftS = (s - 1 + maze.sectors) % maze.sectors;
    if (!cell.walls[3]) {
      neighbors.push(cells[r][leftS]);
    }

    return neighbors;
  }

  update() {
    this.step += 0.5; // Control the speed
    if (this.step >= this.path.length) {
      this.step = 0;
    }
  }

  display() {
    let index = floor(this.step);
    let currentCell = this.path[index];

    let angleStep = 360 / maze.sectors;
    let innerRadius = (currentCell.r * (width / 2) / maze.rings);
    let outerRadius = ((currentCell.r + 1) * (width / 2) / maze.rings);
    let startAngle = currentCell.s * angleStep;
    let endAngle = (currentCell.s + 1) * angleStep;
    let angle = lerp(startAngle, endAngle, 0.5);
    let radius = lerp(innerRadius, outerRadius, 0.5);

    let x = radius * cos(angle);
    let y = radius * sin(angle);

    noStroke();
    fill(255, 0, 0); // Red color for visibility
    ellipse(x, y, 6);

    // Trail effect
    fill(255, 0, 0, 100);
    for (let i = 1; i < 5; i++) {
      let trailIndex = index - i;
      if (trailIndex >= 0) {
        let trailCell = this.path[trailIndex];
        let trailInnerRadius = (trailCell.r * (width / 2) / maze.rings);
        let trailOuterRadius = ((trailCell.r + 1) * (width / 2) / maze.rings);
        let trailStartAngle = trailCell.s * angleStep;
        let trailEndAngle = (trailCell.s + 1) * angleStep;
        let trailAngle = lerp(trailStartAngle, trailEndAngle, 0.5);
        let trailRadius = lerp(trailInnerRadius, trailOuterRadius, 0.5);

        let trailX = trailRadius * cos(trailAngle);
        let trailY = trailRadius * sin(trailAngle);
        ellipse(trailX, trailY, 6 - i);
      }
    }
  }
}
"
"2471212","Particles, Circles and Mazes Chaos","mySketch","let factor = 0;
let particles = [];
let numParticles = 500;
let maze;
let mazeCols, mazeRows;
let cellSize = 20;
let solving = false;
let mazeInitialized = false;

function setup() {
  createCanvas(1200, 800);
  angleMode(DEGREES);
  colorMode(HSB, 360, 100, 100, 100);
  noFill();

  // Initialize particles
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }

  // Initialize maze
  mazeCols = floor(width / cellSize);
  mazeRows = floor(height / cellSize);
  maze = new Maze(mazeCols, mazeRows, cellSize);
}

function draw() {
  background(0, 0, 0, 20);
  translate(width / 2, height / 2);

  // Dynamic particle formation
  updateParticles();

  // Draw the circular pattern with dynamic lines
  drawCircularPattern();

  // Maze generation and solving
  if (!mazeInitialized) {
    maze.generate();
  } else if (!solving) {
    maze.solve();
    solving = true;
  } else {
    maze.displaySolution();
  }

  factor += 0.005;
}

// Function to draw the circular pattern
function drawCircularPattern() {
  let totalPoints = 200;
  let maxRadius = min(width, height) / 2 - 50;

  for (let layer = 1; layer <= 3; layer++) {
    let radius = (maxRadius / 3) * layer;

    for (let i = 0; i < totalPoints; i++) {
      let startAngle = map(i, 0, totalPoints, 0, 360);
      let endAngle = map((i * factor) % totalPoints, 0, totalPoints, 0, 360);

      let startX = radius * cos(startAngle);
      let startY = radius * sin(startAngle);

      let endX = radius * cos(endAngle);
      let endY = radius * sin(endAngle);

      stroke(
        (startAngle + frameCount) % 360,
        80,
        100,
        50 + 50 * sin(frameCount / 10)
      );
      strokeWeight(1 + sin(frameCount / 20 + layer) * 2);
      line(startX, startY, endX, endY);
    }
  }
}

// Function to update and display particles
function updateParticles() {
  for (let p of particles) {
    p.update();
    p.display();
  }
}

// Particle class for dynamic particle formation
class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 5;
    this.maxForce = 0.1;
    this.size = random(2, 4);
    this.color = color(random(360), 80, 100, 80);
    this.target = createVector(random(width), random(height));
  }

  update() {
    // Move towards the target
    let desired = p5.Vector.sub(this.target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);

    this.acc.add(steer);
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Change target occasionally
    if (d < 5) {
      this.target = createVector(random(width), random(height));
    }
  }

  display() {
    push();
    stroke(this.color);
    strokeWeight(this.size);
    point(this.pos.x - width / 2, this.pos.y - height / 2);
    pop();
  }
}

// Maze classes and functions
class Maze {
  constructor(cols, rows, w) {
    this.cols = cols;
    this.rows = rows;
    this.w = w;
    this.grid = [];
    this.stack = [];
    this.current;
    this.completed = false;
    this.path = [];
    this.solving = false;
    this.solvingCompleted = false;
    this.dfsStack = [];

    // Initialize grid cells
    for (let j = 0; j < this.rows; j++) {
      for (let i = 0; i < this.cols; i++) {
        let cell = new Cell(i, j, this.w);
        this.grid.push(cell);
      }
    }

    // Start with a random cell
    this.current = this.grid[0];
    this.current.visited = true;
  }

  generate() {
    // Maze generation using recursive backtracking
    let next = this.current.checkNeighbors(this.grid, this.cols, this.rows);
    if (next) {
      next.visited = true;

      this.stack.push(this.current);

      removeWalls(this.current, next);

      this.current = next;
    } else if (this.stack.length > 0) {
      this.current = this.stack.pop();
    } else {
      // Maze generation completed
      mazeInitialized = true;
    }

    // Display maze
    for (let cell of this.grid) {
      cell.show();
    }
  }

  solve() {
    // Initialize DFS solving
    let startCell = this.grid[0];
    let endCell = this.grid[this.grid.length - 1];
    this.dfsStack.push(startCell);
    startCell.visited = true;
    this.solving = true;

    // Reset visited status
    for (let cell of this.grid) {
      cell.visited = false;
    }
  }

  displaySolution() {
    // Maze solving using iterative DFS
    if (this.solving && this.dfsStack.length > 0) {
      let currentCell = this.dfsStack.pop();

      if (currentCell === this.grid[this.grid.length - 1]) {
        // Path found
        this.solvingCompleted = true;
        this.solving = false;
        this.constructPath(currentCell);
      }

      let neighbors = currentCell.getUnblockedNeighbors(this.grid, this.cols, this.rows);

      for (let neighbor of neighbors) {
        if (!neighbor.visited) {
          neighbor.visited = true;
          neighbor.previous = currentCell;
          this.dfsStack.push(neighbor);
        }
      }
    }

    // Animate traversal
    if (this.solvingCompleted && this.path.length > 0) {
      this.animateTraversal();
    }

    // Display maze
    for (let cell of this.grid) {
      cell.show();
    }
  }

  constructPath(endCell) {
    this.path = [];
    let temp = endCell;
    this.path.push(temp);
    while (temp.previous) {
      this.path.push(temp.previous);
      temp = temp.previous;
    }
    this.path.reverse();
    this.orbPosition = 0;
    this.solvingCompleted = true;
  }

  animateTraversal() {
    if (this.orbPosition < this.path.length - 1) {
      this.orbPosition += 0.5;
      let indexPos = floor(this.orbPosition);
      let t = this.orbPosition - indexPos;

      if (indexPos >= this.path.length - 1) {
        this.orbPosition = this.path.length - 1;
        return;
      }

      let currentCell = this.path[indexPos];
      let nextCell = this.path[indexPos + 1];

      if (!nextCell) return;

      let x = lerp(
        currentCell.i * this.w + this.w / 2,
        nextCell.i * this.w + this.w / 2,
        t
      );
      let y = lerp(
        currentCell.j * this.w + this.w / 2,
        nextCell.j * this.w + this.w / 2,
        t
      );

      // Draw the orb with a glowing effect
      push();
      translate(-width / 2, -height / 2);
      noStroke();
      let glowColor = color((frameCount * 2) % 360, 80, 100, 80);
      fill(glowColor);
      ellipse(x, y, this.w * 0.6, this.w * 0.6);
      pop();

      // Add particles at the orb position
      particles.push(new Particle(x + width / 2, y + height / 2));
    } else if (this.solvingCompleted) {
      // Reset the maze after traversal completes
      setup();
    }
  }
}

class Cell {
  constructor(i, j, w) {
    this.i = i;
    this.j = j;
    this.w = w;
    this.walls = [true, true, true, true]; // Top, Right, Bottom, Left
    this.visited = false;
    this.previous = undefined;
  }

  checkNeighbors(grid, cols, rows) {
    let neighbors = [];

    let top = grid[index(this.i, this.j - 1, cols, rows)];
    let right = grid[index(this.i + 1, this.j, cols, rows)];
    let bottom = grid[index(this.i, this.j + 1, cols, rows)];
    let left = grid[index(this.i - 1, this.j, cols, rows)];

    if (top && !top.visited) {
      neighbors.push(top);
    }
    if (right && !right.visited) {
      neighbors.push(right);
    }
    if (bottom && !bottom.visited) {
      neighbors.push(bottom);
    }
    if (left && !left.visited) {
      neighbors.push(left);
    }

    if (neighbors.length > 0) {
      let r = floor(random(0, neighbors.length));
      return neighbors[r];
    } else {
      return undefined;
    }
  }

  getUnblockedNeighbors(grid, cols, rows) {
    let neighbors = [];
    let i = this.i;
    let j = this.j;

    if (!this.walls[0]) {
      let top = grid[index(i, j - 1, cols, rows)];
      if (top) neighbors.push(top);
    }
    if (!this.walls[1]) {
      let right = grid[index(i + 1, j, cols, rows)];
      if (right) neighbors.push(right);
    }
    if (!this.walls[2]) {
      let bottom = grid[index(i, j + 1, cols, rows)];
      if (bottom) neighbors.push(bottom);
    }
    if (!this.walls[3]) {
      let left = grid[index(i - 1, j, cols, rows)];
      if (left) neighbors.push(left);
    }

    return neighbors;
  }

  show() {
    let x = this.i * this.w - width / 2;
    let y = this.j * this.w - height / 2;

    push();
    stroke(255);
    strokeWeight(2);

    // Draw walls
    if (this.walls[0]) line(x, y, x + this.w, y); // Top
    if (this.walls[1]) line(x + this.w, y, x + this.w, y + this.w); // Right
    if (this.walls[2]) line(x + this.w, y + this.w, x, y + this.w); // Bottom
    if (this.walls[3]) line(x, y + this.w, x, y); // Left
    pop();
  }
}

// Remove walls between two cells
function removeWalls(a, b) {
  let x = a.i - b.i;
  if (x === 1) {
    a.walls[3] = false;
    b.walls[1] = false;
  } else if (x === -1) {
    a.walls[1] = false;
    b.walls[3] = false;
  }
  let y = a.j - b.j;
  if (y === 1) {
    a.walls[0] = false;
    b.walls[2] = false;
  } else if (y === -1) {
    a.walls[2] = false;
    b.walls[0] = false;
  }
}

// Convert 2D grid coordinates to 1D index
function index(i, j, cols, rows) {
  if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) {
    return -1;
  }
  return i + j * cols;
}
"
"2471206","Aurora Nexus","mySketch","let factor = 0;

function setup() {
  createCanvas(800, 800);
  angleMode(DEGREES); // Use degrees for angles
  colorMode(HSB, 360, 100, 100, 100); // Set HSB color mode with alpha
  noFill();
}

function draw() {
  background(0, 0, 0, 10); // Slightly transparent background for a trailing effect
  translate(width / 2, height / 2);

  let totalPoints = 300;
  let maxRadius = width / 2 - 50;

  // Create multiple layers with varying radii
  for (let layer = 1; layer <= 5; layer++) {
    let radius = (maxRadius / 5) * layer;

    // Draw the lines between the points for each layer
    for (let i = 0; i < totalPoints; i++) {
      let startAngle = map(i, 0, totalPoints, 0, 360);
      let endAngle = map((i * factor) % totalPoints, 0, totalPoints, 0, 360);

      let startX = radius * cos(startAngle);
      let startY = radius * sin(startAngle);

      let endX = radius * cos(endAngle);
      let endY = radius * sin(endAngle);

      stroke(
        (startAngle + frameCount) % 360, // Dynamic hue
        80,
        100,
        50 + 50 * sin(frameCount / 10) // Varying alpha for glow effect
      );
      strokeWeight(1 + sin(frameCount / 20 + layer) * 2); // Varying line thickness
      line(startX, startY, endX, endY);
    }
  }

  factor += 0.005;
}
"
"2463838","3D particle vortex","mySketch","// Particle Vortex Simulation in 3D

let particles = [];
let numParticles = 3000;
let angle = 0;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  colorMode(HSB, 360, 100, 100, 100);
  noStroke();

  // Initialize particles
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  background(0, 0, 0, 20); // Slightly transparent background for motion trails
  rotateY(angle);
  angle += 0.002;

  for (let p of particles) {
    p.update();
    p.show();
  }
}

// Particle class
class Particle {
  constructor() {
    this.theta = random(TWO_PI);
    this.phi = random(PI);
    this.radius = random(100, 500);
    this.speed = random(0.0005, 0.002);
    this.hue = random(360);
    this.size = random(1, 3);
  }

  update() {
    this.theta += this.speed;
    this.phi += this.speed / 2;

    // Convert spherical coordinates to Cartesian coordinates
    this.x = this.radius * sin(this.phi) * cos(this.theta);
    this.y = this.radius * sin(this.phi) * sin(this.theta);
    this.z = this.radius * cos(this.phi);

    // Update hue for color variation
    this.hue = (this.hue + 0.1) % 360;
  }

  show() {
    push();
    translate(this.x, this.y, this.z);
    ambientMaterial(this.hue, 80, 100);
    sphere(this.size);
    pop();
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2463832","Epic Perlin","mySketch","let particles = [];
let flowField;
let cols, rows;
let inc = 0.1;
let zoff = 0;
let scl = 10;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);
  background(0);
  cols = floor(width / scl);
  rows = floor(height / scl);
  flowField = new Array(cols * rows);

  // Create particles
  for (let i = 0; i < 10000; i++) {
    particles[i] = new Particle();
  }
}

function draw() {
  let yoff = 0;
  for (let y = 0; y < rows; y++) {
    let xoff = 0;
    for (let x = 0; x < cols; x++) {
      let index = x + y * cols;
      let angle = noise(xoff, yoff, zoff) * TWO_PI * 4;
      let v = p5.Vector.fromAngle(angle);
      v.setMag(1);
      flowField[index] = v;
      xoff += inc;
    }
    yoff += inc;
  }
  zoff += 0.0003;

  // Draw particles
  for (let i = 0; i < particles.length; i++) {
    particles[i].follow(flowField);
    particles[i].update();
    particles[i].edges();
    particles[i].show();
  }
}

// Particle class
class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.maxSpeed = 4;
    this.hue = random(360);
    this.prevPos = this.pos.copy();
  }

  follow(vectors) {
    let x = floor(this.pos.x / scl);
    let y = floor(this.pos.y / scl);
    let index = x + y * cols;
    let force = vectors[index];
    this.applyForce(force);
  }

  applyForce(force) {
    this.acc.add(force);
  }

  update() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  show() {
    stroke(this.hue, 80, 100, 5);
    this.hue = (this.hue + 1) % 360;
    strokeWeight(1);
    line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
    this.updatePrev();
  }

  updatePrev() {
    this.prevPos.x = this.pos.x;
    this.prevPos.y = this.pos.y;
  }

  edges() {
    if (this.pos.x > width) {
      this.pos.x = 0;
      this.updatePrev();
    }
    if (this.pos.x < 0) {
      this.pos.x = width;
      this.updatePrev();
    }
    if (this.pos.y > height) {
      this.pos.y = 0;
      this.updatePrev();
    }
    if (this.pos.y < 0) {
      this.pos.y = height;
      this.updatePrev();
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  background(0);
}
"
"2462122","Earth","mySketch","let globeTexture;

function preload() {
  // Load the Earth texture image
  globeTexture = loadImage('earth_texture.jpg'); 
}

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  noStroke();
}

function drawStars(numStars) {
  push();
  noStroke();
  fill(255);
  for (let i = 0; i < numStars; i++) {
    let x = random(-width, width);
    let y = random(-height, height);
    let z = random(-width, width);
    push();
    translate(x, y, z);
    sphere(1);
    pop();
  }
  pop();
}

function draw() {
  background(0);

  // Draw stars
  push();
  translate(0, 0, 0);
  drawStars(0);
  pop();

  // Set up lighting
ambientLight(30);
pointLight(255, 255, 255, 0, -height / 2, 200);

  // Rotate the globe over time
  rotateY(millis() / 4000);

  // Apply the texture and draw the sphere
  texture(globeTexture);
  sphere(min(width, height) / 3);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}


"
"2460958","Dynamic world of physics","sketch.js","// Module aliases
let Engine = Matter.Engine,
    World = Matter.World,
    Bodies = Matter.Bodies;

let engine;
let world;
let particles = [];
let boundaries = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);

  engine = Engine.create();
  world = engine.world;

  // Create ground boundary
  boundaries.push(new Boundary(width / 2, height + 50, width * 2, 100, 0));

  // Create moving obstacles
  for (let i = 0; i < 8; i++) {
    let w = random(150, 300);
    let h = 20;
    let x = random(width * 0.1, width * 0.9);
    let y = random(height * 0.2, height * 0.8);
    let angle = random(-PI / 6, PI / 6);
    boundaries.push(new MovingBoundary(x, y, w, h, angle));
  }

  Engine.run(engine);
}

function mouseDragged() {
  particles.push(new Particle(mouseX, mouseY, random(5, 15)));
}

function draw() {
  drawGradient();

  // Update and display particles
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].show();
    if (particles[i].isOffScreen()) {
      particles[i].removeFromWorld();
      particles.splice(i, 1);
    }
  }

  // Update and display boundaries
  for (let boundary of boundaries) {
    boundary.update();
    boundary.show();
  }
}

function drawGradient() {
  for (let y = 0; y < height; y++) {
    let inter = map(y, 0, height, 0, 1);
    let c = lerpColor(color(230, 80, 20), color(260, 50, 50), inter);
    stroke(c);
    line(0, y, width, y);
  }
}

// Particle class
class Particle {
  constructor(x, y, r) {
    let options = {
      friction: 0.005,
      restitution: 0.6,
    };
    this.body = Bodies.circle(x, y, r, options);
    this.r = r;
    World.add(world, this.body);
    this.trail = [];
  }

  isOffScreen() {
    let pos = this.body.position;
    return pos.y > height + 100;
  }

  removeFromWorld() {
    World.remove(world, this.body);
  }

  show() {
    let pos = this.body.position;
    let angle = this.body.angle;
    this.trail.push({ x: pos.x, y: pos.y });
    if (this.trail.length > 25) {
      this.trail.shift();
    }

    // Draw trail
    noFill();
    strokeWeight(2);
    beginShape();
    for (let i = 0; i < this.trail.length; i++) {
      let t = map(i, 0, this.trail.length, 0, 1);
      stroke(200, 100, 80, t * 100);
      vertex(this.trail[i].x, this.trail[i].y);
    }
    endShape();

    // Draw particle
    push();
    translate(pos.x, pos.y);
    rotate(angle);
    noStroke();
    fill(200, 100, 80);
    ellipse(0, 0, this.r * 2);
    pop();
  }
}

// Boundary class
class Boundary {
  constructor(x, y, w, h, angle) {
    let options = {
      isStatic: true,
      angle: angle,
      friction: 0.3,
    };
    this.body = Bodies.rectangle(x, y, w, h, options);
    this.w = w;
    this.h = h;
    this.color = color(random(180, 220), 50, 70);
    World.add(world, this.body);
  }

  update() {
    // Static boundary does not update
  }

  show() {
    let pos = this.body.position;
    let angle = this.body.angle;
    push();
    translate(pos.x, pos.y);
    rotate(angle);
    rectMode(CENTER);
    noStroke();
    fill(this.color);
    rect(0, 0, this.w, this.h, 10);
    pop();
  }
}

// MovingBoundary class
class MovingBoundary extends Boundary {
  constructor(x, y, w, h, angle) {
    super(x, y, w, h, angle);
    this.initialY = y;
    this.amplitude = random(50, 150);
    this.frequency = random(0.005, 0.02);
  }

  update() {
    let pos = this.body.position;
    let newY = this.initialY + sin(frameCount * this.frequency) * this.amplitude;
    Matter.Body.setPosition(this.body, { x: pos.x, y: newY });
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2460862","A Galaxy","mySketch","let particles = [];
let numParticles = 1500;
let blackHole;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();

  // Initialize particles at random positions around the center
  for (let i = 0; i < numParticles; i++) {
    let angle = random(TWO_PI);
    let radius = random(50, min(width, height) / 2);
    let x = width / 2 + radius * cos(angle);
    let y = height / 2 + radius * sin(angle);
    particles.push(new Particle(x, y));
  }

  // Create a black hole at the center
  blackHole = new BlackHole(width / 2, height / 2);
}

function draw() {
  background(10, 10, 30, 100);

  // Update and display particles
  for (let p of particles) {
    p.applyGravity(blackHole);
    p.update();
    p.display();
  }

  // Display black hole
  blackHole.display();

  t += 0.01;
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.sub(this.pos, createVector(width / 2, height / 2)).rotate(HALF_PI).setMag(2);
    this.acc = createVector();
    this.color = color(random(200, 255), random(100, 200), random(200, 255));
    this.size = random(1, 3);
  }

  applyGravity(blackHole) {
    let force = p5.Vector.sub(blackHole.pos, this.pos);
    let distanceSq = constrain(force.magSq(), 100, 1000);
    let G = 5;
    let strength = G / distanceSq;
    force.setMag(strength);
    this.acc.add(force);
  }

  update() {
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Wrap around edges
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }

  display() {
    fill(this.color);
    ellipse(this.pos.x, this.pos.y, this.size);
  }
}

class BlackHole {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.size = 50;
  }

  display() {
    noStroke();
    for (let i = this.size; i > 0; i -= 5) {
      fill(0, 0, 0, map(i, 0, this.size, 0, 255));
      ellipse(this.pos.x, this.pos.y, i * 2);
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2460858","Dynamic particles","mySketch","let particles = [];
let numParticles = 800;
let formationIndex = 0;
let formations = [];
let colors = [];
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();

  // Initialize colors
  for (let i = 0; i < numParticles; i++) {
    colors[i] = color(random(100, 255), random(100, 255), random(100, 255));
  }

  // Initialize particles at random positions
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height), colors[i]));
  }

  // Define different formations
  formations = [
    (i) => { // Smiley Face
      let angle = map(i % numParticles, 0, numParticles, 0, TWO_PI);
      let radius = min(width, height) / 4;

      let x = width / 2 + radius * cos(angle);
      let y = height / 2 + radius * sin(angle);

      // Eyes
      if (angle > PI / 8 && angle < PI / 8 * 3) {
        x = width / 2 - radius / 2.5 + random(-10, 10);
        y = height / 2 - radius / 2.5 + random(-10, 10);
      } else if (angle > PI / 8 * 5 && angle < PI / 8 * 7) {
        x = width / 2 + radius / 2.5 + random(-10, 10);
        y = height / 2 - radius / 2.5 + random(-10, 10);
      }
      // Mouth
      else if (angle > PI && angle < PI * 1.5) {
        x = width / 2 + (radius / 1.5) * cos(angle);
        y = height / 2 + (radius / 1.5) * sin(angle) + 30;
      }

      return createVector(x, y);
    },
    (i) => { // Heart Shape
      let angle = map(i % numParticles, 0, numParticles, -PI, PI);
      let x = 16 * pow(sin(angle), 3);
      let y = -(13 * cos(angle) - 5 * cos(2 * angle) - 2 * cos(3 * angle) - cos(4 * angle));
      let scaleFactor = min(width, height) / 25;
      return createVector(width / 2 + x * scaleFactor, height / 2 + y * scaleFactor);
    },
    (i) => { // Star
      let angle = map(i % numParticles, 0, numParticles, 0, TWO_PI * 5);
      let radius = min(width, height) / 3;
      let r = radius * (cos(5 * angle) + 1) / 2;
      let x = width / 2 + r * cos(angle);
      let y = height / 2 + r * sin(angle);
      return createVector(x, y);
    },
    (i) => { // Spiral Galaxy
      let angle = map(i, 0, numParticles, 0, TWO_PI * 4);
      let radius = map(i, 0, numParticles, 0, min(width, height) / 2);
      let offset = sin(angle * 3) * 50;
      let x = width / 2 + (radius + offset) * cos(angle);
      let y = height / 2 + (radius + offset) * sin(angle);
      return createVector(x, y);
    },
    (i) => { // Random Burst
      return createVector(random(width), random(height));
    }
  ];

  // Set initial formation
  setFormation();
}

function draw() {
  background(30, 30, 60, 100);

  // Update and display particles
  for (let p of particles) {
    p.update();
    p.display();
  }

  t += 0.01;
}

function mousePressed() {
  // Change formation on mouse click
  formationIndex = (formationIndex + 1) % formations.length;
  setFormation();
}

function setFormation() {
  // Assign target positions to particles based on the current formation
  for (let i = 0; i < particles.length; i++) {
    let target = formations[formationIndex](i);
    particles[i].setTarget(target.x, target.y);
  }
}

class Particle {
  constructor(x, y, col) {
    this.pos = createVector(x, y);
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 10;
    this.maxForce = 1;
    this.color = col;
    this.size = random(2, 5);
  }

  update() {
    // Arrival behavior towards target
    let desired = p5.Vector.sub(this.target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);

    this.acc.add(steer);
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  display() {
    fill(this.color);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  setTarget(x, y) {
    this.target = createVector(x, y);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  setFormation();
}
"
"2459967","Merger Sponge","mySketch","// Main p5.js sketch
let shaderProgram;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  noStroke();

  // Define the shader
  shaderProgram = createShader(vertShader, fragShader);
}

function draw() {
  background(0);

  // Use the custom shader
  shader(shaderProgram);

  // Pass uniforms to the shader
  shaderProgram.setUniform('u_time', millis() / 1000.0);
  shaderProgram.setUniform('u_resolution', [width, height]);
  shaderProgram.setUniform('u_mouse', [mouseX, mouseY]);

  // Render a plane that covers the entire screen
  plane(width, height);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

// Vertex Shader
const vertShader = `
  precision mediump float;

  // Vertex attributes
  attribute vec3 aPosition;

  // Uniforms for transformation matrices
  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;

  void main() {
    // Apply the model-view and projection transformations
    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
  }
`;

// Fragment Shader
const fragShader = `
  precision highp float;

  // Uniforms
  uniform float u_time;
  uniform vec2 u_resolution;
  uniform vec2 u_mouse;

  // Function to rotate a vector around an arbitrary axis
  mat3 rotate(vec3 axis, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat3(
      oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
      oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,
      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c
    );
  }

  // Distance estimator for the Menger Sponge fractal
  float mengerSponge(vec3 p) {
    float scale = 3.0;
    float minDist = 1e20;

    for (int i = 0; i < 3; i++) {
      p = abs(p);
      // Swap components correctly
      if (p.x < p.y) {
        float temp = p.x;
        p.x = p.y;
        p.y = temp;
      }
      if (p.x < p.z) {
        float temp = p.x;
        p.x = p.z;
        p.z = temp;
      }
      if (p.y < p.z) {
        float temp = p.y;
        p.y = p.z;
        p.z = temp;
      }
      p = scale * p - vec3(scale - 1.0);
      float dist = length(p) / pow(scale, float(i));
      minDist = min(minDist, dist);
    }

    return minDist;
  }

  void main() {
    // Compute UV coordinates
    vec2 uv = (gl_FragCoord.xy / u_resolution.xy) * 2.0 - 1.0;
    uv.x *= u_resolution.x / u_resolution.y;

    // Camera setup
    vec3 ro = vec3(0.0, 0.0, -4.0); // Ray origin
    vec3 rd = normalize(vec3(uv, 1.5)); // Ray direction

    // Rotate the camera based on time and mouse position
    float angle = u_time * 0.5 + (u_mouse.x / u_resolution.x - 0.5) * 3.14;
    vec3 axis = normalize(vec3(0.5, 1.0, 0.0));
    mat3 rotation = rotate(axis, angle);
    ro = rotation * ro;
    rd = rotation * rd;

    // Ray marching
    float totalDistance = 0.0;
    bool hit = false;
    vec3 p;

    for (int i = 0; i < 48; i++) {
      p = ro + rd * totalDistance;
      float distance = mengerSponge(p);
      if (distance < 0.001) {
        hit = true;
        break;
      }
      totalDistance += distance * 0.5; // Step size
      if (totalDistance > 100.0) break;
    }

    if (hit) {
      // Calculate normal for lighting using finite differences
      float eps = 0.001;
      vec3 n = normalize(vec3(
        mengerSponge(p + vec3(eps, 0.0, 0.0)) - mengerSponge(p - vec3(eps, 0.0, 0.0)),
        mengerSponge(p + vec3(0.0, eps, 0.0)) - mengerSponge(p - vec3(0.0, eps, 0.0)),
        mengerSponge(p + vec3(0.0, 0.0, eps)) - mengerSponge(p - vec3(0.0, 0.0, eps))
      ));

      // Simple Phong shading
      vec3 lightPos = vec3(5.0, 5.0, -5.0);
      vec3 lightDir = normalize(lightPos - p);
      float diffuse = max(dot(n, lightDir), 0.0);
      vec3 reflectDir = reflect(-lightDir, n);
      vec3 viewDir = normalize(-rd);
      float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);
      vec3 color = vec3(0.8, 0.7, 0.5) * diffuse + vec3(1.0) * spec;

      gl_FragColor = vec4(color, 1.0);
    } else {
      // Background color
      gl_FragColor = vec4(0.0, 0.1, 0.2, 1.0);
    }
  }
`;
"
"2459271","Earth with Sky","mySketch","// Main p5.js sketch
let globeTexture;

function preload() {
  // Load the Earth texture image
  globeTexture = loadImage('earth_texture.jpg'); // Replace with your texture image path
}

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  noStroke();
}

function drawStars(numStars) {
  push();
  noStroke();
  fill(255);
  for (let i = 0; i < numStars; i++) {
    let x = random(-width, width);
    let y = random(-height, height);
    let z = random(-width, width);
    push();
    translate(x, y, z);
    sphere(1);
    pop();
  }
  pop();
}

function draw() {
  background(0);

  // Draw stars
  push();
  translate(0, 0, -500);
  drawStars(500);
  pop();

  // Set up lighting
ambientLight(30);
pointLight(255, 255, 255, 0, -height / 2, 200);

  // Rotate the globe over time
  rotateY(millis() / 10000);

  // Apply the texture and draw the sphere
  texture(globeTexture);
  sphere(min(width, height) / 3);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}


"
"2459267","Vertex Shader","mySketch","// Main p5.js sketch
let shaderProgram;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  noStroke();

  // Define the shader
  shaderProgram = createShader(vertShader, fragShader);
}

function draw() {
  background(0);

  // Use the custom shader
  shader(shaderProgram);

  // Pass uniforms to the shader
  shaderProgram.setUniform('u_time', millis() / 1000.0);
  shaderProgram.setUniform('u_resolution', [width, height]);
  shaderProgram.setUniform('u_mouse', [mouseX, mouseY]);

  // Render a plane that covers the entire screen
  plane(width, height);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

// Vertex Shader
const vertShader = `
  precision mediump float;

  // Vertex attributes
  attribute vec3 aPosition;
  attribute vec2 aTexCoord;

  // Varying to pass texture coordinates to the fragment shader
  varying vec2 vTexCoord;

  // Uniforms for transformation matrices
  uniform mat4 uModelViewMatrix;
  uniform mat4 uProjectionMatrix;

  void main() {
    // Pass the texture coordinates to the fragment shader
    vTexCoord = aTexCoord;

    // Apply the model-view and projection transformations
    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
  }
`;

// Fragment Shader
const fragShader = `
  precision highp float;

  // Uniforms
  uniform float u_time;
  uniform vec2 u_resolution;
  uniform vec2 u_mouse;

  // Varying from the vertex shader
  varying vec2 vTexCoord;

  // Function to rotate a vector around the Y-axis
  mat3 rotateY(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat3(
      c, 0.0, -s,
      0.0, 1.0, 0.0,
      s, 0.0, c
    );
  }

  // Distance Estimator (DE) for a Mandelbulb fractal
  float mandelbulb(vec3 p) {
    vec3 z = p;
    float dr = 1.0;
    float r = 0.0;

    for (int i = 0; i < 8; i++) {
      r = length(z);
      if (r > 2.0) break;

      // Convert to spherical coordinates
      float theta = acos(z.z / r);
      float phi = atan(z.y, z.x);
      float power = 8.0;

      // Scale and rotate the point
      dr =  pow(r, power - 1.0) * power * dr + 1.0;
      float zr = pow(r, power);
      theta = theta * power;
      phi = phi * power;

      // Convert back to cartesian coordinates
      z = zr * vec3(
        sin(theta) * cos(phi),
        sin(phi) * sin(theta),
        cos(theta)
      );
      z += p;
    }
    return 0.5 * log(r) * r / dr;
  }

  void main() {
    // vTexCoord ranges from 0.0 to 1.0
    // Adjust to range from -1.0 to 1.0
    vec2 uv = vTexCoord * 2.0 - 1.0;

    // Adjust for aspect ratio
    float aspect = u_resolution.x / u_resolution.y;
    uv.x *= aspect;

    // Camera setup
    vec3 ro = vec3(0.0, 0.0, -5.0); // Ray origin
    vec3 rd = normalize(vec3(uv, 1.5)); // Ray direction

    // Rotate the camera based on time and mouse position
    float angle = u_time * 0.2 + (u_mouse.x / u_resolution.x - 0.5) * 3.14;
    mat3 rotation = rotateY(angle);
    ro = rotation * ro;
    rd = rotation * rd;

    // Ray marching
    float totalDistance = 0.0;
    bool hit = false;
    vec3 p;

    for (int i = 0; i < 128; i++) {
      p = ro + rd * totalDistance;
      float distance = mandelbulb(p);
      if (distance < 0.001) {
        hit = true;
        break;
      }
      totalDistance += distance;
      if (totalDistance > 100.0) break;
    }

    if (hit) {
      // Calculate normal for lighting using finite differences
      float eps = 0.001;
      vec3 n = normalize(vec3(
        mandelbulb(p + vec3(eps, 0.0, 0.0)) - mandelbulb(p - vec3(eps, 0.0, 0.0)),
        mandelbulb(p + vec3(0.0, eps, 0.0)) - mandelbulb(p - vec3(0.0, eps, 0.0)),
        mandelbulb(p + vec3(0.0, 0.0, eps)) - mandelbulb(p - vec3(0.0, 0.0, eps))
      ));

      // Simple Lambertian shading
      float diffuse = max(dot(n, vec3(0.0, 0.0, -1.0)), 0.0);
      vec3 color = vec3(0.2, 0.5, 0.9) * diffuse;

      gl_FragColor = vec4(color, 1.0);
    } else {
      // Background color
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
  }
`;

"
"2459236","Liquid motion","mySketch","let particles = [];
let numParticles = 2000;
let flowField;
let cols, rows;
let scale = 10;
let zOff = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  cols = floor(width / scale);
  rows = floor(height / scale);
  flowField = new Array(cols * rows);
  for (let i = 0; i < numParticles; i++) {
    particles[i] = new Particle();
  }
}

function draw() {
  background(0, 10);
  let yOff = 0;
  for (let y = 0; y < rows; y++) {
    let xOff = 0;
    for (let x = 0; x < cols; x++) {
      let index = x + y * cols;
      let angle = noise(xOff, yOff, zOff) * TWO_PI * 4;
      let v = p5.Vector.fromAngle(angle);
      v.setMag(0.5);
      flowField[index] = v;
      xOff += 0.1;
    }
    yOff += 0.1;
  }
  zOff += 0.005;

  for (let i = 0; i < particles.length; i++) {
    particles[i].follow(flowField);
    particles[i].update();
    particles[i].edges();
    particles[i].show();
  }
}

function mouseDragged() {
  particles.push(new Particle(mouseX, mouseY));
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x || random(width), y || random(height));
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.maxSpeed = 4;
    this.prevPos = this.pos.copy();
    this.hue = random(360);
  }

  update() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  follow(vectors) {
    let x = floor(this.pos.x / scale);
    let y = floor(this.pos.y / scale);
    let index = x + y * cols;
    let force = vectors[index];
    this.applyForce(force);
  }

  applyForce(force) {
    this.acc.add(force);
  }

  show() {
    stroke((this.hue + frameCount) % 360, 255, 255, 50);
    strokeWeight(2);
    line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
    this.updatePrev();
  }

  updatePrev() {
    this.prevPos.x = this.pos.x;
    this.prevPos.y = this.pos.y;
  }

  edges() {
    if (this.pos.x > width) {
      this.pos.x = 0;
      this.updatePrev();
    }
    if (this.pos.x < 0) {
      this.pos.x = width;
      this.updatePrev();
    }
    if (this.pos.y > height) {
      this.pos.y = 0;
      this.updatePrev();
    }
    if (this.pos.y < 0) {
      this.pos.y = height;
      this.updatePrev();
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2456911","Liquides","mySketch","let fluid;

function setup() {
  createCanvas(800, 800);
  pixelDensity(1); // Ensure consistent pixel density
  fluid = new Fluid(0.2, 0, 0.0001); // dt, diffusion, viscosity
}

function draw() {
  background(0);

  // Add fluid at mouse position when pressed
  if (mouseIsPressed) {
    let x = floor(mouseX / fluid.scale);
    let y = floor(mouseY / fluid.scale);
    fluid.addDensity(x, y, 100);
    let amountX = (mouseX - pmouseX) * 0.1;
    let amountY = (mouseY - pmouseY) * 0.1;
    fluid.addVelocity(x, y, amountX, amountY);
  }

  fluid.step();
  fluid.renderD();
}

class Fluid {
  constructor(dt, diffusion, viscosity) {
    this.N = 100; // Reduced grid size for performance
    this.dt = dt;
    this.diff = diffusion;
    this.visc = viscosity;

    this.size = this.N + 2; // Including boundary
    this.s = new Array(this.size * this.size).fill(0);
    this.density = new Array(this.size * this.size).fill(0);

    this.Vx = new Array(this.size * this.size).fill(0);
    this.Vy = new Array(this.size * this.size).fill(0);

    this.Vx0 = new Array(this.size * this.size).fill(0);
    this.Vy0 = new Array(this.size * this.size).fill(0);

    this.scale = width / this.N;
  }

  addDensity(x, y, amount) {
    let index = IX(x, y);
    if (index >= 0 && index < this.density.length) {
      this.density[index] += amount;
    }
  }

  addVelocity(x, y, amountX, amountY) {
    let index = IX(x, y);
    if (index >= 0 && index < this.Vx.length) {
      this.Vx[index] += amountX;
      this.Vy[index] += amountY;
    }
  }

  step() {
    let N = this.N;
    let visc = this.visc;
    let diff = this.diff;
    let dt = this.dt;
    let Vx = this.Vx;
    let Vy = this.Vy;
    let Vx0 = this.Vx0;
    let Vy0 = this.Vy0;
    let s = this.s;
    let density = this.density;

    diffuse(1, Vx0, Vx, visc, dt, N);
    diffuse(2, Vy0, Vy, visc, dt, N);

    project(Vx0, Vy0, Vx, Vy, N);

    advect(1, Vx, Vx0, Vx0, Vy0, dt, N);
    advect(2, Vy, Vy0, Vx0, Vy0, dt, N);

    project(Vx, Vy, Vx0, Vy0, N);

    diffuse(0, s, density, diff, dt, N);
    advect(0, density, s, Vx, Vy, dt, N);
  }

  renderD() {
    loadPixels();
    for (let i = 1; i <= this.N; i++) {
      for (let j = 1; j <= this.N; j++) {
        let x = (i - 1) * this.scale;
        let y = (j - 1) * this.scale;
        let d = this.density[IX(i, j)];
        if (d > 0) {
          let screenX = floor(x);
          let screenY = floor(y);
          if (screenX >= 0 && screenX < width && screenY >= 0 && screenY < height) {
            let pixelIndex = 4 * (screenX + screenY * width);
            // Example color mapping (adjust as needed)
            pixels[pixelIndex] = 180; // Red
            pixels[pixelIndex + 1] = 255; // Green
            pixels[pixelIndex + 2] = constrain(d, 0, 255); // Blue
            pixels[pixelIndex + 3] = 255; // Alpha
          }
        }
      }
    }
    updatePixels();
  }
}

// Helper Functions

function IX(x, y) {
  return x + (y * (100 + 2)); // Adjusted for boundary
}

function diffuse(b, x, x0, diff, dt, N) {
  let a = dt * diff * N * N;
  lin_solve(b, x, x0, a, 1 + 4 * a, N);
}

function lin_solve(b, x, x0, a, c, N) {
  for (let k = 0; k < 10; k++) { // Reduced iterations for performance
    for (let j = 1; j <= N; j++) {
      for (let i = 1; i <= N; i++) {
        x[IX(i, j)] =
          (x0[IX(i, j)] +
            a *
              (x[IX(i + 1, j)] +
                x[IX(i - 1, j)] +
                x[IX(i, j + 1)] +
                x[IX(i, j - 1)])) /
          c;
      }
    }
    set_bnd(b, x, N);
  }
}

function advect(b, d, d0, velocX, velocY, dt, N) {
  let dt0 = dt * N;
  for (let j = 1; j <= N; j++) {
    for (let i = 1; i <= N; i++) {
      let x = i - dt0 * velocX[IX(i, j)];
      let y = j - dt0 * velocY[IX(i, j)];
      if (x < 0.5) x = 0.5;
      if (x > N + 0.5) x = N + 0.5;
      let i0 = floor(x);
      let i1 = i0 + 1;
      if (y < 0.5) y = 0.5;
      if (y > N + 0.5) y = N + 0.5;
      let j0 = floor(y);
      let j1 = j0 + 1;
      let s1 = x - i0;
      let s0 = 1 - s1;
      let t1 = y - j0;
      let t0 = 1 - t1;
      d[IX(i, j)] =
        s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
        s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
    }
  }
  set_bnd(b, d, N);
}

function project(velocX, velocY, p, div, N) {
  for (let j = 1; j <= N; j++) {
    for (let i = 1; i <= N; i++) {
      div[IX(i, j)] =
        (-0.5 *
          (velocX[IX(i + 1, j)] -
            velocX[IX(i - 1, j)] +
            velocY[IX(i, j + 1)] -
            velocY[IX(i, j - 1)])) /
        N;
      p[IX(i, j)] = 0;
    }
  }
  set_bnd(0, div, N);
  set_bnd(0, p, N);
  lin_solve(0, p, div, 1, 4, N);
  for (let j = 1; j <= N; j++) {
    for (let i = 1; i <= N; i++) {
      velocX[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) * N;
      velocY[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) * N;
    }
  }
  set_bnd(1, velocX, N);
  set_bnd(2, velocY, N);
}

function set_bnd(b, x, N) {
  for (let i = 1; i <= N; i++) {
    x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
    x[IX(i, N + 1)] = b === 2 ? -x[IX(i, N)] : x[IX(i, N)];
  }
  for (let j = 1; j <= N; j++) {
    x[IX(0, j)] = b === 1 ? -x[IX(1, j)] : x[IX(1, j)];
    x[IX(N + 1, j)] = b === 1 ? -x[IX(N, j)] : x[IX(N, j)];
  }
  // Corners
  x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
  x[IX(0, N + 1)] = 0.5 * (x[IX(1, N + 1)] + x[IX(0, N)]);
  x[IX(N + 1, 0)] = 0.5 * (x[IX(N, 0)] + x[IX(N + 1, 1)]);
  x[IX(N + 1, N + 1)] = 0.5 * (x[IX(N, N + 1)] + x[IX(N + 1, N)]);
}
"
"2450196","Triangle and Angles","mySketch","// Interactive Triangle with Dynamic Angles
// Click and drag the vertices to reshape the triangle

let vertexA, vertexB, vertexC;
let draggingVertex = null;

function setup() {
  createCanvas(windowWidth, windowHeight);
  // Initialize the vertices of the triangle
  vertexA = createVector(width / 2 - 100, height / 2 - 100);
  vertexB = createVector(width / 2 + 100, height / 2 - 100);
  vertexC = createVector(width / 2, height / 2 + 100);
}

function draw() {
  background(255);
  noFill();
  stroke(0);
  strokeWeight(1);

  // Draw the triangle
  triangle(vertexA.x, vertexA.y, vertexB.x, vertexB.y, vertexC.x, vertexC.y);

  // Draw vertices as circles
  fill(255);
  stroke(0);
  ellipse(vertexA.x, vertexA.y, 10);
  ellipse(vertexB.x, vertexB.y, 10);
  ellipse(vertexC.x, vertexC.y, 10);

  // Calculate side lengths
  let sideA = dist(vertexB.x, vertexB.y, vertexC.x, vertexC.y); // opposite to vertexA
  let sideB = dist(vertexA.x, vertexA.y, vertexC.x, vertexC.y); // opposite to vertexB
  let sideC = dist(vertexA.x, vertexA.y, vertexB.x, vertexB.y); // opposite to vertexC

  // Calculate angles using Law of Cosines
  let angleA = degrees(acos((sq(sideB) + sq(sideC) - sq(sideA)) / (2 * sideB * sideC)));
  let angleB = degrees(acos((sq(sideA) + sq(sideC) - sq(sideB)) / (2 * sideA * sideC)));
  let angleC = 180 - angleA - angleB; // Ensure sum to 180°

  angleA = angleA.toFixed(1);
  angleB = angleB.toFixed(1);
  angleC = angleC.toFixed(1);

  // Display angles
  displayAngle(vertexA, angleA);
  displayAngle(vertexB, angleB);
  displayAngle(vertexC, angleC);

  // Calculate perimeter
  let perimeter = sideA + sideB + sideC;

  // Calculate area using Heron's formula
  let s = perimeter / 2;
  let area = sqrt(s * (s - sideA) * (s - sideB) * (s - sideC));

  // Display perimeter and area
  fill(0);
  noStroke();
  textSize(16);
  textAlign(LEFT, TOP);
  text(""Perimeter: "" + perimeter.toFixed(2), 10, 10);
  text(""Area: "" + area.toFixed(2), 10, 30);
}

function displayAngle(vertex, angle) {
  fill(0);
  noStroke();
  textSize(16);
  textAlign(CENTER, CENTER);
  text(angle + ""°"", vertex.x, vertex.y - 20);
}

function mousePressed() {
  // Check if the mouse is over any vertex
  if (dist(mouseX, mouseY, vertexA.x, vertexA.y) < 10) {
    draggingVertex = vertexA;
  } else if (dist(mouseX, mouseY, vertexB.x, vertexB.y) < 10) {
    draggingVertex = vertexB;
  } else if (dist(mouseX, mouseY, vertexC.x, vertexC.y) < 10) {
    draggingVertex = vertexC;
  }
}

function mouseDragged() {
  // Update the position of the dragged vertex
  if (draggingVertex) {
    draggingVertex.x = mouseX;
    draggingVertex.y = mouseY;
  }
}

function mouseReleased() {
  // Stop dragging when the mouse is released
  draggingVertex = null;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function touchStarted() {
  mousePressed();
}

function touchMoved() {
  mouseDragged();
  return false; // Prevent default behavior
}

function touchEnded() {
  mouseReleased();
}
"
"2443373","Reality is an illusion","mySketch","let particles = [];
let userInput = ""Reality is merely an illusion, albeit a very persistent one."";
let fontSize = 64; // Reduced font size for longer sentences
let pg; // Graphics buffer for text
let step = 3; // Step size for pixel sampling
let hueShift = 0;
let mic, fft;

function preload() {
  // Preload fonts if adding multiple fonts
  // fonts.push(loadFont('assets/Arial.ttf'));
}

function setup() {
  createCanvas(800, 400);
  colorMode(HSB, 360, 100, 100, 100);
  noStroke();

  // Create and configure the text graphics buffer
  pg = createGraphics(width, height);
  pg.pixelDensity(1);
  pg.textAlign(LEFT, TOP); // Changed alignment for wrapping
  pg.textSize(fontSize);
  pg.colorMode(HSB, 360, 100, 100, 100);
  pg.background(0, 0, 0, 0);
  pg.fill(0, 0, 0, 100);

  // Initialize audio
  mic = new p5.AudioIn();
  mic.start();
  fft = new p5.FFT();
  fft.setInput(mic);

  // Input for user text
  let textInput = createInput(userInput);
  textInput.position(10, height + 10);
  textInput.size(400);
  textInput.input(updateUserText);

  generateParticles();
}

function draw() {
  // Animated Gradient Background
  for (let y = 0; y < height; y++) {
    let inter = map(y, 0, height, 0, 1);
    let c = lerpColor(color(200, 50, 100), color(300, 50, 100), inter);
    stroke(c);
    line(0, y, width, y);
  }

  // Update and display particles
  let spectrum = fft.analyze();
  let bass = fft.getEnergy(""bass"");
  hueShift = (hueShift + 0.5) % 360;

  for (let p of particles) {
    p.behaviors(bass, hueShift);
    p.update();
    p.show();
  }
}

function updateUserText() {
  userInput = this.value();
  generateParticles();
}

function generateParticles() {
  particles = [];
  pg.clear();

  // Render the text inside a rectangle to allow wrapping
  pg.background(0, 0, 0, 0);
  pg.textAlign(LEFT, TOP); // Changed alignment for wrapping
  pg.textSize(fontSize);
  pg.fill(0, 0, 0, 100);
  pg.text(userInput, 10, 10, pg.width - 20, pg.height - 20); // Added width and height for wrapping

  pg.loadPixels();

  // Iterate through pixels with the specified step size
  for (let x = 0; x < pg.width; x += step) {
    for (let y = 0; y < pg.height; y += step) {
      let index = (x + y * pg.width) * 4;
      // Check if the pixel is not transparent (alpha > 128)
      if (pg.pixels[index + 3] > 128) {
        let posX = x;
        let posY = y;
        let particle = new Particle(posX, posY);
        particles.push(particle);
      }
    }
  }

  pg.updatePixels();
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(random(width), random(height));
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 5;
    this.maxForce = 0.5;
    this.size = random(2, 5);
  }

  show() {
    let noiseVal = noise(this.pos.x * 0.01, this.pos.y * 0.01);
    stroke((noiseVal * 360 + hueShift) % 360, 80, 100, 80);
    strokeWeight(this.size);
    point(this.pos.x, this.pos.y);
  }

  behaviors(bass, hueShift) {
    let arrive = this.arrive(this.target);
    let gravity = createVector(0, 0.05 * (1 + bass / 255));
    let mouse = createVector(mouseX, mouseY);
    let flee = this.flee(mouse);

    arrive.mult(1);
    flee.mult(5);
    gravity.mult(1);

    this.applyForce(arrive);
    this.applyForce(flee);
    this.applyForce(gravity);
  }

  applyForce(f) {
    this.acc.add(f);
  }

  update() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Wrap around edges
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }

  show() {
    stroke((hueShift + this.pos.x / width * 360) % 360, 80, 100, 80);
    strokeWeight(this.size);
    point(this.pos.x, this.pos.y);
  }

  arrive(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);
    return steer;
  }

  flee(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    if (d < 50) {
      desired.setMag(this.maxSpeed);
      desired.mult(-1);
      let steer = p5.Vector.sub(desired, this.vel);
      steer.limit(this.maxForce);
      return steer;
    } else {
      return createVector(0, 0);
    }
  }
}
"
"2443329","Watch","mySketch","let gears = [];
let pendulum;
let lastSecond = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  angleMode(DEGREES);

  // Initialize pendulum with period close to 1 second
  pendulum = new Pendulum(0, -200, 200);

  // Initialize gears with correct gear ratios
  // Teeth numbers chosen to match real clock ratios
  let secondGear = new Gear(0, 0, 60, 50);  // Second gear (60 teeth)
  let minuteGear = new Gear(0, 0, 60, 40);  // Minute gear (60 teeth)
  let hourGear = new Gear(0, 0, 12, 30);    // Hour gear (12 teeth)

  // Connect gears
  secondGear.connectTo(minuteGear);
  minuteGear.connectTo(hourGear);

  gears.push(secondGear, minuteGear, hourGear);
}

function draw() {
  background(255);
  translate(width / 2, height / 2);

  // Update pendulum
  pendulum.update();
  pendulum.display();

  // Get current time in Lisbon
  let { hr, mn, sc } = getLisbonTime();

  // If the second has changed, advance the second gear
  if (sc !== lastSecond) {
    lastSecond = sc;
    gears[0].advance();
  }

  // Update and display gears
  for (let gear of gears) {
    gear.update();
    gear.display();
  }

  // Draw clock hands
  drawClockHands(hr, mn, sc);
}

// Function to get the current time in Lisbon
function getLisbonTime() {
  let now = new Date();
  let lisbonNow = new Date(now.toLocaleString('en-US', { timeZone: 'Europe/Lisbon' }));
  let hr = lisbonNow.getHours();
  let mn = lisbonNow.getMinutes();
  let sc = lisbonNow.getSeconds();
  return { hr, mn, sc };
}

// Pendulum class
class Pendulum {
  constructor(x, y, length) {
    this.origin = createVector(x, y);
    this.position = createVector();
    this.length = length;
    this.angle = 30; // Initial angle
    this.aVelocity = 0;
    this.aAcceleration = 0;
    this.damping = 0.999;
    this.gravity = 1;
  }

  update() {
    this.aAcceleration = (-this.gravity / this.length) * sin(this.angle);
    this.aVelocity += this.aAcceleration;
    this.aVelocity *= this.damping;
    this.angle += this.aVelocity;

    this.position.set(
      this.origin.x + this.length * sin(this.angle),
      this.origin.y + this.length * cos(this.angle)
    );
  }

  display() {
    stroke(0);
    strokeWeight(2);
    line(this.origin.x, this.origin.y, this.position.x, this.position.y);
    fill(0);
    ellipse(this.position.x, this.position.y, 20, 20);
  }
}

// Gear class
class Gear {
  constructor(x, y, teeth, radius) {
    this.position = createVector(x, y);
    this.teeth = teeth;
    this.radius = radius;
    this.angle = 0;
    this.connectedGears = [];
    this.rotationSpeed = 0;
  }

  connectTo(gear) {
    this.connectedGears.push(gear);
  }

  advance() {
    // Advance by one tooth per second
    this.rotationSpeed += 360 / this.teeth;
  }

  update() {
    this.angle += this.rotationSpeed;
    this.rotationSpeed = 0; // Reset after each update

    for (let gear of this.connectedGears) {
      gear.angle += -this.rotationSpeed * (this.teeth / gear.teeth);
    }
  }

  display() {
    push();
    translate(this.position.x, this.position.y);
    rotate(this.angle);
    stroke(0);
    strokeWeight(1);
    noFill();
    ellipse(0, 0, this.radius * 2);

    // Draw gear teeth
    for (let i = 0; i < this.teeth; i++) {
      line(this.radius, 0, this.radius + 5, 0);
      rotate(360 / this.teeth);
    }
    pop();
  }
}

// Function to draw clock hands
function drawClockHands(hr, mn, sc) {
  // Calculate angles based on current time
  let secondAngle = map(sc, 0, 60, 0, 360);
  let minuteAngle = map(mn + sc / 60, 0, 60, 0, 360);
  let hourAngle = map((hr % 12) + mn / 60, 0, 12, 0, 360);

  // Draw hour hand
  push();
  rotate(hourAngle - 90);
  stroke(0);
  strokeWeight(6);
  line(0, 0, 50, 0);
  pop();

  // Draw minute hand
  push();
  rotate(minuteAngle - 90);
  stroke(0);
  strokeWeight(4);
  line(0, 0, 70, 0);
  pop();

  // Draw second hand
  push();
  rotate(secondAngle - 90);
  stroke(255, 0, 0);
  strokeWeight(2);
  line(0, 0, 90, 0);
  pop();

  // Draw clock center
  fill(0);
  noStroke();
  ellipse(0, 0, 10, 10);
}
"
"2443319","What time is it?","mySketch","let gearHour, gearMinute, gearSecond;

function setup() {
  createCanvas(windowWidth, windowHeight);
  angleMode(DEGREES);

  // Initialize gears
  gearSecond = new Gear(200, 0, 60, 60);   // Second gear with 60 teeth
  gearMinute = new Gear(0, 0, 60, 120);    // Minute gear with 60 teeth
  gearHour = new Gear(-200, 0, 40, 80);    // Hour gear with 40 teeth
}

function draw() {
  background(30);
  translate(width / 2, height / 2);
  rotate(-90);

  // Get current time in Lisbon
  let { hr, mn, sc } = getLisbonTime();

  // Compute angles for clock hands
  let secondAngle = map(sc, 0, 60, 0, 360);
  let minuteAngle = map(mn + sc / 60, 0, 60, 0, 360);
  let hourAngle = map(hr % 12 + mn / 60, 0, 12, 0, 360);

  // Update gears to rotate opposite to the clock hands
  gearSecond.angle = -secondAngle;
  gearMinute.angle = -minuteAngle;
  gearHour.angle = -hourAngle;

  // Display gears
  gearSecond.display();
  gearMinute.display();
  gearHour.display();

  // Draw clock face
  stroke(255);
  strokeWeight(8);
  noFill();
  ellipse(0, 0, 400, 400);

  // Draw clock hands
  drawHand(secondAngle, 150, 2, color(255, 100, 150)); // Second hand
  drawHand(minuteAngle, 120, 4, color(150, 100, 255)); // Minute hand
  drawHand(hourAngle, 90, 6, color(150, 255, 100));    // Hour hand

  // Draw clock center
  stroke(255);
  point(0, 0);
}

// Function to draw each clock hand
function drawHand(angle, length, weight, col) {
  push();
  rotate(angle);
  stroke(col);
  strokeWeight(weight);
  line(0, 0, length, 0);
  pop();
}

// Function to get the current time in Lisbon
function getLisbonTime() {
  let now = new Date();
  let lisbonNow = new Date(now.toLocaleString('en-US', { timeZone: 'Europe/Lisbon' }));
  let hr = lisbonNow.getHours();
  let mn = lisbonNow.getMinutes();
  let sc = lisbonNow.getSeconds();
  return { hr, mn, sc };
}

// Gear class definition
class Gear {
  constructor(x, y, teeth, radius) {
    this.x = x;
    this.y = y;
    this.teeth = teeth;
    this.radius = radius;
    this.angle = 0;
  }

  display() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);
    stroke(200);
    noFill();
    ellipse(0, 0, this.radius * 2);

    // Draw gear teeth
    for (let i = 0; i < this.teeth; i++) {
      line(this.radius, 0, this.radius + 10, 0);
      rotate(360 / this.teeth);
    }
    pop();
  }
}
"
"2442976","Galaxies, Clouds and Waves","mySketch","let particles = [];
let numParticles = 1000;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();

  // Initialize particles at random positions
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }

  // Initialize first organic formation
  setFormation();
}

function draw() {
  background(10, 10, 30, 50);

  // Update and display particles
  for (let p of particles) {
    p.update();
    p.display();
  }

  t += 0.01;
}

function mousePressed() {
  // Generate a new organic form on mouse click
  setFormation();
}

function setFormation() {
  // Randomly choose between clouds, galaxies, and waves
  let formations = [generateCloud, generateGalaxy, generateWaves];
  let formationIndex = floor(random(formations.length));
  let organicPoints = formations[formationIndex]();

  // Assign target positions to particles
  for (let i = 0; i < particles.length; i++) {
    let idx = i % organicPoints.length;
    let targetData = organicPoints[idx];
    particles[i].setTarget(targetData.x, targetData.y);
    particles[i].setColor(targetData.color);
  }
}

// Function to generate cloud points
function generateCloud() {
  let points = [];
  let centerX = random(width * 0.3, width * 0.7);
  let centerY = random(height * 0.3, height * 0.7);
  let maxRadius = random(50, 150);
  let numBlobs = floor(random(3, 7));

  for (let i = 0; i < numBlobs; i++) {
    let blobCenterX = centerX + random(-maxRadius, maxRadius);
    let blobCenterY = centerY + random(-maxRadius, maxRadius);
    let blobRadius = random(30, maxRadius);

    // Generate points for each blob
    for (let angle = 0; angle < TWO_PI; angle += TWO_PI / 100) {
      let r = blobRadius + random(-10, 10);
      let x = blobCenterX + r * cos(angle);
      let y = blobCenterY + r * sin(angle);
      points.push({ x: x, y: y, color: color(255, 255, 255, random(100, 200)) });
    }
  }

  return points;
}

// Function to generate galaxy points
function generateGalaxy() {
  let points = [];
  let centerX = width / 2;
  let centerY = height / 2;
  let arms = floor(random(2, 6)); // Number of spiral arms
  let armOffset = random(PI / 4, PI / 2);
  let maxRadius = min(width, height) / 2;

  for (let i = 0; i < numParticles; i++) {
    let angle = random(TWO_PI);
    let radius = pow(random(0, 1), 2) * maxRadius;
    let armAngle = floor((angle / TWO_PI) * arms) * (TWO_PI / arms);
    let offset = armOffset * radius / maxRadius;
    let x = centerX + radius * cos(angle + offset);
    let y = centerY + radius * sin(angle + offset);
    let brightness = map(radius, 0, maxRadius, 255, 50);
    points.push({ x: x, y: y, color: color(brightness, brightness, brightness) });
  }

  return points;
}

// Function to generate wave points
function generateWaves() {
  let points = [];
  let waveHeight = random(50, 150);
  let waveLength = random(100, 300);
  let numWaves = floor(random(1, 3));
  let amplitude = random(20, 50);

  for (let i = 0; i < numParticles; i++) {
    let x = map(i, 0, numParticles, 0, width);
    let y = height / 2;
    for (let n = 1; n <= numWaves; n++) {
      y += sin((x / waveLength) * TWO_PI + (n * t)) * (amplitude / n);
    }
    y += random(-5, 5); // Add some noise
    points.push({ x: x, y: y, color: color(0, 105, 148) }); // Ocean blue
  }

  return points;
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 10;
    this.maxForce = 1;
    this.color = color(255, 255, 255);
    this.size = random(1, 3);
  }

  update() {
    // Arrival behavior towards target
    let desired = p5.Vector.sub(this.target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);

    this.acc.add(steer);
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Fade color based on speed
    let speedMag = this.vel.mag();
    let alpha = map(speedMag, 0, this.maxSpeed, 50, 255);
    this.color.setAlpha(alpha);
  }

  display() {
    fill(this.color);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  setTarget(x, y) {
    this.target = createVector(x, y);
  }

  setColor(c) {
    this.color = c;
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  setFormation();
}
"
"2442973","Skylines","mySketch","let particles = [];
let numParticles = 3000;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();

  // Initialize particles at random positions
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }

  // Initialize first skyline formation
  setFormation();
}

function draw() {
  background(10, 10, 30, 50);

  // Update and display particles
  for (let p of particles) {
    p.update();
    p.display();
  }

  t += 0.01;
}

function mousePressed() {
  // Generate a new skyline on mouse click
  setFormation();
}

function setFormation() {
  // Generate skyline points
  let skylinePoints = generateSkyline();

  // Assign target positions to particles
  for (let i = 0; i < particles.length; i++) {
    let idx = i % skylinePoints.length;
    let targetData = skylinePoints[idx];
    particles[i].setTarget(targetData.x, targetData.y);
    particles[i].setColor(targetData.color);
  }
}

function generateSkyline() {
  let points = [];
  let numBuildings = floor(random(5, 20)); // Random number of buildings
  let buildingWidth = width / numBuildings;
  let maxBuildingHeight = height * random(0.3, 0.7);
  let groundLevel = height * 0.9; // Ground level position

  for (let i = 0; i < numBuildings; i++) {
    let x = i * buildingWidth;
    let buildingHeight = random(maxBuildingHeight * 0.5, maxBuildingHeight);

    // Create building shape points
    let buildingPoints = createBuilding(x, groundLevel, buildingWidth, buildingHeight);
    points = points.concat(buildingPoints);
  }

  // Add some random stars in the sky
  let numStars = floor(random(50, 150));
  for (let i = 0; i < numStars; i++) {
    let starX = random(width);
    let starY = random(height * 0.5);
    points.push({ x: starX, y: starY, color: color(255, 255, 255) });
  }

  return points;
}

function createBuilding(x, groundLevel, buildingWidth, buildingHeight) {
  let points = [];
  let buildingColor = color(random(50, 200), random(50, 200), random(50, 200));

  // Outline of the building
  let numPointsVertical = floor(buildingHeight / 5);
  for (let i = 0; i <= numPointsVertical; i++) {
    let y = groundLevel - (i * buildingHeight) / numPointsVertical;
    points.push({ x: x, y: y, color: buildingColor });
    points.push({ x: x + buildingWidth, y: y, color: buildingColor });
  }

  // Top of the building
  let numPointsHorizontal = floor(buildingWidth / 5);
  for (let i = 0; i <= numPointsHorizontal; i++) {
    let xi = x + (i * buildingWidth) / numPointsHorizontal;
    let y = groundLevel - buildingHeight;
    points.push({ x: xi, y: y, color: buildingColor });
  }

  // Optional: Add windows
  let numWindowsX = floor(buildingWidth / 20);
  let numWindowsY = floor(buildingHeight / 20);
  for (let ix = 1; ix < numWindowsX; ix++) {
    for (let iy = 1; iy < numWindowsY; iy++) {
      let windowX = x + (ix * buildingWidth) / numWindowsX;
      let windowY = groundLevel - (iy * buildingHeight) / numWindowsY;
      if (random() < 0.5) { // Randomly decide whether a window is lit
        points.push({ x: windowX, y: windowY, color: color(255, 215, 0) }); // Yellow light
      }
    }
  }

  return points;
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 10;
    this.maxForce = 1;
    this.color = color(255, 255, 255);
    this.size = random(1, 3);
  }

  update() {
    // Arrival behavior towards target
    let desired = p5.Vector.sub(this.target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);

    this.acc.add(steer);
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Fade color based on speed
    let speedMag = this.vel.mag();
    let alpha = map(speedMag, 0, this.maxSpeed, 50, 255);
    this.color.setAlpha(alpha);
  }

  display() {
    fill(this.color);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  setTarget(x, y) {
    this.target = createVector(x, y);
  }

  setColor(c) {
    this.color = c;
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  setFormation();
}
"
"2442968","Infinite Life Structures","mySketch","let particles = [];
let numParticles = 1000;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();

  // Initialize particles at random positions
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }

  // Initialize first fractal pattern
  setFormation();
}

function draw() {
  background(10, 10, 30, 50);

  // Update and display particles
  for (let p of particles) {
    p.update();
    p.display();
  }

  t += 0.01;
}

function mousePressed() {
  // Generate a new fractal pattern on mouse click
  setFormation();
}

function setFormation() {
  // Generate fractal pattern points
  let fractalPoints = generateFractalPattern();

  // Assign target positions to particles
  for (let i = 0; i < particles.length; i++) {
    let idx = i % fractalPoints.length;
    let targetPos = fractalPoints[idx];
    particles[i].setTarget(targetPos.x, targetPos.y);
    // Optionally set color based on depth or other properties
  }
}

function generateFractalPattern() {
  let points = [];
  let centerX = width / 2;
  let centerY = height / 2;
  let radius = random(100, min(width, height) / 3);
  let numBranches = floor(random(3, 8)); // Number of main branches for symmetry
  let maxDepth = floor(random(3, 6)); // Depth of recursion

  function branch(x, y, len, angle, depth) {
    if (depth > maxDepth || len < 2) {
      return;
    }

    let endX = x + len * cos(angle);
    let endY = y + len * sin(angle);

    // Store points along the branch
    let numPoints = floor(len / 5);
    for (let i = 0; i <= numPoints; i++) {
      let px = lerp(x, endX, i / numPoints);
      let py = lerp(y, endY, i / numPoints);
      points.push(createVector(px, py));
    }

    // Create two child branches at each branch end
    let angleOffset = random(PI / 6, PI / 3);
    let newLen = len * random(0.5, 0.8);
    branch(endX, endY, newLen, angle + angleOffset, depth + 1);
    branch(endX, endY, newLen, angle - angleOffset, depth + 1);
  }

  // Generate symmetrical branches
  for (let i = 0; i < numBranches; i++) {
    let angle = TWO_PI * i / numBranches;
    branch(centerX, centerY, radius, angle, 0);
  }

  return points;
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 10;
    this.maxForce = 1;
    this.color = color(255, 255, 255);
    this.size = random(1, 3);
  }

  update() {
    // Arrival behavior towards target
    let desired = p5.Vector.sub(this.target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);

    this.acc.add(steer);
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Fade color based on speed
    let speedMag = this.vel.mag();
    let alpha = map(speedMag, 0, this.maxSpeed, 50, 255);
    this.color.setAlpha(alpha);
  }

  display() {
    fill(this.color);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  setTarget(x, y) {
    this.target = createVector(x, y);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  setFormation();
}
"
"2442954","Trees of All Species","mySketch","let particles = [];
let numParticles = 3000;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();

  // Initialize particles at random positions
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }

  // Initialize first tree formation
  setFormation();
}

function draw() {
  background(10, 10, 30, 50);

  // Update and display particles
  for (let p of particles) {
    p.update();
    p.display();
  }

  t += 0.01;
}

function mousePressed() {
  // Generate a new tree on mouse click
  setFormation();
}

function setFormation() {
  // Generate tree points
  let treePoints = generateTree();

  // Assign target positions to particles
  for (let i = 0; i < particles.length; i++) {
    let idx = i % treePoints.length;
    let targetData = treePoints[idx];
    particles[i].setTarget(targetData.pos.x, targetData.pos.y);
    // Set color based on depth to simulate trunk, branches, and leaves
    particles[i].setDepth(targetData.depth);
  }
}

function generateTree() {
  // Starting position at the bottom center of the canvas
  let startPos = createVector(width / 2, height);
  let branchLength = random(100, 300);
  let angleRange = random(PI / 6, PI / 4);
  let maxDepth = floor(random(5, 8)); // Randomize max depth for infinite variations

  let points = [];

  function branch(pos, length, angle, depth) {
    if (depth > maxDepth || length < 2) {
      return;
    }

    let endPos = p5.Vector.add(pos, p5.Vector.fromAngle(angle, length));

    // Store points along the branch
    let numPoints = floor(length / 5);
    for (let i = 0; i <= numPoints; i++) {
      let point = p5.Vector.lerp(pos, endPos, i / numPoints);
      points.push({ pos: point, depth: depth });
    }

    // Randomly decide number of child branches (1 to 3)
    let numBranches = floor(random(1, 4));

    for (let i = 0; i < numBranches; i++) {
      let newLength = length * random(0.6, 0.8);
      let newAngle = angle + random(-angleRange, angleRange);
      branch(endPos, newLength, newAngle, depth + 1);
    }
  }

  branch(startPos, branchLength, -PI / 2, 0);

  return points;
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 10;
    this.maxForce = 1;
    this.color = color(255, 255, 255);
    this.size = random(1, 3);
    this.depth = 0;
  }

  update() {
    // Arrival behavior towards target
    let desired = p5.Vector.sub(this.target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);

    this.acc.add(steer);
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Fade color based on speed
    let speedMag = this.vel.mag();
    let alpha = map(speedMag, 0, this.maxSpeed, 50, 255);
    this.color.setAlpha(alpha);
  }

  display() {
    fill(this.color);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  setTarget(x, y) {
    this.target = createVector(x, y);
  }

  setDepth(depth) {
    this.depth = depth;
    // Set color based on depth (trunk, branches, leaves)
    if (depth < 2) {
      // Trunk
      this.color = color(139, 69, 19); // Brown
    } else if (depth < 4) {
      // Branches
      this.color = color(160, 82, 45); // Sienna
    } else {
      // Leaves
      this.color = color(random(34, 85), random(100, 255), random(34, 85)); // Greens
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  setFormation();
}
"
"2442939","Infinite Dynamic Formations","mySketch","let particles = [];
let numParticles = 1000;
let currentFormation;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();

  // Initialize particles at random positions
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }

  // Initialize first formation
  setFormation();
}

function draw() {
  background(10, 10, 30, 50);

  // Update and display particles
  for (let p of particles) {
    p.update();
    p.display();
  }

  t += 0.01;
}

function mousePressed() {
  // Change formation on mouse click
  setFormation();
}

function setFormation() {
  // Define formation functions that generate formations with random parameters
  let formations = [
    function SpiralFormation() {
      let numSpirals = random(1, 5);
      return function(i) {
        let angle = map(i, 0, numParticles, 0, TWO_PI * numSpirals);
        let radius = map(i, 0, numParticles, 0, min(width, height) / 3);
        return createVector(width / 2 + radius * cos(angle), height / 2 + radius * sin(angle));
      };
    },
    function FlowerFormation() {
      let petals = floor(random(3, 10));
      return function(i) {
        let angle = map(i, 0, numParticles, 0, TWO_PI * petals);
        let radius = sin(petals * angle) * min(width, height) / 4;
        return createVector(width / 2 + radius * cos(angle), height / 2 + radius * sin(angle));
      };
    },
    function LissajousFormation() {
      let a = random(1, 5);
      let b = random(1, 5);
      let delta = random(TWO_PI);
      let cycles = random(1, 5);
      return function(i) {
        let angle = map(i, 0, numParticles, 0, TWO_PI * cycles);
        let x = width / 2 + (width / 3) * sin(a * angle + delta);
        let y = height / 2 + (height / 3) * sin(b * angle);
        return createVector(x, y);
      };
    },
    function RandomBezierFormation() {
      let p0 = createVector(random(width), random(height));
      let p1 = createVector(random(width), random(height));
      let p2 = createVector(random(width), random(height));
      let p3 = createVector(random(width), random(height));
      return function(i) {
        let t = map(i, 0, numParticles, 0, 1);
        return cubicBezier(p0, p1, p2, p3, t);
      };
    },
    function RandomFunctionFormation() {
      let noiseScale = random(0.1, 1);
      let cycles = random(1, 5);
      return function(i) {
        let angle = map(i, 0, numParticles, 0, TWO_PI * cycles);
        let radius = map(noise(angle * noiseScale), 0, 1, 50, min(width, height)/2);
        let x = width / 2 + radius * cos(angle);
        let y = height / 2 + radius * sin(angle);
        return createVector(x, y);
      };
    },
    function HeartFormation() {
      let scale = random(8, 12);
      return function(i) {
        let angle = map(i, 0, numParticles, -PI, PI);
        let x = 16 * pow(sin(angle), 3);
        let y = 13 * cos(angle) - 5 * cos(2 * angle) - 2 * cos(3 * angle) - cos(4 * angle);
        return createVector(width / 2 + x * scale, height / 2 - y * scale);
      };
    },
    function CircleFormation() {
      let radius = random(50, min(width, height)/2 - 50);
      return function(i) {
        let angle = map(i, 0, numParticles, 0, TWO_PI);
        return createVector(width / 2 + radius * cos(angle), height / 2 + radius * sin(angle));
      };
    },
    function RandomPointsFormation() {
      let points = [];
      for (let i = 0; i < numParticles; i++) {
        points.push(createVector(random(width), random(height)));
      }
      return function(i) {
        return points[i];
      };
    },
    function LineFormation() {
      let x1 = random(width);
      let y1 = random(height);
      let x2 = random(width);
      let y2 = random(height);
      return function(i) {
        let t = map(i, 0, numParticles, 0, 1);
        let x = lerp(x1, x2, t);
        let y = lerp(y1, y2, t);
        return createVector(x, y);
      };
    },
    function GridFormation() {
      let cols = floor(random(5, 20));
      let rows = floor(random(5, 20));
      let cellWidth = width / cols;
      let cellHeight = height / rows;
      let points = [];
      for (let x = 0; x < cols; x++) {
        for (let y = 0; y < rows; y++) {
          points.push(createVector(x * cellWidth + cellWidth / 2, y * cellHeight + cellHeight / 2));
        }
      }
      while (points.length < numParticles) {
        points.push(points[floor(random(points.length))]);
      }
      return function(i) {
        return points[i % points.length];
      };
    }
  ];

  // Randomly select a formation
  let formationIndex = floor(random(formations.length));
  currentFormation = formations[formationIndex]();

  // Assign target positions to particles
  for (let i = 0; i < particles.length; i++) {
    let target = currentFormation(i);
    particles[i].setTarget(target.x, target.y);
  }
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 10;
    this.maxForce = 1;
    this.color = color(255, 255, 255);
    this.size = random(1, 3);
  }

  update() {
    // Arrival behavior towards target
    let desired = p5.Vector.sub(this.target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);

    this.acc.add(steer);
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Fade color based on speed
    let speedMag = this.vel.mag();
    let alpha = map(speedMag, 0, this.maxSpeed, 50, 255);
    this.color.setAlpha(alpha);
  }

  display() {
    fill(this.color);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  setTarget(x, y) {
    this.target = createVector(x, y);
  }
}

function cubicBezier(p0, p1, p2, p3, t) {
  let a = p0.copy().mult(pow(1 - t, 3));
  let b = p1.copy().mult(3 * t * pow(1 - t, 2));
  let c = p2.copy().mult(3 * pow(t, 2) * (1 - t));
  let d = p3.copy().mult(pow(t, 3));
  return a.add(b).add(c).add(d);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  setFormation();
}
"
"2441578","Dynamic Particle Formation","mySketch","let particles = [];
let numParticles = 1000;
let formationType = 0;
let formations = [];
let transition = false;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();

  // Initialize particles at random positions
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }

  // Define different mathematical formations
  formations = [
    (i) => { // Spiral
      let angle = map(i, 0, numParticles, 0, TWO_PI * 5);
      let radius = map(i, 0, numParticles, 0, min(width, height) / 3);
      return createVector(width / 2 + radius * cos(angle), height / 2 + radius * sin(angle));
    },
    (i) => { // Flower
      let angle = map(i, 0, numParticles, 0, TWO_PI * 8);
      let radius = sin(4 * angle) * min(width, height) / 4;
      return createVector(width / 2 + radius * cos(angle), height / 2 + radius * sin(angle));
    },
    (i) => { // Lissajous Curve
      let a = random(1, 5);
      let b = random(1, 5);
      let delta = random(TWO_PI);
      let angle = map(i, 0, numParticles, 0, TWO_PI * 5);
      let x = width / 2 + (width / 3) * sin(a * angle + delta);
      let y = height / 2 + (height / 3) * sin(b * angle);
      return createVector(x, y);
    },
    (i) => { // Circle
      let angle = map(i, 0, numParticles, 0, TWO_PI);
      let radius = min(width, height) / 3;
      return createVector(width / 2 + radius * cos(angle), height / 2 + radius * sin(angle));
    },
    (i) => { // Heart
      let angle = map(i, 0, numParticles, -PI, PI);
      let x = 16 * pow(sin(angle), 3);
      let y = 13 * cos(angle) - 5 * cos(2 * angle) - 2 * cos(3 * angle) - cos(4 * angle);
      return createVector(width / 2 + x * 10, height / 2 - y * 10);
    },
    (i) => { // Random Bezier Curve
      let p0 = createVector(random(width), random(height));
      let p1 = createVector(random(width), random(height));
      let p2 = createVector(random(width), random(height));
      let p3 = createVector(random(width), random(height));
      let t = map(i, 0, numParticles, 0, 1);
      let pos = cubicBezier(p0, p1, p2, p3, t);
      return pos;
    }
  ];

  // Initialize first formation
  setFormation();
}

function draw() {
  background(10, 10, 30, 50);

  // Update and display particles
  for (let p of particles) {
    p.update();
    p.display();
  }

  t += 0.01;
}

function mousePressed() {
  // Change formation on mouse click
  formationType = (formationType + 1) % formations.length;
  setFormation();
}

function setFormation() {
  // Assign target positions to particles based on the current formation
  for (let i = 0; i < particles.length; i++) {
    let target = formations[formationType](i);
    particles[i].setTarget(target.x, target.y);
  }
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 10;
    this.maxForce = 1;
    this.color = color(255, 255, 255);
    this.size = random(1, 3);
  }

  update() {
    // Arrival behavior towards target
    let desired = p5.Vector.sub(this.target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);

    this.acc.add(steer);
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Fade color based on speed
    let speedMag = this.vel.mag();
    let alpha = map(speedMag, 0, this.maxSpeed, 50, 255);
    this.color.setAlpha(alpha);
  }

  display() {
    fill(this.color);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  setTarget(x, y) {
    this.target = createVector(x, y);
  }
}

function cubicBezier(p0, p1, p2, p3, t) {
  let a = p0.copy().mult(pow(1 - t, 3));
  let b = p1.copy().mult(3 * t * pow(1 - t, 2));
  let c = p2.copy().mult(3 * pow(t, 2) * (1 - t));
  let d = p3.copy().mult(pow(t, 3));
  return a.add(b).add(c).add(d);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  setFormation();
}
"
"2441528","Universe creation","mySketch","let colors = [];
let maxLayers = 15;
let time = 0;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  noCursor();
  strokeWeight(1);
  angleMode(DEGREES);

  // Generate a vibrant color palette
  for (let i = 0; i < 360; i += 20) {
    colors.push(color(`hsb(${i}, 100%, 100%)`));
  }
}

function draw() {
  background(0);
  orbitControl(); // Enable mouse control for rotation
  rotateX(time * 0.2);
  rotateY(time * 0.1);

  for (let i = 0; i < maxLayers; i++) {
    push();
    rotateY(frameCount * 0.5 + i * 10);
    rotateX(frameCount * 0.3 + i * 15);
    stroke(colors[i % colors.length]);

    // Draw the complex 3D shape
    beginShape(POINTS);
    for (let theta = 0; theta < 360; theta += 5) {
      for (let phi = 0; phi < 180; phi += 5) {
        let r = 200 * sin((mouseX * 0.01 + i) * theta) * cos((mouseY * 0.01 + i) * phi);
        let x = r * sin(phi) * cos(theta);
        let y = r * sin(phi) * sin(theta);
        let z = r * cos(phi);
        vertex(x, y, z);
      }
    }
    endShape();
    pop();
  }
  time += 0.02;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2439812","da Vinci's inspired sketches","mySketch","let sketches = [];
let inkColor;
let parchmentColor;

function setup() {
  createCanvas(800, 800);
  noLoop();
  
  // Set parchment background
  parchmentColor = color(245, 222, 179); // A light tan color resembling parchment
  background(parchmentColor);
  
  // Set ink color to a sepia tone
  inkColor = color(101, 67, 33); // A dark brown color resembling sepia ink
  
  // Generate random sketches
  for (let i = 0; i < 10; i++) {
    sketches.push(generateRandomSketch());
  }
}

function draw() {
  background(parchmentColor);
  
  // Draw the sketches
  for (let sketch of sketches) {
    drawSketch(sketch);
  }
}

function generateRandomSketch() {
  let sketchType = random(['spiral', 'mechanical', 'anatomical', 'landscape', 'geometry']);
  let posX = random(width * 0.1, width * 0.9);
  let posY = random(height * 0.1, height * 0.9);
  let sketchSize = random(100, 300);
  let rotation = random(-PI / 8, PI / 8); // Slight rotation to simulate hand-drawn feel
  
  return {
    type: sketchType,
    x: posX,
    y: posY,
    size: sketchSize,
    rotation: rotation
  };
}

function drawSketch(sketch) {
  push();
  translate(sketch.x, sketch.y);
  rotate(sketch.rotation);
  stroke(inkColor);
  strokeWeight(1);
  noFill();
  
  switch (sketch.type) {
    case 'spiral':
      drawSpiral(sketch.size);
      break;
    case 'mechanical':
      drawMechanical(sketch.size);
      break;
    case 'anatomical':
      drawAnatomical(sketch.size);
      break;
    case 'landscape':
      drawLandscape(sketch.size);
      break;
    case 'geometry':
      drawGeometricShape(sketch.size);
      break;
  }
  
  pop();
}

function drawSpiral(size) {
  beginShape();
  for (let a = 0; a < TWO_PI * 5; a += 0.1) {
    let r = size * 0.1 * a;
    let x = r * cos(a);
    let y = r * sin(a);
    vertex(x, y);
  }
  endShape();
}

function drawMechanical(size) {
  let numCogs = floor(random(3, 6));
  for (let i = 0; i < numCogs; i++) {
    let cogSize = size * random(0.2, 0.4);
    let angle = random(TWO_PI);
    let x = cos(angle) * size * 0.5;
    let y = sin(angle) * size * 0.5;
    drawCog(x, y, cogSize);
  }
}

function drawCog(x, y, size) {
  push();
  translate(x, y);
  let numTeeth = floor(random(8, 16));
  beginShape();
  for (let i = 0; i < TWO_PI; i += TWO_PI / numTeeth) {
    let outerX = cos(i) * size;
    let outerY = sin(i) * size;
    vertex(outerX, outerY);
    let innerX = cos(i + (TWO_PI / numTeeth) / 2) * size * 0.8;
    let innerY = sin(i + (TWO_PI / numTeeth) / 2) * size * 0.8;
    vertex(innerX, innerY);
  }
  endShape(CLOSE);
  
  // Draw center circle
  ellipse(0, 0, size * 0.5, size * 0.5);
  pop();
}

function drawAnatomical(size) {
  // Draw a simplified anatomical heart
  beginShape();
  curveVertex(-size * 0.2, -size * 0.3);
  curveVertex(-size * 0.2, -size * 0.3);
  curveVertex(-size * 0.5, -size * 0.1);
  curveVertex(-size * 0.3, size * 0.2);
  curveVertex(0, size * 0.5);
  curveVertex(size * 0.3, size * 0.2);
  curveVertex(size * 0.5, -size * 0.1);
  curveVertex(size * 0.2, -size * 0.3);
  curveVertex(size * 0.2, -size * 0.3);
  endShape();
  
  // Add arteries
  strokeWeight(0.5);
  line(-size * 0.1, -size * 0.3, -size * 0.15, -size * 0.5);
  line(size * 0.1, -size * 0.3, size * 0.15, -size * 0.5);
}

function drawLandscape(size) {
  // Draw simple rolling hills
  strokeWeight(1);
  for (let i = -size / 2; i < size / 2; i += size / 10) {
    let amplitude = random(size * 0.05, size * 0.1);
    beginShape();
    for (let x = -size / 2; x <= size / 2; x += 5) {
      let y = sin((x + i) * 0.05) * amplitude + i * 0.5;
      vertex(x, y);
    }
    endShape();
  }
  
  // Draw a simple tree
  strokeWeight(1);
  line(0, 0, 0, -size * 0.2);
  ellipse(0, -size * 0.3, size * 0.2, size * 0.3);
}

function drawGeometricShape(size) {
  // Draw a dodecahedron (12-sided polygon)
  let sides = 12;
  beginShape();
  for (let i = 0; i < TWO_PI; i += TWO_PI / sides) {
    let x = cos(i) * size * 0.5;
    let y = sin(i) * size * 0.5;
    vertex(x, y);
  }
  endShape(CLOSE);
  
  // Add internal lines
  strokeWeight(0.5);
  for (let i = 0; i < TWO_PI; i += TWO_PI / sides) {
    let x1 = cos(i) * size * 0.5;
    let y1 = sin(i) * size * 0.5;
    for (let j = i + TWO_PI / sides; j < TWO_PI; j += TWO_PI / sides) {
      let x2 = cos(j) * size * 0.5;
      let y2 = sin(j) * size * 0.5;
      line(x1, y1, x2, y2);
    }
  }
}

function mousePressed() {
  let newSketch = generateRandomSketch();
  newSketch.x = mouseX;
  newSketch.y = mouseY;
  sketches.push(newSketch);
  redraw();
}

function keyPressed() {
  if (key === 'C' || key === 'c') {
    sketches = [];
    redraw();
  }
}
"
"2439811","Miró-inspired art","mySketch","let shapes = [];
let colors = [];

function setup() {
  createCanvas(800, 800);
  background(255);
  noLoop();
  noStroke();
  
  // Define a palette of bold colors typical in Miró's work
  colors = [
    color(0, 0, 0),        // Black
    color(255, 0, 0),      // Red
    color(0, 0, 255),      // Blue
    color(255, 255, 0),    // Yellow
    color(0, 255, 0),      // Green
    color(255, 255, 255)   // White
  ];
  
  // Generate random shapes
  for (let i = 0; i < 50; i++) {
    shapes.push(generateRandomShape());
  }
}

function draw() {
  background(255);

  // Draw the shapes
  for (let shape of shapes) {
    drawShape(shape);
  }
}

function generateRandomShape() {
  let shapeType = random(['circle', 'line', 'rectangle', 'star', 'abstract']);
  let posX = random(width);
  let posY = random(height);
  let shapeSize = random(20, 150);
  let rotation = random(TWO_PI);
  let col = random(colors);
  
  return {
    type: shapeType,
    x: posX,
    y: posY,
    size: shapeSize,
    rotation: rotation,
    color: col
  };
}

function drawShape(shape) {
  push();
  translate(shape.x, shape.y);
  rotate(shape.rotation);
  fill(shape.color);
  stroke(0);
  strokeWeight(2);

  switch (shape.type) {
    case 'circle':
      ellipse(0, 0, shape.size, shape.size);
      break;
    case 'rectangle':
      rectMode(CENTER);
      rect(0, 0, shape.size, shape.size);
      break;
    case 'line':
      strokeWeight(4);
      line(-shape.size / 2, 0, shape.size / 2, 0);
      break;
    case 'star':
      drawStar(0, 0, shape.size / 2, shape.size, 5);
      break;
    case 'abstract':
      drawAbstractShape(shape.size);
      break;
  }

  pop();
}

function drawStar(x, y, radius1, radius2, npoints) {
  let angle = TWO_PI / npoints;
  let halfAngle = angle / 2.0;
  beginShape();
  for (let a = 0; a < TWO_PI; a += angle) {
    let sx = x + cos(a) * radius2;
    let sy = y + sin(a) * radius2;
    vertex(sx, sy);
    sx = x + cos(a + halfAngle) * radius1;
    sy = y + sin(a + halfAngle) * radius1;
    vertex(sx, sy);
  }
  endShape(CLOSE);
}

function drawAbstractShape(shapeSize) {
  beginShape();
  vertex(-shapeSize / 2, -shapeSize / 2);
  bezierVertex(-shapeSize / 4, -shapeSize, shapeSize / 4, -shapeSize, shapeSize / 2, -shapeSize / 2);
  bezierVertex(shapeSize, -shapeSize / 4, shapeSize, shapeSize / 4, shapeSize / 2, shapeSize / 2);
  bezierVertex(shapeSize / 4, shapeSize, -shapeSize / 4, shapeSize, -shapeSize / 2, shapeSize / 2);
  bezierVertex(-shapeSize, shapeSize / 4, -shapeSize, -shapeSize / 4, -shapeSize / 2, -shapeSize / 2);
  endShape(CLOSE);
}

function mousePressed() {
  let newShape = generateRandomShape();
  newShape.x = mouseX;
  newShape.y = mouseY;
  shapes.push(newShape);
  redraw();
}

function keyPressed() {
  if (key === 'C' || key === 'c') {
    shapes = [];
    redraw();
  }
}
"
"2439808","Pollock-style art","mySketch","let drips = [];
let splatterFunctions = [];

function setup() {
  createCanvas(800, 800);
  background(255);
  colorMode(HSB, 360, 100, 100, 100);
  splatterFunctions = [drawSplatter, drawSpray, drawBlob, drawDrip, drawStroke];
}

function draw() {
  // Generate random splatters over time
  if (frameCount % 10 == 0) {
    let x = random(width);
    let y = random(height);
    let size = random(20, 100);
    let splatterFunction = random(splatterFunctions);
    splatterFunction(x, y, size);
  }

  // Animate drips
  for (let i = drips.length - 1; i >= 0; i--) {
    let drip = drips[i];
    stroke(drip.hue, drip.saturation, drip.brightness, drip.alpha);
    strokeWeight(drip.weight);
    line(drip.x, drip.currentY - 1, drip.xEnd, drip.currentY);
    drip.currentY += 2;
    if (drip.currentY >= drip.yEnd) {
      drips.splice(i, 1);
    }
  }
}

function drawSplatter(x, y, size) {
  let points = floor(random(50, 150));
  for (let i = 0; i < points; i++) {
    let angle = random(TWO_PI);
    let radius = random(size * 0.2, size);
    let xOffset = cos(angle) * radius;
    let yOffset = sin(angle) * radius;
    let hue = random(360);
    let saturation = random(50, 100);
    let brightness = random(50, 100);
    let alpha = random(50, 100);
    noStroke();
    fill(hue, saturation, brightness, alpha);
    let ellipseSize = random(2, 10);
    ellipse(x + xOffset, y + yOffset, ellipseSize, ellipseSize);
  }
}

function drawSpray(x, y, size) {
  let points = floor(random(100, 300));
  for (let i = 0; i < points; i++) {
    let angle = random(TWO_PI);
    let radius = abs(randomGaussian(0, size / 2));
    let xOffset = cos(angle) * radius;
    let yOffset = sin(angle) * radius;
    let hue = random(360);
    let saturation = random(50, 100);
    let brightness = random(50, 100);
    let alpha = random(20, 80);
    noStroke();
    fill(hue, saturation, brightness, alpha);
    let ellipseSize = random(1, 5);
    ellipse(x + xOffset, y + yOffset, ellipseSize, ellipseSize);
  }
}

function drawBlob(x, y, size) {
  let hue = random(360);
  let saturation = random(50, 100);
  let brightness = random(50, 100);
  let alpha = random(80, 100);
  noStroke();
  fill(hue, saturation, brightness, alpha);
  ellipse(x, y, size * random(0.8, 1.2), size * random(0.8, 1.2));
}

function drawDrip(x, y) {
  let dripLength = random(20, 100);
  let hue = random(360);
  let saturation = random(50, 100);
  let brightness = random(50, 100);
  let alpha = random(80, 100);
  let weight = random(2, 5);
  let xEnd = x + random(-10, 10);
  drips.push({
    x: x,
    y: y,
    xEnd: xEnd,
    yEnd: y + dripLength,
    currentY: y,
    hue: hue,
    saturation: saturation,
    brightness: brightness,
    alpha: alpha,
    weight: weight
  });
}

function drawStroke(x, y, size) {
  let hue = random(360);
  let saturation = random(50, 100);
  let brightness = random(50, 100);
  let alpha = random(80, 100);
  stroke(hue, saturation, brightness, alpha);
  strokeWeight(size * random(0.1, 0.3));
  noFill();
  let angle = random(TWO_PI);
  let length = size * random(0.5, 1.5);
  let xEnd = x + cos(angle) * length;
  let yEnd = y + sin(angle) * length;
  line(x, y, xEnd, yEnd);
}

function mousePressed() {
  let size = random(20, 100);
  let splatterFunction = random(splatterFunctions);
  splatterFunction(mouseX, mouseY, size);
}

function mouseDragged() {
  let size = random(20, 100);
  let splatterFunction = random(splatterFunctions);
  splatterFunction(mouseX, mouseY, size);
}

function keyPressed() {
  if (key === 'c' || key === 'C') {
    background(255);
  }
}
"
"2439806","Pollock Splatter Art","mySketch","let colors = ['#1b263b', '#e63946', '#457b9d', '#f4a261', '#2a9d8f', '#264653'];
let maxSplatterSize = 50;
let splatterIntensity = 100;

function setup() {
  createCanvas(800, 800);
  background(255);
  noLoop();
}

function drawSplatter(x, y, size) {
  for (let i = 0; i < splatterIntensity; i++) {
    let angle = random(TWO_PI);
    let radius = random(size * 0.2, size);
    let xOffset = cos(angle) * radius;
    let yOffset = sin(angle) * radius;
    
    noStroke();
    fill(random(colors) + hex(floor(random(100, 255)), 2));
    ellipse(x + xOffset, y + yOffset, random(2, 10));
  }
}

function drawDrip(x, y) {
  let dripLength = random(20, 60);
  strokeWeight(random(2, 5));
  stroke(random(colors) + hex(floor(random(100, 255)), 2));
  
  let xEnd = x + random(-10, 10);
  let yEnd = y + dripLength;
  line(x, y, xEnd, yEnd);
}

function mousePressed() {
  let size = random(20, maxSplatterSize);
  drawSplatter(mouseX, mouseY, size);

  // Add drips to simulate paint flowing
  for (let i = 0; i < random(1, 5); i++) {
    drawDrip(mouseX + random(-size / 2, size / 2), mouseY + random(-size / 2, size / 2));
  }

  // Add finer splatters for texture
  for (let i = 0; i < random(10, 20); i++) {
    let xOffset = random(-size, size);
    let yOffset = random(-size, size);
    noStroke();
    fill(random(colors) + hex(floor(random(100, 255)), 2));
    ellipse(mouseX + xOffset, mouseY + yOffset, random(1, 4));
  }
}
"
"2439805","Interactive Miro-Inspired Canvas","mySketch","let colors = ['#E63946', '#F1FAEE', '#A8DADC', '#457B9D', '#F4A261', '#E76F51'];
let clicks = 0;

function setup() {
  createCanvas(800, 800);
  background(255);
  noLoop();
  initialShapes();
}

function initialShapes() {
  for (let i = 0; i < 10; i++) {
    let x = random(width);
    let y = random(height);
    drawMiroShape(x, y, random(60, 150));
  }
}

function drawMiroShape(x, y, size) {
  // Draw a base ellipse with a bold stroke
  fill(random(colors));
  stroke(0);
  strokeWeight(3);
  ellipse(x, y, size, size * 0.7);

  // Add a smaller inner circle
  fill(random(colors));
  ellipse(x, y, size * 0.3);

  // Draw a random line extending from the shape
  let angle = random(TWO_PI);
  let length = random(50, 120);
  let x2 = x + cos(angle) * length;
  let y2 = y + sin(angle) * length;
  strokeWeight(2);
  line(x, y, x2, y2);

  // Add small dots and irregular lines for added texture
  noStroke();
  fill(random(colors));
  for (let j = 0; j < random(5, 10); j++) {
    ellipse(x + random(-size, size), y + random(-size, size), random(5, 10));
  }
}

function mousePressed() {
  clicks++;
  if (clicks < 8) {
    drawMiroShape(mouseX, mouseY, random(80, 160));
  } else {
    // Draw smaller, finer details in later clicks
    drawFineDetail(mouseX, mouseY);
  }
}

function drawFineDetail(x, y) {
  fill(random(colors));
  noStroke();
  for (let i = 0; i < random(3, 6); i++) {
    ellipse(x + random(-20, 20), y + random(-20, 20), random(5, 15));
  }

  stroke(0);
  strokeWeight(1);
  for (let i = 0; i < random(2, 4); i++) {
    let angle = random(TWO_PI);
    let length = random(20, 50);
    let x2 = x + cos(angle) * length;
    let y2 = y + sin(angle) * length;
    line(x, y, x2, y2);
  }
}
"
"2439804","Interactive Mondrian Draw","mySketch","let colors = ['#E63946', '#F1FAEE', '#A8DADC', '#457B9D', '#1D3557'];
let largeGrid, smallGrid;
let clicks = 0;

function setup() {
  createCanvas(600, 600);
  largeGrid = 120; // Start with large grid
  smallGrid = 30;  // Switch to fine-tune grid later
  noLoop();
  drawInitialGrid();
}

function drawInitialGrid() {
  background(255);
  for (let x = 0; x < width; x += largeGrid) {
    for (let y = 0; y < height; y += largeGrid) {
      strokeWeight(6);
      stroke(0);
      fill(random(colors));
      rect(x, y, largeGrid, largeGrid);
    }
  }
}

function mousePressed() {
  clicks++;
  let grid = clicks > 4 ? smallGrid : largeGrid;  // Switch to smaller grid after a few clicks
  let x = floor(mouseX / grid) * grid;
  let y = floor(mouseY / grid) * grid;
  let w = grid * floor(random(1, 3));
  let h = grid * floor(random(1, 3));

  fill(random(colors));
  strokeWeight(clicks > 4 ? 3 : 6);
  stroke(0);
  rect(x, y, w, h);

  if (clicks > 10) {
    noLoop(); // Stop if sufficiently detailed
  }
}
"
"2439802","Parchment Geometric Harmony","mySketch","// ""Epic Geometric Harmony""

let angleX = 0;
let angleY = 0;
let angleZ = 0;
let zoom = 1;
let rotationSpeedX = 0.01;
let rotationSpeedY = 0.008;
let rotationSpeedZ = 0.005;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  background(245, 245, 220); // Parchment-like background
  stroke(0);
  noFill();
  smooth();
}

function draw() {
  background(245, 245, 220);
  
  // Apply zoom based on mouse wheel
  scale(zoom);
  
  // Apply rotations
  rotateX(angleX);
  rotateY(angleY);
  rotateZ(angleZ);
  
  // Increment angles for continuous rotation
  angleX += rotationSpeedX;
  angleY += rotationSpeedY;
  angleZ += rotationSpeedZ;
  
  // Draw multiple layers of geometric patterns
  drawMetatronCube(150);
  drawFlowerOfLife(150);
  drawInnerPatterns(150);
}

// Function to draw Metatron's Cube
function drawMetatronCube(radius) {
  push();
  strokeWeight(1);
  
  // Draw the outer circle
  ellipse(0, 0, radius * 2, radius * 2);
  
  // Generate 6 points for the hexagon
  let points = [];
  for (let i = 0; i < 6; i++) {
    let angle = TWO_PI / 6 * i - HALF_PI;
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    points.push(createVector(x, y));
    // Draw lines from center to each vertex
    line(0, 0, x, y);
  }
  
  // Draw lines connecting the hexagon vertices to form the cube
  for (let i = 0; i < points.length; i++) {
    for (let j = i + 1; j < points.length; j++) {
      let distance = p5.Vector.dist(points[i], points[j]);
      if (abs(distance - radius) < 1) { // Connect only adjacent vertices
        line(points[i].x, points[i].y, points[j].x, points[j].y);
      }
    }
  }
  
  pop();
}

// Function to draw Flower of Life pattern
function drawFlowerOfLife(radius) {
  push();
  strokeWeight(0.5);
  
  // Draw multiple overlapping circles
  for (let i = 0; i < 6; i++) {
    let angle = TWO_PI / 6 * i;
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    ellipse(x, y, radius * 1.732, radius * 1.732); // 1.732 ≈ sqrt(3)
  }
  
  pop();
}

// Function to draw additional inner patterns for complexity
function drawInnerPatterns(radius) {
  push();
  strokeWeight(0.3);
  
  // Draw smaller concentric circles
  for (let r = radius * 0.2; r < radius; r += radius * 0.2) {
    ellipse(0, 0, r * 2, r * 2);
  }
  
  // Draw diagonals
  line(-radius, -radius, radius, radius);
  line(-radius, radius, radius, -radius);
  
  pop();
}

// Handle window resizing
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

// Handle mouse wheel for zooming
function mouseWheel(event) {
  zoom += event.delta * -0.001;
  zoom = constrain(zoom, 0.5, 3);
}

// Handle mouse drag for rotation control
function mouseDragged() {
  let deltaX = movedX;
  let deltaY = movedY;
  angleY += deltaX * 0.005;
  angleX += deltaY * 0.005;
}
"
"2439797","4D Tesseract -> 2D plane","mySketch","// ""Epic Rotating Tesseract Projection"" (Corrected and Enhanced)

let angle = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(245, 245, 220); // Parchment-like background
  stroke(0);
  noFill();
}

function draw() {
  background(245, 245, 220);
  translate(width / 2, height / 2);

  let cubeSize = min(width, height) * 0.3; // Increased size for better visibility
  let points = [];

  // Define the 16 vertices of a tesseract in 4D space
  for (let i = 0; i < 16; i++) {
    let x = (i & 1) ? cubeSize : -cubeSize;
    let y = (i & 2) ? cubeSize : -cubeSize;
    let z = (i & 4) ? cubeSize : -cubeSize;
    let w = (i & 8) ? cubeSize : -cubeSize;
    points.push([x, y, z, w]);
  }

  let rotatedPoints = points.map(p => rotate4D(p, angle));
  let projectedPoints = rotatedPoints.map(p => project4Dto2D(p));

  // Draw edges between connected vertices
  strokeWeight(1);
  for (let i = 0; i < 16; i++) {
    for (let j = i + 1; j < 16; j++) {
      if (isConnected(i, j)) {
        let a = projectedPoints[i];
        let b = projectedPoints[j];
        line(a.x, a.y, b.x, b.y);
      }
    }
  }

  angle += 0.01; // Rotation speed
}

function rotate4D(p, angle) {
  let [x, y, z, w] = p;

  // Rotation in the XW plane
  let sinA = sin(angle * 0.5);
  let cosA = cos(angle * 0.5);
  let x1 = x * cosA - w * sinA;
  let w1 = x * sinA + w * cosA;

  // Rotation in the YZ plane
  let sinB = sin(angle * 0.3);
  let cosB = cos(angle * 0.3);
  let y1 = y * cosB - z * sinB;
  let z1 = y * sinB + z * cosB;

  return [x1, y1, z1, w1];
}

function project4Dto2D(p) {
  let [x, y, z, w] = p;

  // Perspective projection from 4D to 3D
  let distance4D = 600; // Distance from the viewer in 4D space
  let wFactor = distance4D / (distance4D - w);
  let x3D = x * wFactor;
  let y3D = y * wFactor;
  let z3D = z * wFactor;

  // Perspective projection from 3D to 2D
  let distance3D = 600; // Distance from the viewer in 3D space
  let zFactor = distance3D / (distance3D - z3D);
  let x2D = x3D * zFactor;
  let y2D = y3D * zFactor;

  return createVector(x2D, y2D);
}

function isConnected(i, j) {
  let b = i ^ j;
  // Two vertices are connected if their indices differ by exactly one bit
  return (b & (b - 1)) === 0;
}

// Optional: Make the canvas responsive
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2439792","Double Pendulum with Chaotic Motion","mySketch","let r1 = 150;
let r2 = 150;
let m1 = 10;
let m2 = 10;
let a1, a2;
let a1_v = 0;
let a2_v = 0;
let g = 1;
let px2 = -1;
let py2 = -1;
let dragging = false;

function setup() {
  createCanvas(800, 600);
  a1 = Math.PI / 2;
  a2 = Math.PI / 2;
  background(255);
}

function draw() {
  background(255, 5); // light fade to create motion blur effect

  if (!dragging) {
    // Calculate accelerations
    let num1 = -g * (2 * m1 + m2) * sin(a1);
    let num2 = -m2 * g * sin(a1 - 2 * a2);
    let num3 = -2 * sin(a1 - a2) * m2;
    let num4 = a2_v * a2_v * r2 + a1_v * a1_v * r1 * cos(a1 - a2);
    let den = r1 * (2 * m1 + m2 - m2 * cos(2 * a1 - 2 * a2));
    let a1_a = (num1 + num2 + num3 * num4) / den;

    num1 = 2 * sin(a1 - a2);
    num2 = (a1_v * a1_v * r1 * (m1 + m2));
    num3 = g * (m1 + m2) * cos(a1);
    num4 = a2_v * a2_v * r2 * m2 * cos(a1 - a2);
    den = r2 * (2 * m1 + m2 - m2 * cos(2 * a1 - 2 * a2));
    let a2_a = (num1 * (num2 + num3 + num4)) / den;

    // Update velocities and angles
    a1_v += a1_a;
    a2_v += a2_a;
    a1 += a1_v;
    a2 += a2_v;

    // Damping
    a1_v *= 0.99;
    a2_v *= 0.99;
  }

  // Calculate positions
  let x1 = r1 * sin(a1) + width / 2;
  let y1 = r1 * cos(a1) + height / 2;
  let x2 = x1 + r2 * sin(a2);
  let y2 = y1 + r2 * cos(a2);

  // Draw arms
  stroke(0);
  strokeWeight(1);
  line(width / 2, height / 2, x1, y1);
  line(x1, y1, x2, y2);

  // Draw bobs
  fill(0);
  ellipse(x1, y1, m1, m1);
  ellipse(x2, y2, m2, m2);

  // Draw the path of the second bob
  stroke(0, 150);
  strokeWeight(0.5);
  if (px2 != -1 && py2 != -1) {
    line(px2, py2, x2, y2);
  }

  px2 = x2;
  py2 = y2;
}

function mousePressed() {
  let d1 = dist(mouseX, mouseY, width / 2 + r1 * sin(a1), height / 2 + r1 * cos(a1));
  let d2 = dist(mouseX, mouseY, width / 2 + r1 * sin(a1) + r2 * sin(a2), height / 2 + r1 * cos(a1) + r2 * cos(a2));
  if (d1 < m1 || d2 < m2) {
    dragging = true;
    a1_v = 0;
    a2_v = 0;
  }
}

function mouseDragged() {
  if (dragging) {
    a1 = atan2(mouseY - height / 2, mouseX - width / 2);
    a2 = atan2(mouseY - (height / 2 + r1 * cos(a1)), mouseX - (width / 2 + r1 * sin(a1))) - a1;
  }
}

function mouseReleased() {
  dragging = false;
}
"
"2439790","Langton's Ant Simulation","mySketch","let cols, rows;
let grid;
let ant;

function setup() {
  createCanvas(600, 600);
  cols = width / 10;
  rows = height / 10;
  grid = Array.from({ length: cols }, () => Array(rows).fill(0));
  ant = new Ant(floor(cols / 2), floor(rows / 2));
  frameRate(30);
}

function draw() {
  background(255);
  drawGrid();
  ant.update();
}

function drawGrid() {
  for (let x = 0; x < cols; x++) {
    for (let y = 0; y < rows; y++) {
      fill(grid[x][y] == 1 ? 0 : 255);
      noStroke();
      rect(x * 10, y * 10, 10, 10);
    }
  }
}

class Ant {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.dir = 0; // 0=up, 1=right, 2=down, 3=left
  }

  update() {
    if (grid[this.x][this.y] == 0) {
      this.turnRight();
      grid[this.x][this.y] = 1;
    } else {
      this.turnLeft();
      grid[this.x][this.y] = 0;
    }
    this.move();
  }

  turnRight() {
    this.dir = (this.dir + 1) % 4;
  }

  turnLeft() {
    this.dir = (this.dir + 3) % 4;
  }

  move() {
    if (this.dir == 0) this.y = (this.y - 1 + rows) % rows;
    if (this.dir == 1) this.x = (this.x + 1) % cols;
    if (this.dir == 2) this.y = (this.y + 1) % rows;
    if (this.dir == 3) this.x = (this.x - 1 + cols) % cols;
  }
}
"
"2439788","Diffusion-Limited Aggregation Simulation","mySketch","let particles = [];
let center;

function setup() {
  createCanvas(600, 600);
  center = createVector(width / 2, height / 2);
  particles.push(new Particle(center.x, center.y, true));
  for (let i = 0; i < 100; i++) {
    particles.push(new Particle(random(width), random(height)));
  }
  background(0);
}

function draw() {
  background(0, 10); // slow fade for effect
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].move();
    particles[i].display();
    if (particles[i].stuck) continue;

    for (let j = 0; j < particles.length; j++) {
      if (particles[i] !== particles[j] && particles[j].stuck && particles[i].intersects(particles[j])) {
        particles[i].stuck = true;
        particles.push(new Particle(random(width), random(height)));
        break;
      }
    }
  }
}

class Particle {
  constructor(x, y, stuck = false) {
    this.pos = createVector(x, y);
    this.stuck = stuck;
    this.r = 4;
  }

  move() {
    if (!this.stuck) {
      this.pos.x += random(-2, 2);
      this.pos.y += random(-2, 2);
      this.pos.x = constrain(this.pos.x, 0, width);
      this.pos.y = constrain(this.pos.y, 0, height);
    }
  }

  intersects(other) {
    let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
    return d < this.r * 2;
  }

  display() {
    noStroke();
    fill(255);
    ellipse(this.pos.x, this.pos.y, this.r * 2, this.r * 2);
  }
}
"
"2439209","Infinite Maze","mySketch","let cols, rows;
let w = 20; // Cell size
let grid = [];
let walls = [];
let visited = [];
let current;
let mazeCompleted = false;
let path = [];
let orbPosition = 0;
let particles = [];
let solving = false;
let solvingCompleted = false;
let dfsStack = [];
let dfsStepsPerFrame = 20; // Number of DFS steps per frame for faster solving

function setup() {
  createCanvas(1200, 400);
  cols = floor(width / w);
  rows = floor(height / w);
  frameRate(60); // Increase frame rate for smoother and faster animations

  initializeMaze();
}

function draw() {
  background(30);

  // Draw all cells
  for (let cell of grid) {
    cell.show();
  }

  // Maze generation using Prim's algorithm
  if (!mazeCompleted) {
    let wallsToProcess = 10; // Number of walls to process per frame for faster generation

    for (let n = 0; n < wallsToProcess; n++) {
      if (walls.length > 0) {
        let randomWall = random(walls);
        let { cellA, cellB } = randomWall;

        if (cellB && !cellB.visited) {
          // Remove wall between cellA and cellB
          cellA.removeWalls(cellB);
          cellB.visited = true;
          visited.push(cellB);
          addWalls(cellB);
        }

        // Remove the wall from the list
        walls.splice(walls.indexOf(randomWall), 1);
      } else if (!mazeCompleted) {
        // Maze generation completed
        mazeCompleted = true;

        // Reset visited status for maze solving
        for (let cell of grid) {
          cell.visited = false;
        }

        // Initialize DFS solving
        let startCell = grid[0];
        let endCell = grid[grid.length - 1];
        dfsStack.push(startCell);
        startCell.visited = true;
        solving = true;
      }
    }
  }

  // Maze solving using Iterative DFS
  if (solving && dfsStack.length > 0) {
    for (let n = 0; n < dfsStepsPerFrame; n++) {
      if (dfsStack.length === 0) break;

      let currentCell = dfsStack.pop();

      if (currentCell === grid[grid.length - 1]) {
        // Path found
        solvingCompleted = true;
        solving = false;
        constructPath(currentCell);
        break;
      }

      let neighbors = currentCell.getUnblockedNeighbors();

      for (let neighbor of neighbors) {
        if (!neighbor.visited) {
          neighbor.visited = true;
          neighbor.previous = currentCell;
          dfsStack.push(neighbor);
        }
      }
    }
  }

  // Draw the traversal animation
  if (solvingCompleted && path.length > 0) {
    animateTraversal();
  }

  // Update and draw particles
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].show();
    if (particles[i].finished()) {
      particles.splice(i, 1);
    }
  }
}

// Initialize or reset the maze
function initializeMaze() {
  // Clear all arrays and variables
  grid = [];
  walls = [];
  visited = [];
  dfsStack = [];
  path = [];
  particles = [];
  mazeCompleted = false;
  solving = false;
  solvingCompleted = false;
  orbPosition = 0;

  // Initialize grid cells
  for (let j = 0; j < rows; j++) {
    for (let i = 0; i < cols; i++) {
      let cell = new Cell(i, j);
      grid.push(cell);
    }
  }

  // Start with a random cell
  current = grid[floor(random(0, grid.length))];
  visited.push(current);
  current.visited = true;
  addWalls(current);
}

// Add walls of a cell to the wall list
function addWalls(cell) {
  let neighbors = cell.getNeighbors();
  for (let neighbor of neighbors) {
    if (!neighbor.visited) {
      walls.push({ cellA: cell, cellB: neighbor });
    }
  }
}

// Convert 2D grid coordinates to 1D index
function index(i, j) {
  if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) {
    return -1;
  }
  return i + j * cols;
}

// Construct the path from end to start and reverse it
function constructPath(endCell) {
  path = [];
  let temp = endCell;
  path.push(temp);
  while (temp.previous) {
    path.push(temp.previous);
    temp = temp.previous;
  }
  path.reverse(); // Ensure path starts from the beginning

  // Start traversal animation
  orbPosition = 0;
  solvingCompleted = true;
}

// Animate the orb traversing the path
function animateTraversal() {
  if (orbPosition < path.length - 1) {
    orbPosition += 0.4; // Increased speed for faster traversal
    let indexPos = floor(orbPosition);
    let t = orbPosition - indexPos;

    // Ensure that indexPos and indexPos +1 are within bounds
    if (indexPos >= path.length - 1) {
      orbPosition = path.length - 1;
      return;
    }

    let currentCell = path[indexPos];
    let nextCell = path[indexPos + 1];

    if (!nextCell) return; // Prevent accessing undefined

    let x = lerp(
      currentCell.i * w + w / 2,
      nextCell.i * w + w / 2,
      t
    );
    let y = lerp(
      currentCell.j * w + w / 2,
      nextCell.j * w + w / 2,
      t
    );

    // Draw the orb with a glowing effect
    noStroke();
    let glowColor = color(255, 0, 255);
    glowColor.setAlpha(200);
    fill(glowColor);
    ellipse(x, y, w * 0.6, w * 0.6);

    // Add particles
    particles.push(new Particle(x, y));

  } else if (solvingCompleted) {
    // Reset the maze immediately after traversal completes
    initializeMaze();
  }
}

// Particle class for trailing effects
class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.vel.mult(random(1, 3));
    this.acc = createVector(0, 0);
    this.lifespan = 255;
  }

  finished() {
    return this.lifespan < 0;
  }

  update() {
    this.vel.mult(0.95);
    this.pos.add(this.vel);
    this.lifespan -= 5;
  }

  show() {
    noStroke();
    fill(255, 0, 255, this.lifespan);
    ellipse(this.pos.x, this.pos.y, 4);
  }
}

// Cell class representing each cell in the maze
class Cell {
  constructor(i, j) {
    this.i = i;
    this.j = j;
    this.walls = [true, true, true, true]; // Top, Right, Bottom, Left
    this.visited = false;
    this.previous = undefined;
  }

  // Get all neighboring cells
  getNeighbors() {
    let neighbors = [];
    let top = grid[index(this.i, this.j - 1)];
    let right = grid[index(this.i + 1, this.j)];
    let bottom = grid[index(this.i, this.j + 1)];
    let left = grid[index(this.i - 1, this.j)];

    if (top) neighbors.push(top);
    if (right) neighbors.push(right);
    if (bottom) neighbors.push(bottom);
    if (left) neighbors.push(left);

    return neighbors;
  }

  // Get neighbors that are accessible (no wall between)
  getUnblockedNeighbors() {
    let neighbors = [];
    let i = this.i;
    let j = this.j;

    if (!this.walls[0]) {
      let top = grid[index(i, j - 1)];
      if (top) neighbors.push(top);
    }
    if (!this.walls[1]) {
      let right = grid[index(i + 1, j)];
      if (right) neighbors.push(right);
    }
    if (!this.walls[2]) {
      let bottom = grid[index(i, j + 1)];
      if (bottom) neighbors.push(bottom);
    }
    if (!this.walls[3]) {
      let left = grid[index(i - 1, j)];
      if (left) neighbors.push(left);
    }

    return neighbors;
  }

  // Remove walls between this cell and another
  removeWalls(other) {
    let x = this.i - other.i;
    if (x === 1) {
      this.walls[3] = false;
      other.walls[1] = false;
    } else if (x === -1) {
      this.walls[1] = false;
      other.walls[3] = false;
    }
    let y = this.j - other.j;
    if (y === 1) {
      this.walls[0] = false;
      other.walls[2] = false;
    } else if (y === -1) {
      this.walls[2] = false;
      other.walls[0] = false;
    }
  }

  // Display the cell
  show() {
    let x = this.i * w;
    let y = this.j * w;

    stroke(255);
    strokeWeight(2);

    if (this.visited) {
      noStroke();
      fill(50, 50, 50, 100);
      rect(x, y, w, w);
    }

    // Draw walls
    stroke(255);
    if (this.walls[0]) line(x, y, x + w, y); // Top
    if (this.walls[1]) line(x + w, y, x + w, y + w); // Right
    if (this.walls[2]) line(x + w, y + w, x, y + w); // Bottom
    if (this.walls[3]) line(x, y + w, x, y); // Left
  }
}
"
"2439208","Maze: Problem + Solution","mySketch","let cols, rows;
let w = 20; // Cell size
let grid = [];
let walls = [];
let visited = [];
let current;
let mazeCompleted = false;
let path = [];
let orbPosition = 0;
let particles = [];
let solving = false;

function setup() {
  createCanvas(800, 800);
  cols = floor(width / w);
  rows = floor(height / w);

  // Initialize grid cells
  for (let j = 0; j < rows; j++) {
    for (let i = 0; i < cols; i++) {
      let cell = new Cell(i, j);
      grid.push(cell);
    }
  }

  // Start with a random cell
  current = grid[floor(random(0, grid.length))];
  visited.push(current);
  current.visited = true;
  addWalls(current);
}

function draw() {
  background(30);

  // Draw all cells
  for (let cell of grid) {
    cell.show();
  }

  // Maze generation using Prim's algorithm
  if (walls.length > 0) {
    let randomWall = random(walls);
    let { cellA, cellB } = randomWall;

    if (cellB && !cellB.visited) {
      // Remove wall between cellA and cellB
      cellA.removeWalls(cellB);
      cellB.visited = true;
      visited.push(cellB);
      addWalls(cellB);
    }

    // Remove the wall from the list
    walls.splice(walls.indexOf(randomWall), 1);
  } else if (!mazeCompleted) {
    // Maze generation completed
    mazeCompleted = true;
    console.log(""Maze Completed!"");

    // Reset visited status for maze solving
    for (let cell of grid) {
      cell.visited = false;
    }

    // Start maze solving
    path = [];
    solving = true;
    let startCell = grid[0];
    let endCell = grid[grid.length - 1];
    solveMaze(startCell, endCell);
  }

  // Draw the traversal animation
  if (mazeCompleted && solving && path.length > 0) {
    animateTraversal();
  }

  // Update and draw particles
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].show();
    if (particles[i].finished()) {
      particles.splice(i, 1);
    }
  }
}

function addWalls(cell) {
  let neighbors = cell.getNeighbors();
  for (let neighbor of neighbors) {
    if (!neighbor.visited) {
      walls.push({ cellA: cell, cellB: neighbor });
    }
  }
}

function index(i, j) {
  if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) {
    return -1;
  }
  return i + j * cols;
}

// Maze solving using DFS
function solveMaze(current, endCell) {
  current.visited = true;
  if (current === endCell) {
    path.push(current);
    return true;
  }

  let neighbors = current.getUnblockedNeighbors();
  for (let neighbor of neighbors) {
    if (!neighbor.visited) {
      neighbor.previous = current;
      if (solveMaze(neighbor, endCell)) {
        path.push(current);
        return true;
      }
    }
  }
  return false;
}

function animateTraversal() {
  if (orbPosition < path.length - 1) {
    orbPosition += 0.02; // Adjust speed here
    let index = floor(orbPosition);
    let t = orbPosition - index;

    let currentCell = path[index];
    let nextCell = path[index + 1];

    let x = lerp(
      currentCell.i * w + w / 2,
      nextCell.i * w + w / 2,
      t
    );
    let y = lerp(
      currentCell.j * w + w / 2,
      nextCell.j * w + w / 2,
      t
    );

    // Draw the orb
    noStroke();
    let glowColor = color(0, 255, 255);
    glowColor.setAlpha(200);
    fill(glowColor);
    ellipse(x, y, w * 0.6, w * 0.6);

    // Add particles
    particles.push(new Particle(x, y));

  } else {
    solving = false;
    console.log(""Traversal Completed!"");
  }
}

class Cell {
  constructor(i, j) {
    this.i = i;
    this.j = j;
    this.walls = [true, true, true, true]; // Top, Right, Bottom, Left
    this.visited = false;
    this.previous = undefined;
  }

  getNeighbors() {
    let neighbors = [];
    let top = grid[index(this.i, this.j - 1)];
    let right = grid[index(this.i + 1, this.j)];
    let bottom = grid[index(this.i, this.j + 1)];
    let left = grid[index(this.i - 1, this.j)];

    if (top) neighbors.push(top);
    if (right) neighbors.push(right);
    if (bottom) neighbors.push(bottom);
    if (left) neighbors.push(left);

    return neighbors;
  }

  getUnblockedNeighbors() {
    let neighbors = [];
    let i = this.i;
    let j = this.j;

    if (!this.walls[0]) {
      let top = grid[index(i, j - 1)];
      if (top) neighbors.push(top);
    }
    if (!this.walls[1]) {
      let right = grid[index(i + 1, j)];
      if (right) neighbors.push(right);
    }
    if (!this.walls[2]) {
      let bottom = grid[index(i, j + 1)];
      if (bottom) neighbors.push(bottom);
    }
    if (!this.walls[3]) {
      let left = grid[index(i - 1, j)];
      if (left) neighbors.push(left);
    }

    return neighbors;
  }

  removeWalls(other) {
    let x = this.i - other.i;
    if (x === 1) {
      this.walls[3] = false;
      other.walls[1] = false;
    } else if (x === -1) {
      this.walls[1] = false;
      other.walls[3] = false;
    }
    let y = this.j - other.j;
    if (y === 1) {
      this.walls[0] = false;
      other.walls[2] = false;
    } else if (y === -1) {
      this.walls[2] = false;
      other.walls[0] = false;
    }
  }

  show() {
    let x = this.i * w;
    let y = this.j * w;

    stroke(255);
    strokeWeight(2);

    if (this.visited) {
      noStroke();
      fill(50, 50, 50, 100);
      rect(x, y, w, w);
    }

    // Draw walls
    stroke(255);
    if (this.walls[0]) line(x, y, x + w, y); // Top
    if (this.walls[1]) line(x + w, y, x + w, y + w); // Right
    if (this.walls[2]) line(x + w, y + w, x, y + w); // Bottom
    if (this.walls[3]) line(x, y + w, x, y); // Left
  }
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.vel.mult(random(1, 3));
    this.acc = createVector(0, 0);
    this.lifespan = 255;
  }

  finished() {
    return this.lifespan < 0;
  }

  update() {
    this.vel.mult(0.95);
    this.pos.add(this.vel);
    this.lifespan -= 5;
  }

  show() {
    noStroke();
    fill(0, 255, 255, this.lifespan);
    ellipse(this.pos.x, this.pos.y, 4);
  }
}
"
"2439206","Prim's algorithm","mySketch","let cols, rows;
let w = 20; // Cell size
let grid = [];
let walls = [];
let visited = [];
let current;
let mazeCompleted = false;

function setup() {
  createCanvas(800, 800);
  cols = floor(width / w);
  rows = floor(height / w);

  // Initialize grid cells
  for (let j = 0; j < rows; j++) {
    for (let i = 0; i < cols; i++) {
      let cell = new Cell(i, j);
      grid.push(cell);
    }
  }

  // Start with a random cell
  current = grid[floor(random(0, grid.length))];
  visited.push(current);
  current.visited = true;
  addWalls(current);
}

function draw() {
  background(30);

  // Draw all cells
  for (let cell of grid) {
    cell.show();
  }

  // Maze generation using Prim's algorithm
  if (walls.length > 0) {
    let randomWall = random(walls);
    let { cellA, cellB } = randomWall;

    if (cellB && !cellB.visited) {
      // Remove wall between cellA and cellB
      cellA.removeWalls(cellB);
      cellB.visited = true;
      visited.push(cellB);
      addWalls(cellB);
    }

    // Remove the wall from the list
    walls.splice(walls.indexOf(randomWall), 1);
  } else if (!mazeCompleted) {
    // Maze generation completed
    mazeCompleted = true;
    console.log(""Maze Completed!"");
  }

  // Epic visual effects
  if (mazeCompleted) {
    noLoop();
    // Add your epic visual effects here
    // For example, animate a ball traversing the maze
    traverseMaze();
  }
}

function addWalls(cell) {
  let neighbors = cell.getNeighbors();
  for (let neighbor of neighbors) {
    if (!neighbor.visited) {
      walls.push({ cellA: cell, cellB: neighbor });
    }
  }
}

function index(i, j) {
  if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) {
    return -1;
  }
  return i + j * cols;
}

function traverseMaze() {
  // Implement a traversal animation or effect here
  // This function can be expanded to create an epic visualization
}

class Cell {
  constructor(i, j) {
    this.i = i;
    this.j = j;
    this.walls = [true, true, true, true]; // Top, Right, Bottom, Left
    this.visited = false;
  }

  getNeighbors() {
    let neighbors = [];
    let top = grid[index(this.i, this.j - 1)];
    let right = grid[index(this.i + 1, this.j)];
    let bottom = grid[index(this.i, this.j + 1)];
    let left = grid[index(this.i - 1, this.j)];

    if (top && !visited.includes(top)) neighbors.push(top);
    if (right && !visited.includes(right)) neighbors.push(right);
    if (bottom && !visited.includes(bottom)) neighbors.push(bottom);
    if (left && !visited.includes(left)) neighbors.push(left);

    return neighbors;
  }

  removeWalls(other) {
    let x = this.i - other.i;
    if (x === 1) {
      this.walls[3] = false;
      other.walls[1] = false;
    } else if (x === -1) {
      this.walls[1] = false;
      other.walls[3] = false;
    }
    let y = this.j - other.j;
    if (y === 1) {
      this.walls[0] = false;
      other.walls[2] = false;
    } else if (y === -1) {
      this.walls[2] = false;
      other.walls[0] = false;
    }
  }

  show() {
    let x = this.i * w;
    let y = this.j * w;

    stroke(255);
    strokeWeight(2);

    // Epic glow effect
    if (this.visited) {
      noStroke();
      fill(50, 50, 50, 100);
      rect(x, y, w, w);
    }

    // Draw walls
    if (this.walls[0]) line(x, y, x + w, y); // Top
    if (this.walls[1]) line(x + w, y, x + w, y + w); // Right
    if (this.walls[2]) line(x + w, y + w, x, y + w); // Bottom
    if (this.walls[3]) line(x, y + w, x, y); // Left
  }
}
"
"2439204","A* algorithm","mySketch","let cols = 50;
let rows = 50;
let grid = new Array(cols);

let openSet = [];
let closedSet = [];
let start;
let end;
let w, h;
let path = [];
let current;

function heuristic(a, b) {
  // Using Euclidean distance as heuristic
  return dist(a.i, a.j, b.i, b.j);
}

function removeFromArray(arr, elt) {
  for (let i = arr.length -1; i >= 0; i--) {
    if (arr[i] == elt) {
      arr.splice(i, 1);
    }
  }
}

function setup() {
  createCanvas(600, 600);
  w = width / cols;
  h = height / rows;

  // Create grid
  for (let i = 0; i < cols; i++) {
    grid[i] = new Array(rows);
  }

  // Initialize Spots
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      grid[i][j] = new Spot(i, j);
    }
  }

  // Add neighbors
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      grid[i][j].addNeighbors(grid);
    }
  }

  // Start and end
  start = grid[0][0];
  end = grid[cols - 1][rows - 1];
  start.wall = false;
  end.wall = false;

  openSet.push(start);
}

function draw() {
  background(30);

  if (openSet.length > 0) {
    // Keep going
    let lowestIndex = 0;
    for (let i = 0; i < openSet.length; i++) {
      if (openSet[i].f < openSet[lowestIndex].f) {
        lowestIndex = i;
      }
    }

    current = openSet[lowestIndex];

    if (current === end) {
      // Path found
      noLoop();
      console.log('Path Found!');
    }

    removeFromArray(openSet, current);
    closedSet.push(current);

    let neighbors = current.neighbors;
    for (let neighbor of neighbors) {
      if (!closedSet.includes(neighbor) && !neighbor.wall) {
        let tempG = current.g + heuristic(neighbor, current);

        let newPath = false;
        if (openSet.includes(neighbor)) {
          if (tempG < neighbor.g) {
            neighbor.g = tempG;
            newPath = true;
          }
        } else {
          neighbor.g = tempG;
          newPath = true;
          openSet.push(neighbor);
        }

        if (newPath) {
          neighbor.h = heuristic(neighbor, end);
          neighbor.f = neighbor.g + neighbor.h;
          neighbor.previous = current;
        }
      }
    }

  } else {
    // No solution
    console.log('No Solution');
    noLoop();
    return;
  }

  // Draw grid
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      grid[i][j].show(color(50));
    }
  }

  // Closed set
  for (let spot of closedSet) {
    spot.show(color(255, 0, 0, 100));
  }

  // Open set
  for (let spot of openSet) {
    spot.show(color(0, 255, 0, 100));
  }

  // Path
  path = [];
  let temp = current;
  path.push(temp);
  while (temp.previous) {
    path.push(temp.previous);
    temp = temp.previous;
  }

  // Draw path with gradient
  noFill();
  strokeWeight(w / 2);
  for (let i = 0; i < path.length - 1; i++) {
    let start = path[i];
    let end = path[i + 1];
    let inter = map(i, 0, path.length, 0, 1);
    let col = lerpColor(color(0, 0, 255), color(255, 255, 0), inter);
    stroke(col);
    line(
      start.i * w + w / 2,
      start.j * h + h / 2,
      end.i * w + w / 2,
      end.j * h + h / 2
    );
  }
}

function Spot(i, j) {
  this.i = i;
  this.j = j;
  this.f = 0;
  this.g = 0;
  this.h = 0;
  this.neighbors = [];
  this.previous = undefined;
  this.wall = false;

  if (random(1) < 0.3) {
    this.wall = true;
  }

  this.show = function(col) {
    if (this.wall) {
      fill(0);
      noStroke();
      ellipse(this.i * w + w / 2, this.j * h + h / 2, w / 2, h / 2);
    } else {
      fill(col);
      noStroke();
      rect(this.i * w, this.j * h, w, h);
    }
  };

  this.addNeighbors = function(grid) {
    let i = this.i;
    let j = this.j;
    if (i < cols - 1) {
      this.neighbors.push(grid[i + 1][j]);
    }
    if (i > 0) {
      this.neighbors.push(grid[i - 1][j]);
    }
    if (j < rows - 1) {
      this.neighbors.push(grid[i][j + 1]);
    }
    if (j > 0) {
      this.neighbors.push(grid[i][j - 1]);
    }
    // Diagonals (optional)
    if (i > 0 && j > 0) {
      this.neighbors.push(grid[i - 1][j - 1]);
    }
    if (i < cols - 1 && j > 0) {
      this.neighbors.push(grid[i + 1][j - 1]);
    }
    if (i > 0 && j < rows - 1) {
      this.neighbors.push(grid[i - 1][j + 1]);
    }
    if (i < cols - 1 && j < rows - 1) {
      this.neighbors.push(grid[i + 1][j + 1]);
    }
  };
}
"
"2438386","Dynamic Flow Field","mySketch","// ""Dynamic Flow Field"" 🎨 #WCCChallenge
// 8th April 2024

let flowField;
let cols, rows;
let resolution = 20;
let particles = [];
let numParticles = 1000;
let zOffset = 0;
let colorPalette;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  colorMode(HSB, 360, 100, 100, 100);
  
  cols = floor(width / resolution);
  rows = floor(height / resolution);
  flowField = new Array(cols * rows);
  
  // Initialize particles
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle());
  }
  
  // Define a vibrant color palette
  colorPalette = [
    color(0, 100, 100, 30),
    color(30, 100, 100, 30),
    color(60, 100, 100, 30),
    color(120, 100, 100, 30),
    color(180, 100, 100, 30),
    color(240, 100, 100, 30),
    color(300, 100, 100, 30),
  ];
}

function draw() {
  // Semi-transparent background for trail effect
  background(0, 0, 0, 10);
  
  // Update flow field
  let yOffset = zOffset;
  for (let y = 0; y < rows; y++) {
    let xOffset = 0;
    for (let x = 0; x < cols; x++) {
      let index = x + y * cols;
      let angle = noise(xOffset, yOffset, zOffset) * TWO_PI * 4;
      let v = p5.Vector.fromAngle(angle);
      v.setMag(1);
      flowField[index] = v;
      xOffset += 0.1;
    }
    yOffset += 0.1;
  }
  zOffset += 0.003;
  
  // Update and display particles
  for (let particle of particles) {
    particle.follow(flowField);
    particle.update();
    particle.edges();
    particle.show();
  }
}

function mouseMoved() {
  addDisturbance();
}

function mouseDragged() {
  addDisturbance();
}

function addDisturbance() {
  let disturbanceRadius = 100;
  for (let particle of particles) {
    let d = dist(mouseX, mouseY, particle.pos.x, particle.pos.y);
    if (d < disturbanceRadius) {
      let force = p5.Vector.sub(particle.pos, createVector(mouseX, mouseY));
      force.setMag(0.5);
      particle.vel.add(force);
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  cols = floor(width / resolution);
  rows = floor(height / resolution);
  flowField = new Array(cols * rows);
  background(0);
}

// Particle class
class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.maxSpeed = 4;
    this.prevPos = this.pos.copy();
    this.hue = random(360);
  }
  
  follow(flow) {
    let x = floor(this.pos.x / resolution);
    let y = floor(this.pos.y / resolution);
    let index = x + y * cols;
    if (index >= 0 && index < flow.length) {
      let force = flow[index];
      this.applyForce(force);
    }
  }
  
  applyForce(force) {
    this.acc.add(force);
  }
  
  update() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }
  
  show() {
    stroke(this.hue, 100, 100, 30);
    strokeWeight(1);
    line(this.prevPos.x, this.prevPos.y, this.pos.x, this.pos.y);
    this.prevPos = this.pos.copy();
  }
  
  edges() {
    if (this.pos.x > width) {
      this.pos.x = 0;
      this.prevPos = this.pos.copy();
    }
    if (this.pos.x < 0) {
      this.pos.x = width;
      this.prevPos = this.pos.copy();
    }
    if (this.pos.y > height) {
      this.pos.y = 0;
      this.prevPos = this.pos.copy();
    }
    if (this.pos.y < 0) {
      this.pos.y = height;
      this.prevPos = this.pos.copy();
    }
  }
}
"
"2438367","Gray-Scott Reaction-Diffusion","mySketch","let grid;
let next;
let dA = 1.0;
let dB = 0.5;
let feed = 0.055;
let k = 0.062;
let canvasSize;
let pixelDensityValue;

function setup() {
  canvasSize = min(windowWidth, windowHeight);
  createCanvas(canvasSize, canvasSize);
  pixelDensityValue = pixelDensity();
  
  // Initialize grid and next arrays
  grid = [];
  next = [];
  for (let x = 0; x < width * pixelDensityValue; x++) {
    grid[x] = [];
    next[x] = [];
    for (let y = 0; y < height * pixelDensityValue; y++) {
      grid[x][y] = { a: 1, b: 0 };
      next[x][y] = { a: 1, b: 0 };
    }
  }

  // Seed the initial pattern in the center with integer indices
  let centerX = floor(width / 2);
  let centerY = floor(height / 2);
  for (let i = centerX - 10; i < centerX + 10; i++) {
    for (let j = centerY - 10; j < centerY + 10; j++) {
      if (i >= 0 && i < width * pixelDensityValue && j >= 0 && j < height * pixelDensityValue) {
        grid[i][j].b = 1;
      }
    }
  }
}

function draw() {
  background(245, 245, 220, 10); // Slightly transparent background for trailing effect

  // Perform one step of the simulation
  for (let x = 1; x < width * pixelDensityValue - 1; x++) {
    for (let y = 1; y < height * pixelDensityValue - 1; y++) {
      let a = grid[x][y].a;
      let b = grid[x][y].b;

      // Gray-Scott Reaction-Diffusion equations
      next[x][y].a = a + (dA * laplaceA(x, y) - a * b * b + feed * (1 - a)) * 1;
      next[x][y].b = b + (dB * laplaceB(x, y) + a * b * b - (k + feed) * b) * 1;

      // Constrain the values between 0 and 1
      next[x][y].a = constrain(next[x][y].a, 0, 1);
      next[x][y].b = constrain(next[x][y].b, 0, 1);
    }
  }

  // Update the pixel array for visualization
  loadPixels();
  for (let x = 0; x < width * pixelDensityValue; x++) {
    for (let y = 0; y < height * pixelDensityValue; y++) {
      let pix = (x + y * width * pixelDensityValue) * 4;
      let a = next[x][y].a;
      let b = next[x][y].b;
      let c = floor((a - b) * 255);

      // Apply smooth and thin lines with grayscale coloring
      c = constrain(c, 0, 255);
      pixels[pix + 0] = c;     // Red
      pixels[pix + 1] = c;     // Green
      pixels[pix + 2] = c;     // Blue
      pixels[pix + 3] = 255;   // Alpha
    }
  }
  updatePixels();

  // Swap the grids for the next iteration
  let temp = grid;
  grid = next;
  next = temp;
}

// Laplace operator for chemical A
function laplaceA(x, y) {
  let sumA = 0;
  sumA += grid[x][y].a * -1;
  sumA += grid[x - 1][y].a * 0.2;
  sumA += grid[x + 1][y].a * 0.2;
  sumA += grid[x][y + 1].a * 0.2;
  sumA += grid[x][y - 1].a * 0.2;
  sumA += grid[x - 1][y - 1].a * 0.05;
  sumA += grid[x + 1][y - 1].a * 0.05;
  sumA += grid[x + 1][y + 1].a * 0.05;
  sumA += grid[x - 1][y + 1].a * 0.05;
  return sumA;
}

// Laplace operator for chemical B
function laplaceB(x, y) {
  let sumB = 0;
  sumB += grid[x][y].b * -1;
  sumB += grid[x - 1][y].b * 0.2;
  sumB += grid[x + 1][y].b * 0.2;
  sumB += grid[x][y + 1].b * 0.2;
  sumB += grid[x][y - 1].b * 0.2;
  sumB += grid[x - 1][y - 1].b * 0.05;
  sumB += grid[x + 1][y - 1].b * 0.05;
  sumB += grid[x + 1][y + 1].b * 0.05;
  sumB += grid[x - 1][y + 1].b * 0.05;
  return sumB;
}

// Allow the user to interact by adding chemical B with mouse drag
function mouseDragged() {
  let x = floor(mouseX * pixelDensityValue);
  let y = floor(mouseY * pixelDensityValue);
  if (x > 1 && x < width * pixelDensityValue - 1 && y > 1 && y < height * pixelDensityValue - 1) {
    grid[x][y].b = 1;
    grid[x - 1][y].b = 1;
    grid[x + 1][y].b = 1;
    grid[x][y - 1].b = 1;
    grid[x][y + 1].b = 1;
  }
}

// Adjust the canvas and reinitialize the grid upon window resize
function windowResized() {
  canvasSize = min(windowWidth, windowHeight);
  resizeCanvas(canvasSize, canvasSize);
  
  // Reinitialize grid and next arrays
  grid = [];
  next = [];
  for (let x = 0; x < width * pixelDensityValue; x++) {
    grid[x] = [];
    next[x] = [];
    for (let y = 0; y < height * pixelDensityValue; y++) {
      grid[x][y] = { a: 1, b: 0 };
      next[x][y] = { a: 1, b: 0 };
    }
  }

  // Seed the initial pattern in the center with integer indices
  let centerX = floor(width / 2);
  let centerY = floor(height / 2);
  for (let i = centerX - 10; i < centerX + 10; i++) {
    for (let j = centerY - 10; j < centerY + 10; j++) {
      if (i >= 0 && i < width * pixelDensityValue && j >= 0 && j < height * pixelDensityValue) {
        grid[i][j].b = 1;
      }
    }
  }
}
"
"2438351","Yet another Superformula","mySketch","let m = 0;
let n1 = 1;
let n2 = 1;
let n3 = 1;
let a = 1;
let b = 1;
let sliderM, sliderN1, sliderN2, sliderN3;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(245, 245, 220); // Parchment-like background
  angleMode(DEGREES);
  
  // Create sliders for interaction
  sliderM = createSlider(0, 20, 0, 0.1);
  sliderM.position(20, 20);
  sliderM.style('width', '200px');
  
  sliderN1 = createSlider(0.1, 10, 1, 0.1);
  sliderN1.position(20, 50);
  sliderN1.style('width', '200px');
  
  sliderN2 = createSlider(0.1, 10, 1, 0.1);
  sliderN2.position(20, 80);
  sliderN2.style('width', '200px');
  
  sliderN3 = createSlider(0.1, 10, 1, 0.1);
  sliderN3.position(20, 110);
  sliderN3.style('width', '200px');
  
  stroke(0);
  noFill();
}

function draw() {
  background(245, 245, 220, 10); // Fade effect for trailing
  translate(width / 2, height / 2);
  
  m = sliderM.value();
  n1 = sliderN1.value();
  n2 = sliderN2.value();
  n3 = sliderN3.value();
  
  let radius = min(width, height) * 0.4;
  let totalPoints = 360;
  
  strokeWeight(1);
  beginShape();
  for (let angle = 0; angle < 360; angle += 360 / totalPoints) {
    let r = superformula(angle);
    let x = radius * r * cos(angle);
    let y = radius * r * sin(angle);
    vertex(x, y);
  }
  endShape(CLOSE);
  
  // Display parameter values
  resetMatrix();
  fill(0);
  noStroke();
  textSize(16);
  text('m: ' + nf(m, 1, 1), 240, 35);
  text('n1: ' + nf(n1, 1, 1), 240, 65);
  text('n2: ' + nf(n2, 1, 1), 240, 95);
  text('n3: ' + nf(n3, 1, 1), 240, 125);
}

function superformula(theta) {
  let part1 = (1 / a) * cos(m * theta / 4);
  part1 = abs(part1);
  part1 = pow(part1, n2);
  
  let part2 = (1 / b) * sin(m * theta / 4);
  part2 = abs(part2);
  part2 = pow(part2, n3);
  
  let r = pow(part1 + part2, -1 / n1);
  return r;
}
"
"2438335","Metatron's Cube","mySketch","// ""Metatron's Cube Sketch"" 

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(245, 245, 220); // Parchment-like background
  stroke(0);
  noFill();
}

function draw() {
  background(245, 245, 220);
  translate(width / 2, height / 2);

  let radius = min(width, height) * 0.2;
  let points = [];

  // Generate 13 points (center + vertices of two overlapping hexagons)
  for (let i = 0; i < 6; i++) {
    let angle = TWO_PI / 6 * i - PI / 2;
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    points.push(createVector(x, y));
  }
  for (let i = 0; i < 6; i++) {
    let angle = TWO_PI / 6 * i - PI / 2 + PI / 6;
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    points.push(createVector(x, y));
  }
  points.push(createVector(0, 0)); // Center point

  // Draw circles at each point
  strokeWeight(1);
  for (let p of points) {
    ellipse(p.x, p.y, radius * 2);
  }

  // Draw lines connecting all points
  for (let i = 0; i < points.length; i++) {
    for (let j = i + 1; j < points.length; j++) {
      line(points[i].x, points[i].y, points[j].x, points[j].y);
    }
  }
}
"
"2438324","Spring time","mySketch","let flowers = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);
  angleMode(DEGREES);
  noLoop();
}

function draw() {
  background(255, 10); // Semi-transparent background for fade effect

  for (let flower of flowers) {
    flower.update();
    flower.display();
  }
}

function mousePressed() {
  flowers.push(new Flower(mouseX, mouseY));
  loop();
}

class Flower {
  constructor(x, y) {
    this.position = createVector(x, y);
    this.maxPetalSize = random(50, 150);
    this.petalSize = 0;
    this.growthRate = 2;
    this.numPetals = int(random(12, 24));
    this.angleOffset = random(360);
    this.petalColor = color(random(200, 255), random(100, 200), random(100, 200));
    this.centerColor = color(random(200, 255), random(200, 255), 0);
    this.grown = false;
  }

  update() {
    if (this.petalSize < this.maxPetalSize) {
      this.petalSize += this.growthRate;
    } else {
      this.grown = true;
      noLoop();
    }
  }

  display() {
    push();
    translate(this.position.x, this.position.y);
    rotate(this.angleOffset);
    noStroke();

    // Draw petals with Bézier curves for maximum definition
    for (let i = 0; i < this.numPetals; i++) {
      let angle = (360 / this.numPetals) * i;
      push();
      rotate(angle);
      fill(this.petalColor);
      beginShape();
      vertex(0, 0);
      bezierVertex(
        -this.petalSize * 0.2,
        -this.petalSize * 0.2,
        -this.petalSize * 0.2,
        -this.petalSize * 0.8,
        0,
        -this.petalSize
      );
      bezierVertex(
        this.petalSize * 0.2,
        -this.petalSize * 0.8,
        this.petalSize * 0.2,
        -this.petalSize * 0.2,
        0,
        0
      );
      endShape(CLOSE);
      pop();
    }

    // Draw flower center with gradient
    noStroke();
    for (let r = this.petalSize * 0.2; r > 0; r -= 2) {
      fill(lerpColor(this.centerColor, color(255), r / (this.petalSize * 0.2)));
      ellipse(0, 0, r * 2);
    }

    pop();
  }
}
"
"2438316","Random Forest","mySketch","let trees = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(51);
}

function draw() {
  background(51, 25); // Semi-transparent background for trail effect

  for (let tree of trees) {
    tree.grow();
    tree.display();
  }
}

function mousePressed() {
  trees.push(new Tree(mouseX, mouseY));
}

class Tree {
  constructor(x, y) {
    this.branches = [];
    this.maxLevels = int(random(5, 8));
    this.initialLength = random(50, 100);
    this.origin = createVector(x, y);
    this.angleOffset = random(-PI / 6, PI / 6);
    this.generation = 0;
    this.grown = false;

    // Start growing from the bottom up
    let a = createVector(0, -1);
    a.setMag(this.initialLength);
    let root = new Branch(this.origin, p5.Vector.add(this.origin, a), this.generation, this.maxLevels);
    this.branches.push(root);
  }

  grow() {
    if (!this.grown) {
      let branchesToAdd = [];
      for (let branch of this.branches) {
        if (!branch.finished && branch.generation < this.maxLevels) {
          branchesToAdd.push(branch.branchA());
          branchesToAdd.push(branch.branchB());
          branch.finished = true;
        }
      }
      this.branches = this.branches.concat(branchesToAdd);

      // Check if tree has finished growing
      if (branchesToAdd.length === 0) {
        this.grown = true;
      }
    }
  }

  display() {
    for (let branch of this.branches) {
      branch.display();
    }
  }
}

class Branch {
  constructor(start, end, generation, maxLevels) {
    this.start = start;
    this.end = end;
    this.finished = false;
    this.generation = generation;
    this.maxLevels = maxLevels;
  }

  branchA() {
    let dir = p5.Vector.sub(this.end, this.start);
    dir.rotate(random(-PI / 6, -PI / 4));
    dir.mult(0.67);
    let newEnd = p5.Vector.add(this.end, dir);
    return new Branch(this.end, newEnd, this.generation + 1, this.maxLevels);
  }

  branchB() {
    let dir = p5.Vector.sub(this.end, this.start);
    dir.rotate(random(PI / 4, PI / 6));
    dir.mult(0.67);
    let newEnd = p5.Vector.add(this.end, dir);
    return new Branch(this.end, newEnd, this.generation + 1, this.maxLevels);
  }

  display() {
    stroke(139, 69, 19); // Brown color for branches
    strokeWeight(map(this.maxLevels - this.generation, 0, this.maxLevels, 1, 10));
    line(this.start.x, this.start.y, this.end.x, this.end.y);

    // Leaves at the end branches
    if (this.generation === this.maxLevels) {
      fill(34, 139, 34, 150); // Green leaves
      noStroke();
      ellipse(this.end.x, this.end.y, 10, 10);
    }
  }
}
"
"2438306","Universe creation","mySketch","let galaxies = [];
let isDragging = false;
let dragStart;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
}

function draw() {
  background(0, 25); // Semi-transparent background for trail effect
  
  // Display and update all galaxies
  for (let galaxy of galaxies) {
    galaxy.update();
    galaxy.display();
  }
  
  // If dragging, draw a line to show the drag
  if (isDragging) {
    stroke(255);
    strokeWeight(1);
    line(dragStart.x, dragStart.y, mouseX, mouseY);
  }
}

function mousePressed() {
  isDragging = true;
  dragStart = createVector(mouseX, mouseY);
}

function mouseReleased() {
  isDragging = false;
  let dragEnd = createVector(mouseX, mouseY);
  let dragVector = p5.Vector.sub(dragEnd, dragStart);
  
  // Determine galaxy properties based on drag
  let size = constrain(dragVector.mag(), 50, 300);
  let rotationSpeed = map(dragVector.mag(), 0, 500, 0.01, 0.05);
  if (dragVector.mag() === 0) {
    rotationSpeed = 0.02; // Default rotation speed
  }
  
  // Create a new galaxy
  galaxies.push(new Galaxy(dragStart.x, dragStart.y, size, rotationSpeed, dragVector.heading()));
}

class Galaxy {
  constructor(x, y, size, rotationSpeed, angle) {
    this.position = createVector(x, y);
    this.size = size;
    this.rotationSpeed = rotationSpeed;
    this.angleOffset = angle;
    this.stars = [];
    this.numStars = int(map(size, 50, 300, 100, 500));
    this.rotation = 0;
    this.color = color(random(360), 255, 255);
    colorMode(HSB, 360, 255, 255, 255);
    
    // Generate stars in a spiral pattern
    for (let i = 0; i < this.numStars; i++) {
      let angle = i * 0.1;
      let radius = (i / this.numStars) * this.size;
      let x = radius * cos(angle);
      let y = radius * sin(angle);
      this.stars.push(createVector(x, y));
    }
  }
  
  update() {
    this.rotation += this.rotationSpeed;
  }
  
  display() {
    push();
    translate(this.position.x, this.position.y);
    rotate(this.rotation + this.angleOffset);
    noStroke();
    fill(this.color);
    for (let star of this.stars) {
      ellipse(star.x, star.y, 2, 2);
    }
    pop();
  }
}
"
"2438287","Epic Fireworks","mySketch","// ""Epic Fireworks Display"" 

let fireworks = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB);
  background(0);
  frameRate(60);
}

function draw() {
  background(0, 25); // Semi-transparent background for trail effect
  for (let i = fireworks.length - 1; i >= 0; i--) {
    fireworks[i].update();
    fireworks[i].display();

    if (fireworks[i].done()) {
      fireworks.splice(i, 1);
    }
  }
}

function mousePressed() {
  fireworks.push(new Firework(mouseX, mouseY));
}

function touchStarted() {
  fireworks.push(new Firework(mouseX, mouseY));
  return false; // Prevent default behavior
}

class Firework {
  constructor(x, targetY) {
    this.position = createVector(x, height);
    this.velocity = createVector(0, random(-12, -8));
    this.acceleration = createVector(0, 0);
    this.exploded = false;
    this.particles = [];
    this.color = color(random(360), 255, 255);
    this.targetY = targetY;
  }

  applyForce(force) {
    this.acceleration.add(force);
  }

  update() {
    if (!this.exploded) {
      this.applyForce(createVector(0, 0.2)); // Gravity
      this.velocity.add(this.acceleration);
      this.position.add(this.velocity);
      this.acceleration.mult(0);
      if (this.position.y <= this.targetY || this.velocity.y >= 0) {
        this.explode();
      }
    }

    for (let i = this.particles.length - 1; i >= 0; i--) {
      this.particles[i].applyForce(createVector(0, 0.2)); // Gravity
      this.particles[i].update();
      if (this.particles[i].done()) {
        this.particles.splice(i, 1);
      }
    }
  }

  explode() {
    this.exploded = true;
    let numParticles = random(50, 150);
    for (let i = 0; i < numParticles; i++) {
      let p = new Particle(this.position.x, this.position.y, this.color);
      this.particles.push(p);
    }
  }

  done() {
    return this.exploded && this.particles.length == 0;
  }

  display() {
    if (!this.exploded) {
      stroke(this.color);
      strokeWeight(4);
      point(this.position.x, this.position.y);
    }
    for (let i = 0; i < this.particles.length; i++) {
      this.particles[i].display();
    }
  }
}

class Particle {
  constructor(x, y, color) {
    this.position = createVector(x, y);
    this.velocity = p5.Vector.random2D();
    this.velocity.mult(random(2, 10));
    this.acceleration = createVector(0, 0);
    this.lifespan = 255;
    this.color = color;
  }

  applyForce(force) {
    this.acceleration.add(force);
  }

  update() {
    this.velocity.mult(0.95); // Air resistance
    this.velocity.add(this.acceleration);
    this.position.add(this.velocity);
    this.acceleration.mult(0);
    this.lifespan -= 4;
  }

  done() {
    return this.lifespan < 0;
  }

  display() {
    strokeWeight(2);
    stroke(this.color.levels[0], this.color.levels[1], this.color.levels[2], this.lifespan);
    point(this.position.x, this.position.y);
  }
}
"
"2437971","OFO Star!","mySketch","let particles = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  angleMode(DEGREES);
  for (let i = 0; i < 100; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  background(0);
  
  // Desenhar partículas
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.update();
    p.show();
    if (p instanceof ParticleExplosion && p.isFinished()) {
      particles.splice(i, 1);
    }
  }

  // Desenhar estrela rotativa
  push();
  translate(width / 2, height / 2);
  rotate(frameCount);
  fill(255, 204, 0);
  noStroke();
  drawStar(0, 0, 100, 50, 5);
  pop();
}

function drawStar(x, y, radius1, radius2, npoints) {
  let angle = 360 / npoints;
  let halfAngle = angle / 2.0;
  beginShape();
  for (let a = 0; a < 360; a += angle) {
    let sx = x + cos(a) * radius2;
    let sy = y + sin(a) * radius2;
    vertex(sx, sy);
    sx = x + cos(a + halfAngle) * radius1;
    sy = y + sin(a + halfAngle) * radius1;
    vertex(sx, sy);
  }
  endShape(CLOSE);
}

class Particle {
  constructor() {
    this.x = random(width);
    this.y = random(height);
    this.vx = random(-1, 1);
    this.vy = random(-1, 1);
    this.alpha = random(100, 255);
    this.size = random(2, 5);
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;

    // Envolver nas bordas
    if (this.x < 0) this.x = width;
    if (this.x > width) this.x = 0;
    if (this.y < 0) this.y = height;
    if (this.y > height) this.y = 0;
  }

  show() {
    noStroke();
    fill(255, this.alpha);
    ellipse(this.x, this.y, this.size);
  }
}

class ParticleExplosion extends Particle {
  constructor(x, y) {
    super();
    this.x = x;
    this.y = y;
    this.vx = random(-3, 3);
    this.vy = random(-3, 3);
    this.alpha = 255;
    this.size = random(2, 5);
    this.lifetime = 255;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.lifetime -= 5;
    this.alpha = this.lifetime;
  }

  isFinished() {
    return this.lifetime < 0;
  }
}

function mousePressed() {
  for (let i = 0; i < 50; i++) {
    particles.push(new ParticleExplosion(mouseX, mouseY));
  }
}

function touchStarted() {
  mousePressed();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2431681","Art Generation","index.html","<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <title>Generative Tree Gallery Piece</title>
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #FFFFFF;
            margin: 0;
            padding: 0;
            overflow-x: hidden; /* Prevents horizontal scrolling */
        }
        
        #promptContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            min-height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.95);
            z-index: 1000;
            padding: 20px;
        }
        
        #promptContainer h1 {
            margin-bottom: 10px;
            font-size: 24px;
        }
        #promptContainer h2 {
            margin-bottom: 10px;
            font-size: 20px;
        }
        #promptContainer p {
            max-width: 600px;
            margin-bottom: 20px;
            font-size: 16px;
            line-height: 1.5;
        }
        #promptContainer input {
            padding: 10px;
            font-size: 16px;
            border: 2px solid #000;
            border-radius: 5px;
            width: 250px;
            margin-bottom: 20px;
        }
        .styledButton {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            background-color: #000;
            color: #fff;
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            transition: background-color 0.3s;
            margin-top: 20px;
            margin-bottom: 50px;
        }
        .styledButton:hover {
            background-color: #333;
        }
        canvas {
            display: block;
            margin: 50px auto;
            border: 13px solid black;
            box-sizing: content-box;
            box-shadow: -26px 26px 26px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            height: auto;
            width: 90%;
        }
        
        /* Responsive adjustments for mobile devices */
        @media (max-width: 600px) {
            canvas {
                border: 5px solid black;
                box-shadow: -10px 10px 10px rgba(0, 0, 0, 0.5);
                margin: 20px auto;
            }
        }
    </style>
</head>
<body>
    <div id=""promptContainer"">
        <h1>Welcome to Building Creative Machines<br>Be part of our Art Generation Experience</h1>
        <p>Experience the magic of art reimagined. This generator crafts a bespoke masterpiece, uniquely imprinted with your name, date, and the precise moment of creation. Each artwork stands as a one-of-a-kind reflection of your presence, further enriched by the shared spirit and growing legacy of our creative community—evolving with every new piece ever made.</p>
        <p>After submitting your name and email, you may download your unique art piece and share it with the world. We will use your email only to subscribe you to the Building Creative Machines Substack and offer you new experiences like this and much more.</p>
        <h2>What is your name?</h2>
        <input type=""text"" id=""nameInput"" placeholder=""Enter your name"">
        <h2>What is your email?</h2>
        <input type=""email"" id=""emailInput"" placeholder=""Enter your email"">
        <button id=""submitButton"" class=""styledButton"">Submit</button>
    </div>
    <script>
        (function() {
            // Linear Congruential Generator (LCG) for pseudo-random number generation
            function LCG(seed) {
                return function() {
                    seed = (seed * 1664525 + 1013904223) % 4294967296;
                    return seed / 4294967296;
                }
            }

            // Simple hash function to generate a numerical seed from a string
            function hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = str.charCodeAt(i) + ((hash << 5) - hash);
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }

            // Function to detect if the device is a mobile smartphone
            function isMobile() {
                return /Mobi|Android/i.test(navigator.userAgent);
            }

            document.addEventListener('DOMContentLoaded', function() {
                const nameInput = document.getElementById('nameInput');
                const emailInput = document.getElementById('emailInput');
                const promptContainer = document.getElementById('promptContainer');
                const submitButton = document.getElementById('submitButton');

                const SHEETDB_API_URL = 'https://sheetdb.io/api/v1/q5grl5uop89pe'; // Replace with your SheetDB API URL

                function sendDataToSheetDB(name, email) {
                    const data = {
                        data: [
                            {
                                Name: name,
                                Email: email
                            }
                        ]
                    };

                    fetch(SHEETDB_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    })
                    .then(function(response) {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(function(data) {
                        console.log('Data sent to SheetDB:', data);
                    })
                    .catch(function(error) {
                        console.error('Error sending data to SheetDB:', error);
                    });
                }

                submitButton.addEventListener('click', function() {
                    const userName = nameInput.value.trim();
                    const userEmail = emailInput.value.trim();
                    if (userName !== '' && userEmail !== '') {
                        sendDataToSheetDB(userName, userEmail);
                        if (isMobile()) {
                            generateAndDownloadImage(userName);
                        } else {
                            startTreeGeneration(userName);
                        }
                    } else {
                        alert('Please enter your name and email.');
                    }
                });

                nameInput.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter' || event.keyCode === 13) {
                        emailInput.focus();
                    }
                });

                emailInput.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter' || event.keyCode === 13) {
                        const userName = nameInput.value.trim();
                        const userEmail = emailInput.value.trim();
                        if (userName !== '' && userEmail !== '') {
                            sendDataToSheetDB(userName, userEmail);
                            if (isMobile()) {
                                generateAndDownloadImage(userName);
                            } else {
                                startTreeGeneration(userName);
                            }
                        } else {
                            alert('Please enter your name and email.');
                        }
                    }
                });

                function startTreeGeneration(userName) {
                    promptContainer.style.display = 'none';

                    const canvas = document.createElement('canvas');
                    const maxCanvasWidth = 800;
                    const cssCanvasWidth = Math.min(window.innerWidth * 0.9, maxCanvasWidth);
                    const cssCanvasHeight = cssCanvasWidth * 0.75; // Maintain aspect ratio

                    // Get device pixel ratio
                    const devicePixelRatio = window.devicePixelRatio || 1;

                    // Set the canvas width and height according to the device pixel ratio
                    canvas.width = cssCanvasWidth * devicePixelRatio;
                    canvas.height = cssCanvasHeight * devicePixelRatio;

                    // Set the canvas CSS width and height
                    canvas.style.width = cssCanvasWidth + 'px';
                    canvas.style.height = cssCanvasHeight + 'px';

                    const ctx = canvas.getContext('2d');

                    // Scale the context to the device pixel ratio
                    ctx.scale(devicePixelRatio, devicePixelRatio);

                    // Append the canvas to the document
                    document.body.appendChild(canvas);

                    // Create and append the download button
                    const downloadButton = document.createElement('button');
                    downloadButton.textContent = 'Download';
                    downloadButton.id = 'downloadButton';
                    downloadButton.className = 'styledButton';
                    document.body.appendChild(downloadButton);

                    downloadButton.addEventListener('click', function() {
                        const link = document.createElement('a');
                        link.download = userName.replace(/\s+/g, '_') + '_Generative_Tree.png';
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    });

                    // Generate and draw the tree
                    generateTree(canvas, ctx, cssCanvasWidth, cssCanvasHeight, userName, function() {
                        // Drawing complete, nothing else to do
                    });
                }

                function generateAndDownloadImage(userName) {
                    promptContainer.style.display = 'none';

                    const canvas = document.createElement('canvas');
                    const maxCanvasWidth = 800;
                    const canvasWidth = maxCanvasWidth;
                    const canvasHeight = canvasWidth * 0.75; // Maintain aspect ratio

                    // Get device pixel ratio
                    const devicePixelRatio = window.devicePixelRatio || 1;

                    // Set the canvas width and height according to the device pixel ratio
                    canvas.width = canvasWidth * devicePixelRatio;
                    canvas.height = canvasHeight * devicePixelRatio;

                    const ctx = canvas.getContext('2d');

                    // Scale the context to the device pixel ratio
                    ctx.scale(devicePixelRatio, devicePixelRatio);

                    // Generate and draw the tree
                    generateTree(canvas, ctx, canvasWidth, canvasHeight, userName, function() {
                        // Drawing complete, initiate download
                        const link = document.createElement('a');
                        link.download = userName.replace(/\s+/g, '_') + '_Generative_Tree.png';
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    });
                }

                // Shared function to generate and draw the tree
                function generateTree(canvas, ctx, canvasWidth, canvasHeight, userName, callback) {
                    const inputNumber = 1001;
                    const currentDate = new Date();
                    const seedInput = hashString(userName) + currentDate.getTime() + inputNumber;
                    const prng = LCG(seedInput);

                    const maxBranches = 1000;
                    const angleVariation = 70;
                    const lengthVariation = 0.7;
                    const baseLength = 80;
                    const colors = ['#FF7F50', '#FFD700', '#ADFF2F', '#00FA9A', '#00CED1', '#1E90FF', '#9932CC'];

                    let branches = [{
                        x: canvasWidth / 2,
                        y: canvasHeight - 50 - 26,
                        angle: -90,
                        length: baseLength,
                        depth: 0,
                        maxDepth: 12
                    }];

                    function initBackground() {
                        const gradient = ctx.createRadialGradient(
                            canvasWidth / 2, canvasHeight, 0,
                            canvasWidth / 2, canvasHeight, canvasHeight
                        );
                        gradient.addColorStop(0, '#000000');
                        gradient.addColorStop(1, '#333333');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                    }

                    initBackground();

                    function drawStamp() {
                        const stampTextLine1 = 'A unique creation for ' + userName + ' by Building Creative Machines, marked ' + currentDate.toLocaleString();
                        const stampTextLine2 = 'Craft your masterpiece at www.buildingcreativemachines.com';
                        ctx.font = '12px Arial'; // Keep font size consistent
                        ctx.fillStyle = 'white';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText(stampTextLine1, canvasWidth / 2, canvasHeight - 10 - 26);
                        ctx.fillText(stampTextLine2, canvasWidth / 2, canvasHeight - 30 - 26);
                    }

                    function draw() {
                        let newBranches = [];

                        branches.forEach(function(branch) {
                            ctx.beginPath();
                            ctx.moveTo(branch.x, branch.y);

                            const endX = branch.x + branch.length * Math.cos(branch.angle * Math.PI / 180);
                            const endY = branch.y + branch.length * Math.sin(branch.angle * Math.PI / 180);

                            ctx.lineTo(endX, endY);

                            ctx.strokeStyle = colors[branch.depth % colors.length];
                            ctx.lineWidth = (branch.maxDepth - branch.depth + 1) * 1.2; // Keep line width consistent
                            ctx.stroke();

                            if (branch.depth < branch.maxDepth) {
                                const branchesNum = 2 + Math.round(prng() * 2);
                                for (let i = 0; i < branchesNum; i++) {
                                    const newAngle = branch.angle + prng() * angleVariation - angleVariation / 2;
                                    const newLength = branch.length * (lengthVariation + prng() * (1 - lengthVariation));

                                    newBranches.push({
                                        x: endX,
                                        y: endY,
                                        angle: newAngle,
                                        length: newLength,
                                        depth: branch.depth + 1,
                                        maxDepth: branch.maxDepth
                                    });
                                }
                            } else {
                                ctx.beginPath();
                                const radius = 5 + prng() * 5; // Keep radius consistent
                                ctx.arc(endX, endY, radius, 0, Math.PI * 2);
                                ctx.fillStyle = colors[(branch.depth + 1) % colors.length];
                                ctx.fill();
                            }
                        });

                        branches = newBranches;

                        if (branches.length > 0 && branches.length < maxBranches) {
                            // Continue drawing with animation frame
                            requestAnimationFrame(draw);
                        } else {
                            drawStamp();
                            callback(); // Drawing is complete
                        }
                    }

                    draw();
                }
            });
        })();
    </script>
</body>
</html>
"
"2431080","Serigrafias","mySketch","(function() {
    // Create and style the canvas
    var canvas = document.createElement('canvas');
    canvas.width = 800;
    canvas.height = 600;
    canvas.style.display = 'block';
    canvas.style.margin = '50px auto';
    canvas.style.border = '13px solid black';
    canvas.style.padding = '26px';
    canvas.style.boxShadow = '-26px 26px 26px rgba(0, 0, 0, 0.5)';
    document.body.style.backgroundColor = '#FFFFFF';
    document.body.appendChild(canvas);

    var ctx = canvas.getContext('2d');

    // Variables for the tree generation
    var branches = [];
    var maxBranches = 1000;
    var angleVariation = 70;
    var lengthVariation = 0.7;
    var baseLength = 80;
    var colors = ['#FF7F50', '#FFD700', '#ADFF2F', '#00FA9A', '#00CED1', '#1E90FF', '#9932CC'];

    // Initial branch starting from the bottom center
    branches.push({
        x: canvas.width / 2,
        y: canvas.height - 50,
        angle: -90,
        length: baseLength,
        depth: 0,
        maxDepth: 12
    });

    // Function to draw the tree recursively
    function draw() {
        var newBranches = [];

        branches.forEach(function(branch) {
            ctx.beginPath();
            ctx.moveTo(branch.x, branch.y);

            var endX = branch.x + branch.length * Math.cos(branch.angle * Math.PI / 180);
            var endY = branch.y + branch.length * Math.sin(branch.angle * Math.PI / 180);

            ctx.lineTo(endX, endY);

            ctx.strokeStyle = colors[branch.depth % colors.length];
            ctx.lineWidth = (branch.maxDepth - branch.depth + 1) * 1.2;
            ctx.stroke();

            // Generate new branches if depth allows
            if (branch.depth < branch.maxDepth) {
                var branchesNum = 2 + Math.round(Math.random() * 2); // Randomly 2 to 4 branches
                for (var i = 0; i < branchesNum; i++) {
                    var newAngle = branch.angle + Math.random() * angleVariation - angleVariation / 2;
                    var newLength = branch.length * (lengthVariation + Math.random() * (1 - lengthVariation));

                    newBranches.push({
                        x: endX,
                        y: endY,
                        angle: newAngle,
                        length: newLength,
                        depth: branch.depth + 1,
                        maxDepth: branch.maxDepth
                    });
                }
            } else {
                // Draw leaves at the end branches
                ctx.beginPath();
                ctx.arc(endX, endY, 5 + Math.random() * 5, 0, Math.PI * 2);
                ctx.fillStyle = colors[(branch.depth + 1) % colors.length];
                ctx.fill();
            }
        });

        branches = newBranches;

        // Continue drawing if there are new branches
        if (branches.length > 0 && branches.length < maxBranches) {
            requestAnimationFrame(draw);
        }
    }

    // Draw a gradient background
    var gradient = ctx.createRadialGradient(
        canvas.width / 2, canvas.height, 0,
        canvas.width / 2, canvas.height, canvas.height
    );
    gradient.addColorStop(0, '#000000');
    gradient.addColorStop(1, '#333333');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Start the tree drawing
    draw();

})();
"
"2428964","Celestial Whirl","sketch.js","(async function() {
  function loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  await loadScript('https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js');
  const THREE = await import('https://unpkg.com/three@0.152.0/build/three.module.js');
  new p5(p => {
    let scene, camera, renderer, galaxy;
    let mouseX = 0, mouseY = 0;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;
    p.setup = function() {
      p.createCanvas(p.windowWidth, p.windowHeight).hide();
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 4000);
      camera.position.z = 1000;
      renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      createGalaxy();
      document.addEventListener('mousemove', onDocumentMouseMove, false);
      window.addEventListener('resize', onWindowResize, false);
    };
    p.draw = function() {
      camera.position.x += (mouseX - camera.position.x) * 0.05;
      camera.position.y += (-mouseY - camera.position.y) * 0.05;
      camera.lookAt(scene.position);
      galaxy.rotation.y += 0.002;
      renderer.render(scene, camera);
    };
    function createGalaxy() {
      const particleCount = 50000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      const color = new THREE.Color();
      for (let i = 0; i < particleCount; i++) {
        const radius = Math.random() * 2000;
        const angle = Math.random() * Math.PI * 2;
        const spiralAngle = radius / 1000 * Math.PI * 4;
        const x = Math.cos(angle + spiralAngle) * radius;
        const y = (Math.random() - 0.5) * 200;
        const z = Math.sin(angle + spiralAngle) * radius;
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
        const vx = (x / 2000) + 0.5;
        const vy = (y / 2000) + 0.5;
        const vz = (z / 2000) + 0.5;
        color.setRGB(vx * 1.5, vy * 1.5, vz * 1.5);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
        sizes[i] = 5;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      const material = new THREE.PointsMaterial({
        size: 5,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      });
      galaxy = new THREE.Points(geometry, material);
      scene.add(galaxy);
    }
    function onDocumentMouseMove(event) {
      mouseX = (event.clientX - windowHalfX) * 2;
      mouseY = (event.clientY - windowHalfY) * 2;
    }
    function onWindowResize() {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      p.resizeCanvas(p.windowWidth, p.windowHeight);
    }
  });
})();
"
"2425522","Gravity Dance with Limits","mySketch","let stars = [];
let gravityPoints = [];
let numGravityPoints = 5;
let angleOffset = 0;

function setup() {
  createCanvas(800, 800);
  
  // Initialize stars
  for (let i = 0; i < 500; i++) {
    let angle = random(TWO_PI);
    let radius = sqrt(random(pow(width / 2, 2))) * 0.4;
    stars.push({
      position: createVector(random(-width / 2, width / 2), random(-height / 2, height / 2)),
      velocity: createVector(0, 0),
      colorOffset: random(100, 255),
      size: random(2, 5),
      speed: random(0.005, 0.01)
    });
  }
  
  // Initialize gravity points
  for (let i = 0; i < numGravityPoints; i++) {
    gravityPoints.push(createVector(random(-width / 2, width / 2), random(-height / 2, height / 2)));
  }
  noFill();
}

function draw() {
  background(5, 5, 15, 60); // Dark background for cosmic effect
  translate(width / 2, height / 2);
  
  // Update gravity point positions
  for (let i = 0; i < gravityPoints.length; i++) {
    gravityPoints[i].x += sin(angleOffset + i) * 2;
    gravityPoints[i].y += cos(angleOffset + i) * 2;
  }
  
  // Draw and update each star with gravity and boundary checks
  for (let i = 0; i < stars.length; i++) {
    let star = stars[i];
    
    // Calculate total gravitational force from all gravity points
    let totalForce = createVector(0, 0);
    for (let j = 0; j < gravityPoints.length; j++) {
      let force = p5.Vector.sub(gravityPoints[j], star.position);
      let distance = constrain(force.mag(), 50, 200);
      force.setMag(1 / (distance * 0.1));
      totalForce.add(force);
    }
    
    // Update position and velocity of the star
    star.velocity.add(totalForce);
    star.position.add(star.velocity);
    star.velocity.limit(2);
    
    // Check boundaries and make stars bounce
    if (star.position.x > width / 2 || star.position.x < -width / 2) {
      star.velocity.x *= -1;
    }
    if (star.position.y > height / 2 || star.position.y < -height / 2) {
      star.velocity.y *= -1;
    }

    // Draw the star
    let colorValue = star.colorOffset + sin(frameCount * star.speed) * 50;
    stroke(colorValue, 180, 255 - colorValue, 200);
    strokeWeight(star.size);
    point(star.position.x, star.position.y);

    // Add faint trailing line to emphasize movement
    stroke(255, 100);
    strokeWeight(0.5);
    line(star.position.x, star.position.y, star.position.x - star.velocity.x * 2, star.position.y - star.velocity.y * 2);
  }

  angleOffset += 0.005;
}
"
"2425521","Gravity Dance","mySketch","let stars = [];
let gravityPoints = [];
let numGravityPoints = 5;
let angleOffset = 0;

function setup() {
  createCanvas(800, 800);
  
  // Inicializa as estrelas
  for (let i = 0; i < 500; i++) {
    let angle = random(TWO_PI);
    let radius = sqrt(random(pow(width / 2, 2))) * 0.4;
    stars.push({
      position: createVector(random(-width / 2, width / 2), random(-height / 2, height / 2)),
      velocity: createVector(0, 0),
      colorOffset: random(100, 255),
      size: random(2, 5),
      speed: random(0.005, 0.01)
    });
  }
  
  // Inicializa os pontos de gravidade
  for (let i = 0; i < numGravityPoints; i++) {
    gravityPoints.push(createVector(random(-width / 2, width / 2), random(-height / 2, height / 2)));
  }
  noFill();
}

function draw() {
  background(5, 5, 15, 60); // Fundo escuro para efeito cósmico
  translate(width / 2, height / 2);
  
  // Atualiza a posição dos pontos de gravidade com um leve movimento
  for (let i = 0; i < gravityPoints.length; i++) {
    gravityPoints[i].x += sin(angleOffset + i) * 2;
    gravityPoints[i].y += cos(angleOffset + i) * 2;
  }
  
  // Desenha cada estrela e aplica forças gravitacionais
  for (let i = 0; i < stars.length; i++) {
    let star = stars[i];
    
    // Calcula a força gravitacional total exercida por todos os pontos de gravidade
    let totalForce = createVector(0, 0);
    for (let j = 0; j < gravityPoints.length; j++) {
      let force = p5.Vector.sub(gravityPoints[j], star.position);
      let distance = constrain(force.mag(), 50, 200); // Limita a influência gravitacional
      force.setMag(1 / (distance * 0.1));
      totalForce.add(force);
    }
    
    // Atualiza a posição e velocidade da estrela
    star.velocity.add(totalForce);
    star.position.add(star.velocity);
    star.velocity.limit(2); // Limita a velocidade para manter o efeito coeso

    // Desenha a estrela
    let colorValue = star.colorOffset + sin(frameCount * star.speed) * 50;
    stroke(colorValue, 180, 255 - colorValue, 200);
    strokeWeight(star.size);
    point(star.position.x, star.position.y);

    // Linhas finas para realçar o movimento de cada estrela
    stroke(255, 100);
    strokeWeight(0.5);
    line(star.position.x, star.position.y, star.position.x - star.velocity.x * 2, star.position.y - star.velocity.y * 2);
  }

  angleOffset += 0.005;
}
"
"2425517","Milky Way","mySketch","let stars = [];
let angleOffset = 0;

function setup() {
  createCanvas(800, 800);
  for (let i = 0; i < 1000; i++) {
    let angle = random(TWO_PI);
    let radius = sqrt(random(pow(width / 2, 2))) * 0.5;
    stars.push({
      position: createVector(radius * cos(angle), radius * sin(angle)),
      colorOffset: random(100, 255),
      speed: random(0.001, 0.003),
      orbitRadius: radius,
      angle: angle
    });
  }
  noFill();
}

function draw() {
  background(5, 5, 15, 50); // Fundo escuro e translúcido
  translate(width / 2, height / 2);
  rotate(angleOffset * 0.02);

  // Desenha cada estrela com sua própria trajetória de órbita e ""pulsações""
  for (let i = 0; i < stars.length; i++) {
    let star = stars[i];
    
    // Incrementa o ângulo para criar o movimento orbital
    star.angle += star.speed;
    
    // Atualiza a posição da estrela para girar em uma órbita espiral
    star.position.x = star.orbitRadius * cos(star.angle);
    star.position.y = star.orbitRadius * sin(star.angle);
    
    // Variações de cor e tamanho para simular brilho estelar
    let colorValue = (sin(star.angle * 5) * 50) + star.colorOffset;
    let starSize = map(sin(frameCount * star.speed), -1, 1, 2, 5);
    
    // Desenha estrela
    stroke(colorValue, 180, 255, 200);
    strokeWeight(starSize);
    point(star.position.x, star.position.y);
    
    // Efeito de cauda leve e translúcido para o movimento
    strokeWeight(1);
    stroke(255, 100);
    line(0, 0, star.position.x * 0.95, star.position.y * 0.95);
  }

  angleOffset += 0.002;
}
"
"2425513","Sorting Galaxy","mySketch","let values = [];
let stars = [];
let i = 0;
let j = 0;
let sortingAlgorithm = ""bubble""; // Alterna entre ""bubble"" e ""merge""
let mergeSteps = [];

function setup() {
  createCanvas(600, 600);
  for (let k = 0; k < 150; k++) {
    values.push(random(height / 2));
    stars.push(createVector(random(-width / 2, width / 2), random(-height / 2, height / 2)));
  }
  mergeSteps = mergeSort([...values]);
  noFill();
}

function draw() {
  background(5, 5, 15); // Fundo escuro como o espaço
  translate(width / 2, height / 2);
  
  if (sortingAlgorithm === ""bubble"") {
    bubbleSortStep();
  } else if (sortingAlgorithm === ""merge"") {
    mergeSortStep();
  }
  
  drawGalaxy();
}

function bubbleSortStep() {
  if (i < values.length) {
    if (j < values.length - i - 1) {
      if (values[j] > values[j + 1]) {
        [values[j], values[j + 1]] = [values[j + 1], values[j]];
      }
      j++;
    } else {
      j = 0;
      i++;
    }
  } else {
    sortingAlgorithm = ""merge"";
  }
}

function mergeSortStep() {
  if (mergeSteps.length > 0) {
    values = mergeSteps.shift();
  } else {
    sortingAlgorithm = ""done"";
  }
}

function drawGalaxy() {
  for (let k = 0; k < values.length; k++) {
    let angle = map(k, 0, values.length, 0, TWO_PI);
    let radius = map(values[k], 0, height / 2, 50, width / 2);
    let target = p5.Vector.fromAngle(angle).mult(radius);

    // Move stars smoothly toward their sorted positions
    stars[k].lerp(target, 0.05);

    // Draw stars as bright points
    let colorValue = map(values[k], 0, height / 2, 100, 255);
    stroke(colorValue, colorValue * 0.8, 255, 200);
    strokeWeight(3);
    point(stars[k].x, stars[k].y);

    // Trailing effect for movement
    strokeWeight(1);
    line(0, 0, stars[k].x, stars[k].y);
  }
}

function mergeSort(arr) {
  if (arr.length <= 1) return [arr];
  let mid = Math.floor(arr.length / 2);
  let left = mergeSort(arr.slice(0, mid));
  let right = mergeSort(arr.slice(mid));
  return mergeSteps.concat(merge(left[0], right[0]));
}

function merge(left, right) {
  let result = [];
  let steps = [];
  while (left.length && right.length) {
    if (left[0] < right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
    steps.push([...result, ...left, ...right]);
  }
  return steps.concat([result.concat(left).concat(right)]);
}
"
"2425512","Radial Sorting Waves","mySketch","let values = [];
let i = 0;
let j = 0;
let sortingAlgorithm = ""bubble""; // Alterna entre ""bubble"" e ""merge""
let mergeSteps = [];
let angleOffset = 0;

function setup() {
  createCanvas(600, 600);
  for (let k = 0; k < 200; k++) {
    values.push(random(height / 2));
  }
  mergeSteps = mergeSort([...values]);
  noFill();
}

function draw() {
  background(20, 20, 30, 50); // Fundo escuro e translúcido para suavidade
  translate(width / 2, height / 2);
  if (sortingAlgorithm === ""bubble"") {
    bubbleSortStep();
  } else if (sortingAlgorithm === ""merge"") {
    mergeSortStep();
  }
  drawRadialWaves();
  angleOffset += 0.02;
}

function bubbleSortStep() {
  if (i < values.length) {
    if (j < values.length - i - 1) {
      if (values[j] > values[j + 1]) {
        [values[j], values[j + 1]] = [values[j + 1], values[j]];
      }
      j++;
    } else {
      j = 0;
      i++;
    }
  } else {
    sortingAlgorithm = ""merge"";
  }
}

function mergeSortStep() {
  if (mergeSteps.length > 0) {
    values = mergeSteps.shift();
  } else {
    sortingAlgorithm = ""done"";
  }
}

function drawRadialWaves() {
  for (let k = 0; k < values.length; k++) {
    let angle = angleOffset + k * 0.1;
    let radius = map(values[k], 0, height / 2, 50, width / 2);
    let waveHeight = map(values[k], 0, height / 2, 5, 50);
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    let colorValue = map(k, 0, values.length, 0, 255);
    stroke(colorValue, 200, 255 - colorValue, 150);
    strokeWeight(2);
    line(0, 0, x, y); // Linhas que irradiam do centro, variando em comprimento
  }
}

function mergeSort(arr) {
  if (arr.length <= 1) return [arr];
  let mid = Math.floor(arr.length / 2);
  let left = mergeSort(arr.slice(0, mid));
  let right = mergeSort(arr.slice(mid));
  return mergeSteps.concat(merge(left[0], right[0]));
}

function merge(left, right) {
  let result = [];
  let steps = [];
  while (left.length && right.length) {
    if (left[0] < right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
    steps.push([...result, ...left, ...right]);
  }
  return steps.concat([result.concat(left).concat(right)]);
}
"
"2425508","Sorting Spirals","mySketch","let values = [];
let i = 0;
let j = 0;
let sortingAlgorithm = ""bubble""; // Alterna entre ""bubble"" e ""merge""
let mergeSteps = [];
let angleOffset = 0;

function setup() {
  createCanvas(600, 600);
  for (let k = 0; k < 100; k++) {
    values.push(random(height / 2));
  }
  mergeSteps = mergeSort([...values]);
  noStroke();
}

function draw() {
  background(10, 10, 30, 50); // Fundo mais escuro e translúcido
  translate(width / 2, height / 2);
  if (sortingAlgorithm === ""bubble"") {
    bubbleSortStep();
  } else if (sortingAlgorithm === ""merge"") {
    mergeSortStep();
  }
  drawSpiralBars();
  angleOffset += 0.02;
}

function bubbleSortStep() {
  if (i < values.length) {
    if (j < values.length - i - 1) {
      if (values[j] > values[j + 1]) {
        [values[j], values[j + 1]] = [values[j + 1], values[j]];
      }
      j++;
    } else {
      j = 0;
      i++;
    }
  } else {
    sortingAlgorithm = ""merge"";
  }
}

function mergeSortStep() {
  if (mergeSteps.length > 0) {
    values = mergeSteps.shift();
  } else {
    sortingAlgorithm = ""done"";
  }
}

function drawSpiralBars() {
  for (let k = 0; k < values.length; k++) {
    let angle = angleOffset + k * 0.1;
    let radius = map(values[k], 0, height / 2, 50, width / 2);
    let barHeight = map(values[k], 0, height / 2, 5, 20);
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    let colorValue = map(k, 0, values.length, 0, 255);
    fill(colorValue, 200, 255 - colorValue, 180);
    push();
    translate(x, y);
    rotate(angle);
    rect(0, 0, barHeight, 8); // Desenha barras mais espessas
    pop();
  }
}

function mergeSort(arr) {
  if (arr.length <= 1) return [arr];
  let mid = Math.floor(arr.length / 2);
  let left = mergeSort(arr.slice(0, mid));
  let right = mergeSort(arr.slice(mid));
  return mergeSteps.concat(merge(left[0], right[0]));
}

function merge(left, right) {
  let result = [];
  let steps = [];
  while (left.length && right.length) {
    if (left[0] < right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
    steps.push([...result, ...left, ...right]);
  }
  return steps.concat([result.concat(left).concat(right)]);
}
"
"2423528","Jump Scare","mySketch","// ""Jump Scare"" 😱 #WCCChallenge
// by Gonçalo Perdigão, Building  Creative Machines

let shapes = [];
let currentShapeIndex = 0;
let particleShapes = [];
let disintegrate = false;
let interactionCount = 0;
let jumpScare = false;
let scareTime;

function setup() {
  createCanvas(800, 600);
  background(20);
  noStroke();
  scareTime = millis() + 20000; // Jump scare after 20 seconds

  // Create particle shapes
  createParticleShapes();

  // Start with the first shape
  shapes.push(new Shape(particleShapes[currentShapeIndex]));
}

function draw() {
  background(20);

  if (!jumpScare) {
    // Update and display shapes
    for (let s of shapes) {
      s.update();
      s.display();
    }

    // Check for disintegration
    for (let s of shapes) {
      s.checkDisintegration();
    }

    // Remove shapes that have completed reintegration
    shapes = shapes.filter(s => !s.isFinished());

    // If no shapes are left, create the next shape
    if (shapes.length === 0 && !disintegrate) {
      currentShapeIndex = (currentShapeIndex + 1) % particleShapes.length;
      shapes.push(new Shape(particleShapes[currentShapeIndex]));
    }

    // Trigger jump scare after interactions or time
    if (interactionCount >= 30 || millis() > scareTime) {
      jumpScare = true;
    }
  } else {
    // Display jump scare
    drawScaryFace();
  }
}

function createParticleShapes() {
  // Create off-screen graphics to draw shapes
  let ghostGfx = createGraphics(200, 200);
  ghostGfx.noStroke();
  ghostGfx.fill(255);
  ghostGfx.beginShape();
  ghostGfx.vertex(100, 20);
  ghostGfx.bezierVertex(150, 20, 180, 80, 100, 180);
  ghostGfx.bezierVertex(20, 80, 50, 20, 100, 20);
  ghostGfx.endShape(CLOSE);
  // Eyes
  ghostGfx.fill(0);
  ghostGfx.ellipse(80, 80, 20, 30);
  ghostGfx.ellipse(120, 80, 20, 30);

  let batGfx = createGraphics(200, 200);
  batGfx.noStroke();
  batGfx.fill(150, 0, 150);
  batGfx.beginShape();
  batGfx.vertex(100, 50);
  batGfx.vertex(130, 80);
  batGfx.vertex(160, 50);
  batGfx.vertex(190, 80);
  batGfx.vertex(160, 110);
  batGfx.vertex(190, 140);
  batGfx.vertex(160, 170);
  batGfx.vertex(130, 140);
  batGfx.vertex(100, 170);
  batGfx.vertex(70, 140);
  batGfx.vertex(40, 170);
  batGfx.vertex(10, 140);
  batGfx.vertex(40, 110);
  batGfx.vertex(10, 80);
  batGfx.vertex(40, 50);
  batGfx.vertex(70, 80);
  batGfx.endShape(CLOSE);

  let pumpkinGfx = createGraphics(200, 200);
  pumpkinGfx.noStroke();
  pumpkinGfx.fill(255, 140, 0);
  pumpkinGfx.ellipse(100, 100, 150, 150);
  // Stem
  pumpkinGfx.fill(139, 69, 19);
  pumpkinGfx.rect(90, 40, 20, 30);
  // Eyes
  pumpkinGfx.fill(0);
  pumpkinGfx.triangle(70, 80, 85, 60, 100, 80);
  pumpkinGfx.triangle(100, 80, 115, 60, 130, 80);
  // Mouth
  pumpkinGfx.rect(70, 120, 60, 20);

  // Create particle arrays from graphics
  particleShapes.push(getParticlesFromGraphics(ghostGfx));
  particleShapes.push(getParticlesFromGraphics(batGfx));
  particleShapes.push(getParticlesFromGraphics(pumpkinGfx));
}

function getParticlesFromGraphics(gfx) {
  let particles = [];
  gfx.loadPixels();
  for (let x = 0; x < gfx.width; x += 4) {
    for (let y = 0; y < gfx.height; y += 4) {
      let index = (x + y * gfx.width) * 4;
      let alpha = gfx.pixels[index + 3];
      if (alpha > 128) {
        let col = color(
          gfx.pixels[index],
          gfx.pixels[index + 1],
          gfx.pixels[index + 2],
          alpha
        );
        let pos = createVector(x, y);
        particles.push(new Particle(pos, col));
      }
    }
  }
  return particles;
}

class Shape {
  constructor(particles) {
    this.particles = particles.map(p => p.copy());
    this.position = createVector(random(100, width - 300), random(100, height - 300));
    this.velocity = p5.Vector.random2D().mult(random(1, 2));
    this.disintegrate = false;
    this.reintegrateTimer = 0;
    this.finished = false;
  }

  update() {
    if (!this.disintegrate) {
      this.position.add(this.velocity);
      // Bounce off edges
      if (this.position.x < 0 || this.position.x > width - 200) {
        this.velocity.x *= -1;
      }
      if (this.position.y < 0 || this.position.y > height - 200) {
        this.velocity.y *= -1;
      }
    }

    for (let p of this.particles) {
      p.update(this.position, this.disintegrate);
    }
  }

  display() {
    for (let p of this.particles) {
      p.show();
    }
  }

  checkDisintegration() {
    let d = dist(mouseX, mouseY, this.position.x + 100, this.position.y + 100);
    if (d < 100 && !this.disintegrate) {
      this.disintegrate = true;
      interactionCount++;
      for (let p of this.particles) {
        let force = p5.Vector.sub(p.pos, createVector(mouseX, mouseY));
        force.setMag(random(2, 5));
        p.applyForce(force);
      }
      // Schedule reintegration
      this.reintegrateTimer = millis() + 2000;
    }
    if (this.disintegrate && millis() > this.reintegrateTimer) {
      this.disintegrate = false;
      // Move shape near mouse position
      this.position = createVector(mouseX - 100, mouseY - 100);
      for (let p of this.particles) {
        p.reset(this.position);
      }
      if (interactionCount >= 3) {
        this.finished = true;
      }
    }
  }

  isFinished() {
    return this.finished;
  }
}

class Particle {
  constructor(pos, col) {
    this.home = pos.copy();
    this.pos = pos.copy();
    this.vel = p5.Vector.random2D();
    this.acc = createVector(0, 0);
    this.col = col;
  }

  copy() {
    return new Particle(this.home, this.col);
  }

  applyForce(force) {
    this.acc.add(force);
  }

  update(shapePos, disintegrate) {
    if (!disintegrate) {
      let target = p5.Vector.add(shapePos, this.home);
      let force = p5.Vector.sub(target, this.pos);
      force.mult(0.2);
      this.applyForce(force);
    } else {
      // Apply gravity effect if needed
    }
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
    this.vel.mult(0.95); // Friction
  }

  reset(shapePos) {
    this.pos = p5.Vector.add(shapePos, this.home);
    this.vel = p5.Vector.random2D();
    this.acc = createVector(0, 0);
  }

  show() {
    fill(this.col);
    ellipse(this.pos.x, this.pos.y, 4, 4);
  }
}

function drawScaryFace() {
  background(0);
  fill(255, 0, 0);
  textSize(100);
  textAlign(CENTER, CENTER);
  text('BOO!', width / 2, height / 2);
}
"
"2420395","Particle Word Star","mySketch","let word = ""Hello""; // Default word
let wordParticles = [];
let starParticles = [];
let input;
let pg; // Graphics buffer for word

// Star parameters
const STAR_POINTS = 5; // Number of star points
const OUTER_RADIUS = 200;
const INNER_RADIUS = 100;
const STAR_DENSITY = 10; // Distance between star particles

// Rotation parameters
const ROTATION_THRESHOLD = 100; // Distance threshold for rotation
const ROTATION_SPEED = 0.05; // Rotation speed for particles

function setup() {
  createCanvas(800, 800);
  background(0);

  // Create input field for the word
  input = createInput(word);
  input.position(10, height + 10);
  input.size(200);
  input.input(updateWord);

  // Create a graphics buffer for the word
  pg = createGraphics(width, height);
  pg.pixelDensity(1); // Ensure consistent pixel density

  // Generate particles for both word and star
  createParticles();
}

function createParticles() {
  wordParticles = [];
  starParticles = [];

  // Generate word particles
  generateWordParticles();

  // Generate star particles
  generateStarParticles();
}

function generateWordParticles() {
  // Clear the graphics buffer
  pg.clear();
  pg.background(0);

  // Set text properties
  pg.textSize(200);
  pg.textAlign(CENTER, CENTER);
  pg.fill(255);
  pg.noStroke();

  // Draw the text onto the graphics buffer
  pg.text(word, width / 2, height / 2);

  // Load the pixel data from the graphics buffer
  pg.loadPixels();

  // Iterate over the pixels to find where the text is
  let density = 8; // Adjust for particle density (lower is denser)
  for (let y = 0; y < pg.height; y += density) {
    for (let x = 0; x < pg.width; x += density) {
      let index = (x + y * pg.width) * 4;
      let r = pg.pixels[index];
      // If the pixel is white (part of the text)
      if (r > 128) { // Threshold can be adjusted
        // Center the word
        let px = x - width / 2;
        let py = y - height / 2;
        wordParticles.push(new Particle(px, py));
      }
    }
  }
}

function generateStarParticles() {
  // Generate star points
  let points = generateStarPoints(0, 0, OUTER_RADIUS, INNER_RADIUS, STAR_POINTS, STAR_DENSITY);

  // Create particles for each star point
  for (let pt of points) {
    starParticles.push(new Particle(pt.x, pt.y));
  }
}

function generateStarPoints(centerX, centerY, outerR, innerR, nPoints, density) {
  let angleStep = TWO_PI / (nPoints * 2);
  let points = [];

  // Calculate the vertices of the star
  for (let i = 0; i < nPoints * 2; i++) {
    let r = (i % 2 === 0) ? outerR : innerR;
    let x = centerX + r * cos(i * angleStep - HALF_PI);
    let y = centerY + r * sin(i * angleStep - HALF_PI);
    points.push(createVector(x, y));
  }

  let sampledPoints = [];

  // Sample points along the star's edges
  for (let i = 0; i < points.length; i++) {
    let start = points[i];
    let end = points[(i + 2) % points.length]; // Connect every other point to form a star

    let totalDist = p5.Vector.dist(start, end);
    let steps = floor(totalDist / density);

    for (let j = 0; j < steps; j++) {
      let t = j / steps;
      let x = lerp(start.x, end.x, t);
      let y = lerp(start.y, end.y, t);
      sampledPoints.push(createVector(x, y));
    }
  }

  return sampledPoints;
}

function updateWord() {
  word = this.value();
  createParticles();
}

function draw() {
  background(0, 20); // Semi-transparent background for trailing effect
  translate(width / 2, height / 2);

  // Calculate mouse position relative to center
  let mouseRelX = mouseX - width / 2;
  let mouseRelY = mouseY - height / 2;

  // Display word particles
  for (let p of wordParticles) {
    p.update(mouseRelX, mouseRelY);
    p.show();
  }

  // Display star particles
  for (let p of starParticles) {
    p.update(mouseRelX, mouseRelY);
    p.show();
  }
}

class Particle {
  constructor(x, y) {
    this.origin = createVector(x, y); // Fixed position
    this.pos = this.origin.copy(); // Current position
    this.size = random(1, 3); // Particle size
    this.rotationAngle = 0; // Current rotation angle
  }

  update(mouseX, mouseY) {
    // Calculate distance from particle to mouse
    let distance = dist(this.origin.x, this.origin.y, mouseX, mouseY);

    if (distance < ROTATION_THRESHOLD) {
      // Rotate the particle around its origin
      this.rotationAngle += ROTATION_SPEED;
      let r = 20; // Radius of rotation around origin
      this.pos.x = this.origin.x + r * cos(this.rotationAngle);
      this.pos.y = this.origin.y + r * sin(this.rotationAngle);
    } else {
      // Reset to origin if not near mouse
      this.pos = this.origin.copy();
      this.rotationAngle = 0;
    }
  }

  show() {
    stroke(255);
    strokeWeight(this.size);
    point(this.pos.x, this.pos.y);
  }
}
"
"2420380","TextSpark","mySketch","let particles = [];
let userInput = ""Reality"";
let fontSize = 128;
let pg; // Graphics buffer for text
let step = 3; // Step size for pixel sampling
let hueShift = 0;
let mic, fft;

function preload() {
  // Preload fonts if adding multiple fonts
  // fonts.push(loadFont('assets/Arial.ttf'));
}

function setup() {
  createCanvas(800, 400);
  colorMode(HSB, 360, 100, 100, 100);
  noStroke();

  // Create and configure the text graphics buffer
  pg = createGraphics(width, height);
  pg.pixelDensity(1);
  pg.textAlign(CENTER, CENTER);
  pg.textSize(fontSize);
  pg.colorMode(HSB, 360, 100, 100, 100);
  pg.background(0, 0, 0, 0);
  pg.fill(0, 0, 0, 100);
  
  // Initialize audio
  mic = new p5.AudioIn();
  mic.start();
  fft = new p5.FFT();
  fft.setInput(mic);

  // Input for user text
  let textInput = createInput(userInput);
  textInput.position(10, height + 10);
  textInput.size(200);
  textInput.input(updateUserText);

  generateParticles();
}

function draw() {
	// Animated Gradient Background
  for (let y = 0; y < height; y++) {
    let inter = map(y, 0, height, 0, 1);
    let c = lerpColor(color(200, 50, 100), color(300, 50, 100), inter);
    stroke(c);
    line(0, y, width, y);
  }

  // Optionally, add audio-reactive background elements here

  // Update and display particles
  let spectrum = fft.analyze();
  let bass = fft.getEnergy(""bass"");
  hueShift = (hueShift + 0.5) % 360;

  for (let p of particles) {
    p.behaviors(bass, hueShift);
    p.update();
    p.show();
  }
}

function updateUserText() {
  userInput = this.value();
  generateParticles();
}

function generateParticles() {
  particles = [];
  pg.clear();

  // Render the text centered horizontally and vertically
  pg.background(0, 0, 0, 0);
  pg.textAlign(CENTER, CENTER);
  pg.textSize(fontSize);
  pg.fill(0, 0, 0, 100);
  pg.text(userInput, width / 2, height / 2);

  pg.loadPixels();

  // Iterate through pixels with the specified step size
  for (let x = 0; x < pg.width; x += step) {
    for (let y = 0; y < pg.height; y += step) {
      let index = (x + y * pg.width) * 4;
      // Check if the pixel is not transparent (alpha > 128)
      if (pg.pixels[index + 3] > 128) {
        let posX = x;
        let posY = y;
        let particle = new Particle(posX, posY);
        particles.push(particle);
      }
    }
  }

  pg.updatePixels();
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(random(width), random(height));
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 5;
    this.maxForce = 0.5;
    this.size = random(2, 5);
	}
		show() {
    let noiseVal = noise(this.pos.x * 0.01, this.pos.y * 0.01);
    stroke((noiseVal * 360 + hueShift) % 360, 80, 100, 80);
    strokeWeight(this.size);
    point(this.pos.x, this.pos.y);
  	}

  behaviors(bass, hueShift) {
    let arrive = this.arrive(this.target);
    let gravity = createVector(0, 0.05 * (1 + bass / 255));
    let mouse = createVector(mouseX, mouseY);
    let flee = this.flee(mouse);

    arrive.mult(1);
    flee.mult(5);
    gravity.mult(1);

    this.applyForce(arrive);
    this.applyForce(flee);
    this.applyForce(gravity);
  }

  applyForce(f) {
    this.acc.add(f);
  }

  update() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);

    // Wrap around edges
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }

  show() {
    stroke((hueShift + this.pos.x / width * 360) % 360, 80, 100, 80);
    strokeWeight(this.size);
    point(this.pos.x, this.pos.y);
  }

  arrive(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);
    return steer;
  }

  flee(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    if (d < 50) {
      desired.setMag(this.maxSpeed);
      desired.mult(-1);
      let steer = p5.Vector.sub(desired, this.vel);
      steer.limit(this.maxForce);
      return steer;
    } else {
      return createVector(0, 0);
    }
  }
}
"
"2420338","Words in particles","mySketch","let particles = [];
let userInput = ""Building"";
let fontSize = 128;
let pg; // Graphics buffer for text
let step = 3; // Step size for pixel sampling (adjust for density)

function setup() {
  createCanvas(800, 400);
  fill(0);
  noStroke();

  // Create and configure the text graphics buffer
  pg = createGraphics(width, height);
  pg.pixelDensity(1);
  pg.textAlign(CENTER, CENTER);
  pg.textSize(fontSize);
  pg.fill(0);
  pg.noStroke();

  // Input for user text
  let textInput = createInput(userInput);
  textInput.position(10, height + 10);
  textInput.size(200);
  textInput.input(updateUserText);

  generateParticles();
}

function draw() {
  background(255);

  // Update and display particles
  for (let p of particles) {
    p.behaviors();
    p.update();
    p.show();
  }
}

function updateUserText() {
  userInput = this.value();
  generateParticles();
}

function generateParticles() {
  particles = [];

  // Clear the graphics buffer
  pg.clear();

  // Calculate vertical centering
  let yOffset = height / 2;
  
  // Render the text centered horizontally and vertically
  pg.textAlign(CENTER, CENTER);
  pg.text(userInput, width / 2, yOffset);

  pg.loadPixels();

  // Iterate through pixels with the specified step size
  for (let x = 0; x < pg.width; x += step) {
    for (let y = 0; y < pg.height; y += step) {
      let index = (x + y * pg.width) * 4;
      // Check if the pixel is not transparent (alpha > 128 for better visibility)
      if (pg.pixels[index + 3] > 128) {
        let posX = x;
        let posY = y;
        let particle = new Particle(posX, posY);
        particles.push(particle);
      }
    }
  }

  pg.updatePixels();
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(random(width), random(height));
    this.target = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.acc = createVector();
    this.maxSpeed = 10;
    this.maxForce = 1;
  }

  behaviors() {
    let arrive = this.arrive(this.target);
    let mouse = createVector(mouseX, mouseY);
    let flee = this.flee(mouse);

    arrive.mult(1);
    flee.mult(5);

    this.applyForce(arrive);
    this.applyForce(flee);
  }

  applyForce(f) {
    this.acc.add(f);
  }

  update() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  show() {
    stroke(0);
    strokeWeight(2);
    point(this.pos.x, this.pos.y);
  }

  arrive(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    let speed = this.maxSpeed;
    if (d < 100) {
      speed = map(d, 0, 100, 0, this.maxSpeed);
    }
    desired.setMag(speed);
    let steer = p5.Vector.sub(desired, this.vel);
    steer.limit(this.maxForce);
    return steer;
  }

  flee(target) {
    let desired = p5.Vector.sub(target, this.pos);
    let d = desired.mag();
    if (d < 50) {
      desired.setMag(this.maxSpeed);
      desired.mult(-1);
      let steer = p5.Vector.sub(desired, this.vel);
      steer.limit(this.maxForce);
      return steer;
    } else {
      return createVector(0, 0);
    }
  }
}
"
"2420310","Bezier Curve","mySketch","let points = [];
let draggingPoint = null;

function setup() {
  createCanvas(600, 600);
  background(255);

  // Initialize control points for a basic Bezier curve
  points.push(createVector(100, height - 100)); // Start point
  points.push(createVector(200, 100)); // Control point 1
  points.push(createVector(400, 500)); // Control point 2
  points.push(createVector(width - 100, 100)); // End point
}

function draw() {
  background(255);
  stroke(0);
  strokeWeight(1);
  noFill();

  // Draw Bezier curve based on control points
  beginShape();
  vertex(points[0].x, points[0].y);
  bezierVertex(points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y);
  endShape();

  // Draw lines connecting control points for clarity
  stroke(200);
  line(points[0].x, points[0].y, points[1].x, points[1].y);
  line(points[2].x, points[2].y, points[3].x, points[3].y);

  // Draw control points
  fill(0);
  noStroke();
  for (let i = 0; i < points.length; i++) {
    ellipse(points[i].x, points[i].y, 10, 10);
  }
}

function mousePressed() {
  // Check if mouse is close to any point to enable dragging
  for (let pt of points) {
    if (dist(mouseX, mouseY, pt.x, pt.y) < 10) {
      draggingPoint = pt;
      break;
    }
  }
}

function mouseDragged() {
  // Move the selected point with the mouse
  if (draggingPoint) {
    draggingPoint.x = mouseX;
    draggingPoint.y = mouseY;
  }
}

function mouseReleased() {
  draggingPoint = null;
}
"
"2420305","Random Walkers","mySketch","let walkers = [];

function setup() {
  createCanvas(600, 600);
  background(255);
  noStroke();
  
  // Initialize multiple random walkers with random colors and positions
  for (let i = 0; i < 200; i++) {
    walkers.push(new Walker(random(width), random(height), color(random(255), random(255), random(255), 100)));
  }
}

function draw() {
  // Update and display each walker
  for (let walker of walkers) {
    walker.update();
    walker.display();
  }
}

// Walker class
class Walker {
  constructor(x, y, col) {
    this.pos = createVector(x, y);
    this.col = col;
  }

  update() {
    // Random movement with a slight bias to create organic flow
    let step = p5.Vector.random2D();
    step.mult(random(0.5, 2));
    this.pos.add(step);

    // Wrap edges
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.y < 0) this.pos.y = height;
    if (this.pos.y > height) this.pos.y = 0;
  }

  display() {
    fill(this.col);
    ellipse(this.pos.x, this.pos.y, 2, 2);
  }
}
"
"2418415","Sun, Earth and Moon","mySketch","let sunPos;
let earthAngle = 0;
let moonAngle = 0;
let earthOrbitRadiusX;
let earthOrbitRadiusY;
let moonOrbitRadius;
let sunSize;
let earthSize;
let moonSize;
let stars = [];
let textSizeValue;

function setup() {
  createCanvas(windowWidth, windowHeight);
  sunPos = createVector(width / 2, height / 2);

  // Set Earth's orbit as an ellipse
  earthOrbitRadiusX = min(width, height) * 0.35; // Major axis
  earthOrbitRadiusY = earthOrbitRadiusX * 0.9;  // Minor axis

  moonOrbitRadius = earthOrbitRadiusX * 0.1;

  sunSize = min(width, height) * 0.1;
  earthSize = sunSize * 0.2;
  moonSize = earthSize * 0.5;

  textSizeValue = min(width, height) * 0.02;

  // Generate stars for the background
  for (let i = 0; i < 200; i++) {
    stars.push({
      x: random(width),
      y: random(height),
      size: random(1, 3)
    });
  }
}

function draw() {
  background(0);

  // Draw stars
  noStroke();
  fill(255);
  for (let star of stars) {
    ellipse(star.x, star.y, star.size);
  }

  // Update angles for Earth's and Moon's orbits
  let time = millis() / 1000;
  earthAngle = time * 0.5;
  moonAngle = time * 5;

  // Calculate Earth's elliptical position
  let earthX = sunPos.x + earthOrbitRadiusX * cos(earthAngle);
  let earthY = sunPos.y + earthOrbitRadiusY * sin(earthAngle);
  let moonX = earthX + moonOrbitRadius * cos(moonAngle);
  let moonY = earthY + moonOrbitRadius * sin(moonAngle);

  // Draw Earth's elliptical orbit with dashed lines
  noFill();
  stroke(255, 255, 0, 100);
  strokeWeight(1);
  drawingContext.setLineDash([5, 15]);
  ellipse(sunPos.x, sunPos.y, earthOrbitRadiusX * 2, earthOrbitRadiusY * 2);
  stroke(0, 0, 255, 100);
  ellipse(earthX, earthY, moonOrbitRadius * 2);
  drawingContext.setLineDash([]);

  // Draw the Sun with a radial gradient
  let ctx = drawingContext;
  let gradient = ctx.createRadialGradient(
    sunPos.x, sunPos.y, 0,
    sunPos.x, sunPos.y, sunSize / 2
  );
  gradient.addColorStop(0, 'yellow');
  gradient.addColorStop(0.5, 'orange');
  gradient.addColorStop(1, 'red');
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(sunPos.x, sunPos.y, sunSize / 2, 0, TWO_PI);
  ctx.fill();
  ctx.fillStyle = null;

  // Draw Earth and Moon
  fill(0, 102, 204);
  noStroke();
  ellipse(earthX, earthY, earthSize);
  fill(200);
  ellipse(moonX, moonY, moonSize);

  // Add labels
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(textSizeValue);
  text('Sun', sunPos.x, sunPos.y - sunSize / 2 - textSizeValue);
  text('Earth', earthX, earthY - earthSize / 2 - textSizeValue);
  text('Moon', moonX, moonY - moonSize / 2 - textSizeValue);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  sunPos.set(width / 2, height / 2);

  // Recalculate scales on window resize
  earthOrbitRadiusX = min(width, height) * 0.35; // Major axis
  earthOrbitRadiusY = earthOrbitRadiusX * 0.9;   // Minor axis
  moonOrbitRadius = earthOrbitRadiusX * 0.1;

  sunSize = min(width, height) * 0.1;
  earthSize = sunSize * 0.2;
  moonSize = earthSize * 0.5;

  textSizeValue = min(width, height) * 0.02;

  // Regenerate stars for the new window size
  stars = [];
  for (let i = 0; i < 200; i++) {
    stars.push({
      x: random(width),
      y: random(height),
      size: random(1, 3)
    });
  }
}
"
"2418391","Mechanical Harmony","mySketch","let gears = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  stroke(0);
  noFill();

  // Create the main gear
  let mainGear = new Gear(width / 2, height / 2, 80, 40);
  mainGear.angularVelocity = 0.005;

  // Create gears around the main gear at different angles
  let angles = [0, PI / 3, (2 * PI) / 3, PI, (4 * PI) / 3, (5 * PI) / 3];
  let radii = [30, 40, 50, 30, 40, 50];

  for (let i = 0; i < angles.length; i++) {
    let angle = angles[i];
    let radius = radii[i];
    let x = mainGear.x + (mainGear.radius + radius) * cos(angle);
    let y = mainGear.y + (mainGear.radius + radius) * sin(angle);
    let numTeeth = Math.floor(radius / 2);
    let gear = new Gear(x, y, radius, numTeeth);
    mainGear.connectTo(gear);
    gears.push(gear);
  }

  gears.push(mainGear);
}

function draw() {
  background(255);
  let visited = new Set();
  gears[gears.length - 1].update(visited); // Start updating from the main gear
  for (let gear of gears) {
    gear.draw();
  }
}

class Gear {
  constructor(x, y, radius, numTeeth, initialAngle) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.numTeeth = numTeeth;
    this.angle = initialAngle || 0;
    this.angularVelocity = 0;
    this.connections = [];
  }

  connectTo(otherGear) {
    // Calculate position to ensure gears touch
    let dx = otherGear.x - this.x;
    let dy = otherGear.y - this.y;
    let angleBetween = atan2(dy, dx);
    otherGear.x = this.x + (this.radius + otherGear.radius) * cos(angleBetween);
    otherGear.y = this.y + (this.radius + otherGear.radius) * sin(angleBetween);
    this.connections.push(otherGear);
  }

  update(visited) {
    if (!visited) {
      visited = new Set();
    }
    if (visited.has(this)) return;
    visited.add(this);
    this.angle += this.angularVelocity;
    for (let otherGear of this.connections) {
      otherGear.angularVelocity =
        -this.angularVelocity * (this.radius / otherGear.radius);
      otherGear.update(visited);
    }
  }

  draw() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);
    stroke(0);
    noFill();
    beginShape();
    let teeth = this.numTeeth;
    let rOuter = this.radius;
    let rInner = this.radius * 0.8;
    let angleStep = TWO_PI / (teeth * 2);
    for (let i = 0; i < teeth * 2; i++) {
      let r = i % 2 === 0 ? rOuter : rInner;
      let a = i * angleStep;
      vertex(r * cos(a), r * sin(a));
    }
    endShape(CLOSE);
    pop();
  }
}
"
"2417370","Click & Shift Tiles","mySketch","const Engine = Matter.Engine,
      World = Matter.World,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      Runner = Matter.Runner;

// Variables
let engine;
let world;
let runner;

let tileSize = 80;
let gridCols, gridRows;
let tiles = [];
let walls = [];
let balls = [];
let palette = ['#FF6347', '#4682B4', '#9ACD32', '#FFD700'];
let ballGenerationInterval;

// Setup function
function setup() {
  createCanvas(windowWidth, windowHeight);
  
  // Initialize Matter.js engine and world
  engine = Engine.create();
  world = engine.world;
  engine.gravity.y = 1; // Adjust gravity as needed
  
  // Initialize Runner
  runner = Runner.create();
  Runner.run(runner, engine);
  
  // Calculate grid size
  gridCols = floor(width / tileSize);
  gridRows = floor(height / tileSize);
  
  // Create boundary walls
  let boundaryOptions = { isStatic: true, restitution: 0.5 };
  World.add(world, [
    Bodies.rectangle(width / 2, -25, width, 50, boundaryOptions), // Top
    Bodies.rectangle(width / 2, height + 25, width, 50, boundaryOptions), // Bottom
    Bodies.rectangle(-25, height / 2, 50, height, boundaryOptions), // Left
    Bodies.rectangle(width + 25, height / 2, 50, height, boundaryOptions) // Right
  ]);
  
  // Generate tiles and walls
  for (let i = 0; i < gridCols; i++) {
    tiles[i] = [];
    for (let j = 0; j < gridRows; j++) {
      let x = i * tileSize + tileSize / 2;
      let y = j * tileSize + tileSize / 2;
      let type = random(['A', 'B', 'C']);
      let rotation = floor(random(4)) * HALF_PI;
      tiles[i][j] = { type, rotation, x, y, walls: [] };
      createTileWalls(i, j);
    }
  }
  
  // Start ball generation at 10 per second
  ballGenerationInterval = setInterval(generateBall, 100); // 100ms interval
}

// Draw function
function draw() {
  background(240);
  
  // Draw tiles
  for (let i = 0; i < gridCols; i++) {
    for (let j = 0; j < gridRows; j++) {
      let tile = tiles[i][j];
      push();
      translate(tile.x, tile.y);
      rotate(tile.rotation);
      drawTile(tile.type, tileSize);
      pop();
    }
  }
  
  // Draw balls
  noStroke();
  for (let i = balls.length -1; i >=0; i--) {
    let ball = balls[i];
    fill(ball.color);
    ellipse(ball.body.position.x, ball.body.position.y, ball.radius * 2);
    
    // Remove balls that reach the bottom
    if (ball.body.position.y > height + 20) {
      World.remove(world, ball.body);
      balls.splice(i, 1);
    }
  }
}

// Function to draw a single tile
function drawTile(type, size) {
  stroke(0);
  strokeWeight(2);
  noFill();
  
  switch(type) {
    case 'A':
      // Cross lines
      line(-size/2, -size/2, size/2, size/2);
      line(-size/2, size/2, size/2, -size/2);
      break;
    case 'B':
      // Vertical and horizontal lines
      line(0, -size/2, 0, size/2);
      line(-size/2, 0, size/2, 0);
      break;
    case 'C':
      // Diagonal corner lines
      line(-size/2, 0, 0, size/2);
      line(0, -size/2, size/2, 0);
      break;
  }
}

// Function to create walls for a specific tile
function createTileWalls(i, j) {
  let tile = tiles[i][j];
  let size = tileSize;
  let x = tile.x;
  let y = tile.y;
  let rotation = tile.rotation;
  let wallThickness = 10; // Increased thickness to prevent crossing
  
  // Define walls based on tile type
  let wallDefs = [];
  switch(tile.type) {
    case 'A':
      // Two diagonal walls
      wallDefs.push({ x1: -size/2, y1: -size/2, x2: size/2, y2: size/2 });
      wallDefs.push({ x1: -size/2, y1: size/2, x2: size/2, y2: -size/2 });
      break;
    case 'B':
      // Horizontal and vertical walls
      wallDefs.push({ x1: -size/2, y1: 0, x2: size/2, y2: 0 });
      wallDefs.push({ x1: 0, y1: -size/2, x2: 0, y2: size/2 });
      break;
    case 'C':
      // Two walls forming a corner
      wallDefs.push({ x1: -size/2, y1: 0, x2: 0, y2: size/2 });
      wallDefs.push({ x1: 0, y1: -size/2, x2: size/2, y2: 0 });
      break;
  }
  
  // Create Matter.js walls
  for (let def of wallDefs) {
    let length = dist(def.x1, def.y1, def.x2, def.y2);
    let angle = atan2(def.y2 - def.y1, def.x2 - def.x1);
    
    // Calculate wall position considering rotation
    let wallX = x + (def.x1 + def.x2)/2 * cos(rotation) - (def.y1 + def.y2)/2 * sin(rotation);
    let wallY = y + (def.x1 + def.x2)/2 * sin(rotation) + (def.y1 + def.y2)/2 * cos(rotation);
    
    let wall = Bodies.rectangle(wallX, wallY, length, wallThickness, {
      isStatic: true,
      angle: rotation + angle,
      restitution: 0.5,
      friction: 0.1
    });
    World.add(world, wall);
    tile.walls.push(wall);
    walls.push(wall);
  }
}

// Function to generate a new ball
function generateBall() {
  let x = random(tileSize/2, width - tileSize/2);
  let y = -10;
  let radius = 5;
  let ball = Bodies.circle(x, y, radius, {
    restitution: 0.1,
    friction: 0.01,
    frictionAir: 0.001
  });
  ball.color = random(palette);
  World.add(world, ball);
  balls.push({ body: ball, radius: radius, color: ball.color });
}

// Function to handle mouse clicks
function mousePressed() {
  let i = floor(mouseX / tileSize);
  let j = floor(mouseY / tileSize);
  
  if (i >= 0 && i < gridCols && j >= 0 && j < gridRows) {
    let tile = tiles[i][j];
    
    // Remove existing walls for this tile
    for (let wall of tile.walls) {
      World.remove(world, wall);
      let wallIndex = walls.indexOf(wall);
      if (wallIndex > -1) {
        walls.splice(wallIndex, 1);
      }
    }
    tile.walls = [];
    
    // Change tile type randomly
    tile.type = random(['A', 'B', 'C']);
    
    // Rotate tile
    tile.rotation = floor(random(4)) * HALF_PI;
    
    // Create new walls based on new type and rotation
    createTileWalls(i, j);
  }
}

// Function to handle window resize
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2415423","Coral Dream","mySketch","let cols = 100;
let rows = 100;
let noiseScale = 0.1;
let zOff = 0;

function setup() {
  createCanvas(800, 800);
  noFill();
  colorMode(HSB, 360, 100, 100, 100);
  background(0);
}

function draw() {
  background(0, 0, 10, 10); // Adding subtle fade effect

  let colorStart = color(220, 60, 90, 100); // Purple hue
  let colorMid = color(330, 80, 90, 100);   // Pink hue
  let colorEnd = color(40, 80, 90, 100);    // Orange hue

  for (let y = 0; y < rows; y++) {
    beginShape();
    for (let x = 0; x < cols; x++) {
      let xOff = map(x, 0, cols, 0, width);
      let yOff = map(y, 0, rows, 0, height);

      // Perlin noise to create undulating form
      let noiseVal = noise(x * noiseScale, y * noiseScale, zOff);
      let size = map(noiseVal, 0, 1, 0, 50); // Adjust size for more texture

      // Position based on noise
      let posX = xOff + size * sin(noiseVal * TWO_PI);
      let posY = yOff + size * cos(noiseVal * TWO_PI);

      // Smooth color gradient mapping
      let lerpAmt = map(y, 0, rows, 0, 1);
      let lerpedColor;
      if (lerpAmt < 0.5) {
        lerpedColor = lerpColor(colorStart, colorMid, lerpAmt * 2);
      } else {
        lerpedColor = lerpColor(colorMid, colorEnd, (lerpAmt - 0.5) * 2);
      }

      stroke(lerpedColor);
      strokeWeight(0.5);
      curveVertex(posX, posY);
    }
    endShape();
  }

  zOff += 0.01; // Animate noise for smooth wave effect
}
"
"2415417","Pulsating Orbitals","mySketch","let colors;
let loopLimit = 20;
let resolutionIncrement = 0.5;
let offsetMultiplier = 6;

function setup() {
  createCanvas(windowWidth, windowHeight);
  noCursor();
  noFill();
  colors = [
    color(255, 99, 71), // Red-Orange
    color(255, 165, 0),  // Orange
    color(0, 255, 255),  // Cyan
    color(255, 20, 147), // Pink
    color(75, 0, 130),   // Indigo
    color(255, 255, 0)   // Yellow
  ];
}

function draw() {
  background(250);
  push();
  translate(width / 2, height / 2);

  for (let i = 0; i < loopLimit; i++) {
    push();
    rotate(sin(frameCount * 0.01 + i) * i);
    strokeWeight(map(sin(frameCount * 0.01 + i), -1, 1, 1, 5));
    stroke(colors[i % colors.length]);
    blobShape(map(mouseX, 0, width, 50, 200) + i * 10, i * 10);
    pop();
  }
  pop();
}

function blobShape(size, offset) {
  beginShape();
  for (let i = 0; i < TWO_PI; i += resolutionIncrement) {
    let xOffset = cos(i + offset) * offsetMultiplier;
    let yOffset = sin(i + offset) * offsetMultiplier;
    let x = (size + noise(xOffset, yOffset, frameCount * 0.01) * 50) * cos(i);
    let y = (size + noise(xOffset, yOffset, frameCount * 0.01) * 50) * sin(i);
    vertex(x, y);
  }
  endShape(CLOSE);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2415413","Flowing Contours","mySketch","let cols, rows;
let scale = 4; // Distance between lines
let noiseStrength = 3; // Controls the ""turbulence"" of the lines

function setup() {
  createCanvas(windowWidth, windowHeight);
  cols = floor(width / scale);
  rows = floor(height / scale);
  noFill();
  stroke(0, 100); // Semi-transparent black lines
}

function draw() {
  background(255);
  let yOffset = 0;
  for (let y = 0; y < rows; y++) {
    beginShape();
    let xOffset = 0;
    for (let x = 0; x < cols; x++) {
      // Create a flowing pattern using Perlin noise
      let angle = noise(xOffset, yOffset, frameCount * 0.01) * TWO_PI;
      let xPos = x * scale + cos(angle) * noiseStrength * scale;
      let yPos = y * scale + sin(angle) * noiseStrength * scale;
      vertex(xPos, yPos);
      xOffset += 0.1;
    }
    endShape();
    yOffset += 0.1;
  }
}
"
"2415410","Nebulae Network","mySketch","let particles = [];
let maxParticles = 300;

function setup() {
  createCanvas(windowWidth, windowHeight);
  for (let i = 0; i < maxParticles; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  background(255, 20); // Light background with slight opacity for smooth trails
  for (let particle of particles) {
    particle.update();
    particle.display();
  }

  // Draw connections between nearby particles
  for (let i = 0; i < particles.length; i++) {
    for (let j = i + 1; j < particles.length; j++) {
      let d = dist(particles[i].pos.x, particles[i].pos.y, particles[j].pos.x, particles[j].pos.y);
      if (d < 70) { // Connect particles within a certain distance
        stroke(0, 20);
        strokeWeight(0.5);
        line(particles[i].pos.x, particles[i].pos.y, particles[j].pos.x, particles[j].pos.y);
      }
    }
  }
}

class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.size = random(1, 3); // Smaller size for elegant look
    this.color = color(random(150, 255), random(120, 200), random(200, 255), 150); // Softer pastel-like colors
    this.angleOffset = random(TWO_PI); // Unique noise offset for smoother flow
  }

  update() {
    let angle = noise(this.pos.x * 0.002, this.pos.y * 0.002, this.angleOffset) * TWO_PI * 2;
    this.acc = p5.Vector.fromAngle(angle).mult(0.2); // Slower, more controlled movement
    this.vel.add(this.acc);
    this.vel.limit(1); // Slower movement for smoother flow
    this.pos.add(this.vel);

    // Wrap around edges
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }

  display() {
    noStroke();
    fill(this.color);
    ellipse(this.pos.x, this.pos.y, this.size);
  }
}
"
"2415406","Mycelium network","mySketch","let nodes = [];
let maxNodes = 200; // Maximum number of nodes in the network

function setup() {
  createCanvas(windowWidth, windowHeight);
  for (let i = 0; i < maxNodes; i++) {
    nodes.push(new Node(random(width), random(height)));
  }
}

function draw() {
  background(255);
  for (let i = 0; i < nodes.length; i++) {
    nodes[i].update();
    nodes[i].display();
  }

  // Draw connections between nodes based on distance
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      let distance = dist(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
      if (distance < 100) {
        stroke(0, map(distance, 0, 100, 255, 50));
        strokeWeight(map(distance, 0, 100, 1.5, 0.5));
        line(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
      }
    }
  }
}

// Node class for each dot in the network
class Node {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = random(3, 5);
    this.xSpeed = random(-0.5, 0.5);
    this.ySpeed = random(-0.5, 0.5);
  }

  update() {
    // Update position with slight movement
    this.x += this.xSpeed;
    this.y += this.ySpeed;

    // Bounce from edges
    if (this.x < 0 || this.x > width) this.xSpeed *= -1;
    if (this.y < 0 || this.y > height) this.ySpeed *= -1;
  }

  display() {
    noStroke();
    fill(0);
    ellipse(this.x, this.y, this.size);
  }
}
"
"2412963","Fireflies with Kuramoto model","mySketch","let fireflies = [];
let numFireflies = 100;
let couplingStrength = 0.05; // Controls synchronization speed

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  for (let i = 0; i < numFireflies; i++) {
    fireflies.push(new Firefly(random(width), random(height)));
  }
}

function draw() {
  background(0, 50); // Slight trail effect
  for (let firefly of fireflies) {
    firefly.move();
    firefly.updatePhase(fireflies);
    firefly.display();
  }
}

function mouseMoved() {
  // Attract fireflies to mouse position
  for (let firefly of fireflies) {
    firefly.attract(mouseX, mouseY);
  }
}

class Firefly {
  constructor(x, y) {
    this.position = createVector(x, y);
    this.velocity = p5.Vector.random2D();
    this.velocity.mult(random(0.5, 2));
    this.acceleration = createVector(0, 0);
    this.maxSpeed = 2;
    this.phase = random(TWO_PI); // Phase of blinking
    this.frequency = random(0.9, 1.1); // Natural frequency
    this.size = 8;
  }

  move() {
    // Update velocity and position
    this.velocity.add(this.acceleration);
    this.velocity.limit(this.maxSpeed);
    this.position.add(this.velocity);
    // Reset acceleration
    this.acceleration.mult(0);

    // Wrap around edges
    if (this.position.x > width) this.position.x = 0;
    if (this.position.x < 0) this.position.x = width;
    if (this.position.y > height) this.position.y = 0;
    if (this.position.y < 0) this.position.y = height;
  }

  attract(targetX, targetY) {
    let target = createVector(targetX, targetY);
    let force = p5.Vector.sub(target, this.position);
    let distance = force.mag();
    if (distance > 0 && distance < 200) {
      force.setMag(map(distance, 0, 200, 0.5, 0));
      this.applyForce(force);
    }
  }

  applyForce(force) {
    this.acceleration.add(force);
  }

  updatePhase(fireflies) {
    // Update phase based on the Kuramoto model
    let sum = 0;
    let count = 0;
    for (let other of fireflies) {
      if (other !== this) {
        let distance = p5.Vector.dist(this.position, other.position);
        if (distance < 100) { // Interaction radius
          sum += sin(other.phase - this.phase);
          count++;
        }
      }
    }
    if (count > 0) {
      let deltaPhase = this.frequency + (couplingStrength / count) * sum;
      this.phase += deltaPhase * 0.05;
    } else {
      this.phase += this.frequency * 0.05;
    }
    this.phase = this.phase % TWO_PI;
  }

  display() {
    // Calculate brightness based on phase
    let brightness = map(sin(this.phase), -1, 1, 50, 255);
    let size = map(brightness, 50, 255, this.size, this.size * 1.5);
    let hue = map(this.phase, 0, TWO_PI, 0, 360);

    push();
    translate(this.position.x, this.position.y);
    rotate(this.velocity.heading() + PI / 2);
    noStroke();
    fill(hue, 200, brightness);
    triangle(0, -size, -size / 2, size / 2, size / 2, size / 2);
    pop();
  }
}
"
"2412939","Flock of Birds","mySketch","let flock;

function setup() {
  createCanvas(windowWidth, windowHeight);
  flock = new Flock();
  // Add initial boids to the flock
  for (let i = 0; i < 100; i++) {
    let boid = new Boid(random(width), random(height));
    flock.addBoid(boid);
  }
}

function draw() {
  background(51);
  flock.run();
}

function mouseMoved() {
  // Update the target position to the mouse position
  flock.setTarget(createVector(mouseX, mouseY));
}

function mousePressed() {
  // Add a new boid at the mouse position
  flock.addBoid(new Boid(mouseX, mouseY));
}

class Flock {
  constructor() {
    this.boids = [];
    this.target = null;
  }

  run() {
    for (let boid of this.boids) {
      boid.flock(this.boids, this.target);
      boid.update();
      boid.borders();
      boid.render();
    }
  }

  addBoid(b) {
    this.boids.push(b);
  }

  setTarget(target) {
    this.target = target;
  }
}

class Boid {
  constructor(x, y) {
    this.position = createVector(x, y);
    this.velocity = p5.Vector.random2D();
    this.acceleration = createVector(0, 0);
    this.maxForce = 0.05;
    this.maxSpeed = 3;
    this.r = 3.0; // Radius for rendering
  }

  flock(boids, target) {
    let sep = this.separate(boids).mult(1.5); // Separation
    let ali = this.align(boids).mult(1.0);    // Alignment
    let coh = this.cohesion(boids).mult(1.0); // Cohesion
    let tgt = createVector(0, 0);             // Attraction to target

    if (target) {
      let desired = p5.Vector.sub(target, this.position);
      let d = desired.mag();
      if (d > 0) {
        desired.normalize();
        desired.mult(this.maxSpeed);
        tgt = p5.Vector.sub(desired, this.velocity);
        tgt.limit(this.maxForce * 5); // Stronger attraction to mouse
      }
    }

    // Apply forces
    this.applyForce(sep);
    this.applyForce(ali);
    this.applyForce(coh);
    this.applyForce(tgt);
  }

  applyForce(force) {
    this.acceleration.add(force);
  }

  update() {
    // Update velocity and position
    this.velocity.add(this.acceleration);
    this.velocity.limit(this.maxSpeed);
    this.position.add(this.velocity);
    // Reset acceleration
    this.acceleration.mult(0);
  }

  render() {
    // Draw the boid as a triangle pointing in the direction of velocity
    let theta = this.velocity.heading() + radians(90);
    fill(127, 200);
    stroke(200);
    push();
    translate(this.position.x, this.position.y);
    rotate(theta);
    beginShape();
    vertex(0, -this.r * 2);
    vertex(-this.r, this.r * 2);
    vertex(this.r, this.r * 2);
    endShape(CLOSE);
    pop();
  }

  borders() {
    // Wrap around edges
    if (this.position.x < -this.r) this.position.x = width + this.r;
    if (this.position.y < -this.r) this.position.y = height + this.r;
    if (this.position.x > width + this.r) this.position.x = -this.r;
    if (this.position.y > height + this.r) this.position.y = -this.r;
  }

  separate(boids) {
    let desiredSeparation = 25;
    let steer = createVector(0, 0);
    let count = 0;
    for (let other of boids) {
      let d = p5.Vector.dist(this.position, other.position);
      if (d > 0 && d < desiredSeparation) {
        let diff = p5.Vector.sub(this.position, other.position);
        diff.normalize();
        diff.div(d); // Weight by distance
        steer.add(diff);
        count++;
      }
    }
    if (count > 0) {
      steer.div(count);
    }
    if (steer.mag() > 0) {
      steer.normalize();
      steer.mult(this.maxSpeed);
      steer.sub(this.velocity);
      steer.limit(this.maxForce);
    }
    return steer;
  }

  align(boids) {
    let neighborDist = 50;
    let sum = createVector(0, 0);
    let count = 0;
    for (let other of boids) {
      let d = p5.Vector.dist(this.position, other.position);
      if (d > 0 && d < neighborDist) {
        sum.add(other.velocity);
        count++;
      }
    }
    if (count > 0) {
      sum.div(count);
      sum.normalize();
      sum.mult(this.maxSpeed);
      let steer = p5.Vector.sub(sum, this.velocity);
      steer.limit(this.maxForce);
      return steer;
    } else {
      return createVector(0, 0);
    }
  }

  cohesion(boids) {
    let neighborDist = 50;
    let sum = createVector(0, 0); // Position
    let count = 0;
    for (let other of boids) {
      let d = p5.Vector.dist(this.position, other.position);
      if (d > 0 && d < neighborDist) {
        sum.add(other.position);
        count++;
      }
    }
    if (count > 0) {
      sum.div(count);
      return this.seek(sum); // Steer towards average position
    } else {
      return createVector(0, 0);
    }
  }

  seek(target) {
    let desired = p5.Vector.sub(target, this.position);
    desired.normalize();
    desired.mult(this.maxSpeed);
    let steer = p5.Vector.sub(desired, this.velocity);
    steer.limit(this.maxForce);
    return steer;
  }
}
"
"2412918","Flow Field of Particles","mySketch","let particles = [];
let flowField = [];
let cols, rows;
let scl = 20;
let zOffset = 0;
let inc = 0.1;

function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  colorMode(HSB, 360, 255, 255, 255);
  cols = floor(width / scl) + 1;
  rows = floor(height / scl) + 1;
  flowField = new Array(cols * rows);
  background(0);
  for (let i = 0; i < 5000; i++) {
    particles[i] = new Particle();
  }
}

function draw() {
  let yOffset = 0;
  for (let y = 0; y < rows; y++) {
    let xOffset = 0;
    for (let x = 0; x < cols; x++) {
      let index = x + y * cols;
      let angle = noise(xOffset, yOffset, zOffset) * TWO_PI * 4;
      let v = p5.Vector.fromAngle(angle);
      v.setMag(1);
      flowField[index] = v;
      xOffset += inc;
    }
    yOffset += inc;
  }
  zOffset += 0.003;

  for (let i = 0; i < particles.length; i++) {
    particles[i].follow(flowField);
    particles[i].update();
    particles[i].edges();
    particles[i].show();
  }
}

function mousePressed() {
  // Reset particles to mouse position on click
  for (let i = 0; i < particles.length; i++) {
    particles[i].position = createVector(mouseX, mouseY);
  }
}

class Particle {
  constructor() {
    this.position = createVector(random(width), random(height));
    this.velocity = createVector(0, 0);
    this.acceleration = createVector(0, 0);
    this.maxSpeed = 4;
    this.hue = random(360);
  }

  follow(vectors) {
    let x = floor(this.position.x / scl);
    let y = floor(this.position.y / scl);
    let index = x + y * cols;
    let force = vectors[index];
    this.applyForce(force);
  }

  applyForce(force) {
    this.acceleration.add(force);
  }

  update() {
    this.velocity.add(this.acceleration);
    this.velocity.limit(this.maxSpeed);
    this.position.add(this.velocity);
    this.acceleration.mult(0);
  }

  edges() {
    if (this.position.x > width) this.position.x = 0;
    if (this.position.x < 0) this.position.x = width;
    if (this.position.y > height) this.position.y = 0;
    if (this.position.y < 0) this.position.y = height;
  }

  show() {
    stroke(this.hue, 255, 255, 25);
    strokeWeight(1);
    point(this.position.x, this.position.y);
    this.hue += 0.5;
    if (this.hue > 360) this.hue = 0;
  }
}
"
"2412305","Butterflies","mySketch","let butterflies = [];
let butterflyImages = [];

function preload() {
  butterflyImages.push(loadImage('b1.gif'));
  butterflyImages.push(loadImage('b2.gif'));
	butterflyImages.push(loadImage('b3.gif'));
}


function setup() {
  createCanvas(windowWidth, windowHeight);
  frameRate(60);
  noCursor();
}

function draw() {
  background(135, 206, 235); // Sky blue background
  
  // Draw and update butterflies
  for (let butterfly of butterflies) {
    butterfly.update();
    butterfly.display();
  }
  
  // Draw a butterfly following the mouse
  imageMode(CENTER);
  let idx = frameCount % butterflyImages.length;
  push();
  translate(mouseX, mouseY);
  rotate(sin(frameCount * 0.1) * 0.2);
  image(butterflyImages[idx], 0, 0, 60, 60);
  pop();
}

function mousePressed() {
  // Add a new butterfly at mouse position
  butterflies.push(new Butterfly(mouseX, mouseY));
}

class Butterfly {
  constructor(x, y) {
    this.position = createVector(x, y);
    this.velocity = p5.Vector.random2D();
    this.velocity.mult(random(1, 3));
    this.acceleration = createVector(0, 0);
    this.image = random(butterflyImages);
    this.size = random(80, 120);
    this.angle = 0;
    this.angleSpeed = random(-0.05, 0.05);
    this.flapSpeed = random(0.1, 0.4);
  }
  
  update() {
    // Apply acceleration towards random points
    let steer = p5.Vector.random2D();
    steer.mult(0.05);
    this.acceleration.add(steer);
    
    // Update velocity and position
    this.velocity.add(this.acceleration);
    this.velocity.limit(3);
    this.position.add(this.velocity);
    
    // Reset acceleration
    this.acceleration.mult(0);
    
    // Update angle for rotation
    this.angle += this.angleSpeed;
    
    // Wrap around the canvas edges
    if (this.position.x > width + this.size) this.position.x = -this.size;
    if (this.position.x < -this.size) this.position.x = width + this.size;
    if (this.position.y > height + this.size) this.position.y = -this.size;
    if (this.position.y < -this.size) this.position.y = height + this.size;
  }
  
  display() {
    push();
    translate(this.position.x, this.position.y);
    rotate(this.angle + sin(frameCount * this.flapSpeed) * 0.2);
    imageMode(CENTER);
    image(this.image, 0, 0, this.size, this.size);
    pop();
  }
}
"
"2412298","Flower garden","mySketch","// ""Reproduction"" 🖨 #WCCChallenge
// 4th November 2024 by Gonçalo Perdigão

let flowers = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  frameRate(60);
  background(230, 230, 250); // Lavender background
}

function draw() {
  background(230, 230, 250, 20); // Semi-transparent background for fade effect
  
  for (let i = flowers.length - 1; i >= 0; i--) {
    flowers[i].grow();
    flowers[i].display();
    
    if (flowers[i].isFinished()) {
      flowers.splice(i, 1); // Remove finished flowers
    }
  }
}

function mousePressed() {
  // Plant a new flower at mouse position
  flowers.push(new Flower(mouseX, mouseY));
}

class Flower {
  constructor(x, y) {
    this.position = createVector(x, height); // Start from the bottom of the canvas
    this.targetY = y;
    this.stemLength = 0;
    this.maxStemLength = this.position.y - this.targetY;
    this.stemGrowthRate = random(2, 5);
    this.bloomed = false;
    this.petals = [];
    this.numPetals = int(random(5, 12));
    this.petalGrowth = 0;
    this.maxPetalGrowth = random(20, 50);
    this.petalColor = color(random(360), 200, 255, 200);
    colorMode(HSB, 360, 255, 255, 255);
  }
  
  grow() {
    if (!this.bloomed) {
      this.stemLength += this.stemGrowthRate;
      if (this.stemLength >= this.maxStemLength) {
        this.bloomed = true;
      }
    } else {
      if (this.petalGrowth < this.maxPetalGrowth) {
        this.petalGrowth += 1;
      }
    }
  }
  
  display() {
    push();
    translate(this.position.x, this.position.y);
    stroke(34, 139, 34); // Stem color
    strokeWeight(2);
    line(0, 0, 0, -this.stemLength);
    
    if (this.bloomed) {
      translate(0, -this.stemLength);
      noStroke();
      fill(this.petalColor);
      for (let i = 0; i < this.numPetals; i++) {
        let angle = map(i, 0, this.numPetals, 0, TWO_PI);
        push();
        rotate(angle + frameCount * 0.01); // Slight rotation animation
        ellipse(0, this.petalGrowth / 2, this.petalGrowth, this.petalGrowth * 2);
        pop();
      }
      fill(255, 204, 0); // Center of the flower
      ellipse(0, 0, this.maxPetalGrowth / 2);
    }
    pop();
  }
  
  isFinished() {
    // Keep flowers on the screen indefinitely
    return false;
  }
}
"
"2408936","Vector Addition","mySketch","let origin;
let vector1, vector2;
let result;

function setup() {
  createCanvas(800, 600);
  origin = createVector(width / 4, height / 2); // Set the origin
  
  // Initial positions for vector heads
  vector1 = createVector(200, 150);
  vector2 = createVector(150, -100);
  
  // Smooth drawing and thin lines for elegance
  strokeWeight(1.5);
  textFont('Georgia');
}

function draw() {
  background(20); // Elegant dark background
  
  // Draw grid
  drawGrid();
  
  // Calculate result vector (vector1 + vector2)
  result = p5.Vector.add(vector1, vector2);
  
  // Draw vectors from the origin
  drawVector(vector1, origin, color(0, 255, 0), ""Vector 1""); // Green
  drawVector(vector2, origin, color(0, 0, 255), ""Vector 2""); // Blue
  drawVector(result, origin, color(255, 0, 0), ""Resultant""); // Red
  
  // Instructions and labels
  noStroke();
  fill(255);
  textSize(16);
  text(""Drag the vector heads to adjust them"", 20, 20);
  text(""Green: Vector 1, Blue: Vector 2, Red: Resultant"", 20, 50);
  
  // Magnitudes and angles display
  text(`|Vector 1|: ${vector1.mag().toFixed(2)}`, 20, height - 70);
  text(`|Vector 2|: ${vector2.mag().toFixed(2)}`, 20, height - 50);
  text(`|Resultant|: ${result.mag().toFixed(2)}`, 20, height - 30);
}

function drawGrid() {
  stroke(100, 100, 100, 50);
  for (let x = 0; x < width; x += 20) {
    line(x, 0, x, height); // Vertical lines
  }
  for (let y = 0; y < height; y += 20) {
    line(0, y, width, y); // Horizontal lines
  }
}

function drawVector(v, base, col, label) {
  stroke(col);
  fill(col);
  
  let arrowSize = 10;
  
  // Draw the vector line
  line(base.x, base.y, base.x + v.x, base.y + v.y);
  
  // Draw the arrowhead
  let angle = atan2(v.y, v.x);
  push();
  translate(base.x + v.x, base.y + v.y);
  rotate(angle);
  triangle(0, 0, -arrowSize, arrowSize / 2, -arrowSize, -arrowSize / 2);
  pop();
  
  // Label the vector with magnitude and angle
  noStroke();
  textSize(14);
  text(`${label} (${v.mag().toFixed(2)}, ${degrees(angle).toFixed(1)}°)`, base.x + v.x + 10, base.y + v.y - 10);
}

function mouseDragged() {
  // Check if mouse is near vector1 head
  if (dist(mouseX, mouseY, origin.x + vector1.x, origin.y + vector1.y) < 20) {
    vector1.set(mouseX - origin.x, mouseY - origin.y);
  }
  
  // Check if mouse is near vector2 head
  if (dist(mouseX, mouseY, origin.x + vector2.x, origin.y + vector2.y) < 20) {
    vector2.set(mouseX - origin.x, mouseY - origin.y);
  }
}
"
"2408932","Euler’s number","mySketch","let t = 0;
let aSlider, rSlider;
let points = [];

function setup() {
  createCanvas(800, 400);
  
  // Use a thin, elegant font for labels and text
  textFont('Georgia');
  
  // Sliders for initial value and growth rate
  aSlider = createSlider(1, 10, 1, 0.1); // Initial value slider
  aSlider.position(20, 50);
  aSlider.style('width', '150px');
  
  rSlider = createSlider(0, 2, 0.5, 0.01); // Growth rate slider
  rSlider.position(20, 110);
  rSlider.style('width', '150px');
  
  // Setup for smooth lines
  strokeWeight(1.5);
}

function draw() {
  background(20); // Dark background for elegant contrast
  
  // Get values from sliders
  let a = aSlider.value();  // Initial value
  let r = rSlider.value();  // Growth rate
  
  // Draw axes with thin lines
  stroke(200, 150); // Light gray for elegant axis lines
  line(50, height - 50, width - 50, height - 50); // X axis
  line(50, 50, 50, height - 50);                  // Y axis
  
  // Labels for axes
  noStroke();
  fill(255);
  textSize(14);
  text(""Time (t)"", width - 100, height - 30);  // X-axis label
  text(""Growth (y)"", 10, 40);                  // Y-axis label
  
  // Slider labels
  fill(255, 200); // Softer white for labels
  textSize(14);
  text(""Initial Value (a):"", 20, 40);
  text(""Growth Rate (r):"", 20, 100);
  
  // Clear previous points for stable animation
  points = [];
  
  // Draw the exponential curve
  stroke(0, 255, 0, 200); // Elegant green curve
  noFill();
  beginShape();
  
  for (let i = 0; i < t; i++) {
    let x = map(i, 0, 200, 50, width - 50); // Mapping time to X axis
    let y = a * exp(r * i / 100);           // Exponential growth formula
    let yPos = map(y, 0, 200, height - 50, 50); // Mapping value to Y axis
    
    points.push(createVector(x, yPos));     // Save point for smooth drawing
    vertex(x, yPos);
  }
  endShape();
  
  // Show the current point on the curve with a small circle
  let currentX = map(t, 0, 200, 50, width - 50);
  let currentY = a * exp(r * t / 100);
  let yPos = map(currentY, 0, 200, height - 50, 50);
  
  fill(255, 0, 0);
  ellipse(currentX, yPos, 8, 8); // Current point on the curve
  
  // Display formula and current values with elegant text
  fill(255);
  textSize(16);
  text(`y = ${a.toFixed(2)} * e^(${r.toFixed(2)} * t)`, 20, 170); // Formula text
  
  // Animate time progression
  t += 1;
  
  // Reset time after exceeding width for continuous animation
  if (t > 200) {
    t = 0;
  }
}
"
"2408925","Cos & Sin curves","mySketch","let angle = 0;
let radius;
let waveOffset = 150;
let sineWave = [];
let cosineWave = [];
let speedSlider;

function setup() {
  createCanvas(800, 400);
  radius = 100;
  
  // Create a slider for adjusting speed of animation
  speedSlider = createSlider(0.01, 0.1, 0.03, 0.01);
  speedSlider.position(20, 20);
  speedSlider.style('width', '100px');
}

function draw() {
  background(0);
  
  let speed = speedSlider.value(); // Get the speed from the slider

  // Draw the unit circle
  translate(150, height / 2);
  stroke(255);
  strokeWeight(1);
  noFill();
  ellipse(0, 0, radius * 2, radius * 2); // Circle outline

  // Calculate current sine and cosine values based on a ""north"" starting point (rotate by HALF_PI)
  let x = radius * cos(angle - HALF_PI);
  let y = radius * sin(angle - HALF_PI);

  // Draw the point on the circle
  fill(255, 0, 0);
  ellipse(x, y, 10, 10);

  // Draw horizontal and vertical lines from the circle point to the axes
  stroke(255, 100);
  line(x, y, x, 0); // Vertical to x-axis (cosine)
  line(x, y, 0, y); // Horizontal to y-axis (sine)

  // Draw axes labels
  noStroke();
  fill(255);
  textSize(16);
  text(""Cosine"", x / 2 - 20, 20); // Label cosine on x-axis
  text(""Sine"", -40, y / 2 + 5);  // Label sine on y-axis

  // Plot the Sine Wave
  stroke(0, 255, 0);
  strokeWeight(2);
  noFill();
  beginShape();
  for (let i = 0; i < sineWave.length; i++) {
    vertex(i + 300, sineWave[i]);
  }
  endShape();

  // Plot the Cosine Wave
  stroke(0, 0, 255);
  strokeWeight(2);
  noFill();
  beginShape();
  for (let i = 0; i < cosineWave.length; i++) {
    vertex(i + 300, cosineWave[i] + waveOffset);
  }
  endShape();

  // Add current sine and cosine values to the waves
  sineWave.push(y);
  cosineWave.push(x);

  // Remove old points from the waves to keep them smooth and scrolling
  if (sineWave.length > width - 300) {
    sineWave.splice(0, 1);
    cosineWave.splice(0, 1);
  }

  // Show the text for the angle in terms of Pi
  noStroke();
  fill(255);
  textSize(20);
  let piFraction = (angle / PI).toFixed(2);
  text(`Angle: ${piFraction}π`, -50, -radius - 20);
  text(`Sine: ${sin(angle - HALF_PI).toFixed(2)}`, -50, -radius - 50);
  text(`Cosine: ${cos(angle - HALF_PI).toFixed(2)}`, -50, -radius - 80);

  // Animate the angle smoothly with the speed from slider
  angle += speed;

  // Reset the angle after a full revolution (0 to 2π)
  if (angle > TWO_PI) {
    angle = 0;
  }

  // Display the speed from the slider
  fill(255);
  textSize(16);
  text(`Speed: ${speed.toFixed(2)}`, 20, 60);
}
"
"2401555","Maze Glide","mySketch","// Variables and constants
let particle;
let maze;
let goal;
let cols, rows;
let cellSize = 40;
let grid = [];
let stack = [];
let level = 1;
let score = 100;
let trail = [];
let gameOver = false;

function setup() {
  createCanvas(600, 600);
  cols = floor(width / cellSize);
  rows = floor(height / cellSize);
  resetGame();
}

function draw() {
  background(240);
  
  maze.display();
  particle.update();
  particle.displayTrail();
  particle.display();

  // Draw goal
  fill(120, 200, 120);
  noStroke();
  ellipse(goal.x, goal.y, 20, 20);

  checkWin();
  displayScore();

  // Decrease score by 1 point per second
  if (frameCount % 60 == 0 && score > 0 && !gameOver) {
    score--;
  }

  // Check if time runs out (Game Over)
  if (score === 0 && !gameOver) {
    gameOver = true;
    fill(200, 0, 0);
    textSize(32);
    textAlign(CENTER, CENTER);
    text(""Game Over!"", width / 2, height / 2 - 30);
    textSize(24);
    text(""You reached Level "" + level + "" with "" + score + "" points."", width / 2, height / 2);
    text(""Press Enter to restart"", width / 2, height / 2 + 30);
    noLoop();
  }
}

function checkWin() {
  let d = dist(particle.pos.x, particle.pos.y, goal.x, goal.y);
  if (d < 10 && !gameOver) {
    fill(0, 150, 0);
    textSize(32);
    textAlign(CENTER, CENTER);
    text(""You Win!"", width / 2, height / 2 - 20);
    textSize(24);
    text(""Press Enter for next level"", width / 2, height / 2 + 10);
    noLoop();
  }
}

function resetGame() {
  grid = [];
  stack = [];
  maze = new Maze();
  maze.generateMaze();
  particle = new Particle(cellSize / 2, cellSize / 2);  // Start in top-left corner
  goal = createVector(width - cellSize / 2, height - cellSize / 2);  // End in bottom-right corner
  trail = [];
  loop();  // Restart the game loop
}

function displayScore() {
  fill(0);
  textSize(16);
  textAlign(LEFT, TOP);
  text(""Score: "" + score, 10, 10);
  text(""Level: "" + level, 10, 30);
}

function keyPressed() {
  if (keyCode === ENTER) {
    if (gameOver) {
      level = 1;
      score = 100;
      gameOver = false;
    } else {
      level++;
      // Add bonus points for completing the level
      score += 100;
    }
    resetGame();
  }
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.maxSpeed = 2;
  }

  update() {
    this.acc.set(0, 0);

    if (touches.length > 0) {
      // Mobile touch input
      let touchPos = createVector(touches[0].x, touches[0].y);
      let dir = p5.Vector.sub(touchPos, this.pos);
      dir.setMag(0.2);
      this.acc = dir;
    } else {
      // Keyboard input
      if (keyIsDown(LEFT_ARROW)) {
        this.acc.x = -0.2;
      }
      if (keyIsDown(RIGHT_ARROW)) {
        this.acc.x = 0.2;
      }
      if (keyIsDown(UP_ARROW)) {
        this.acc.y = -0.2;
      }
      if (keyIsDown(DOWN_ARROW)) {
        this.acc.y = 0.2;
      }
    }

    this.vel.add(this.acc);
    this.vel.limit(this.maxSpeed);
    let nextPos = p5.Vector.add(this.pos, this.vel);

    // Check for collisions before moving
    if (!this.checkCollision(nextPos)) {
      this.pos = nextPos;
    } else {
      this.vel.mult(0);  // Stop movement if collision detected
    }

    this.pos.x = constrain(this.pos.x, 0, width);
    this.pos.y = constrain(this.pos.y, 0, height);

    this.leaveTrail();
  }

  display() {
    fill(30, 150, 255);
    noStroke();
    ellipse(this.pos.x, this.pos.y, 12, 12);
  }

  leaveTrail() {
    trail.push(this.pos.copy());
    if (trail.length > 100) {
      trail.splice(0, 1);  // Limit the trail length
    }
  }

  displayTrail() {
    noFill();
    stroke(30, 150, 255, 100);
    strokeWeight(2);
    beginShape();
    for (let i = 0; i < trail.length; i++) {
      vertex(trail[i].x, trail[i].y);
    }
    endShape();
  }

  checkCollision(nextPos) {
    // Check collision with walls
    for (let wall of maze.walls) {
      if (circleLineCollision(nextPos.x, nextPos.y, 6, wall.x1, wall.y1, wall.x2, wall.y2)) {
        return true; // Collision detected
      }
    }
    return false;
  }
}

class Maze {
  constructor() {
    this.walls = [];
  }

  generateMaze() {
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        let cell = new Cell(x, y);
        grid.push(cell);
      }
    }

    let current = grid[0];  // Start at the top-left corner
    current.visited = true;

    while (true) {
      let next = current.checkNeighbors();
      if (next) {
        next.visited = true;
        stack.push(current);
        removeWalls(current, next);
        current = next;
      } else if (stack.length > 0) {
        current = stack.pop();
      } else {
        break;
      }
    }

    // Create walls for the maze as linear lines
    for (let cell of grid) {
      let x = cell.x * cellSize;
      let y = cell.y * cellSize;
      if (cell.walls[0]) this.walls.push(new Wall(x, y, x + cellSize, y));  // Top
      if (cell.walls[1]) this.walls.push(new Wall(x + cellSize, y, x + cellSize, y + cellSize));  // Right
      if (cell.walls[2]) this.walls.push(new Wall(x, y + cellSize, x + cellSize, y + cellSize));  // Bottom
      if (cell.walls[3]) this.walls.push(new Wall(x, y, x, y + cellSize));  // Left
    }
  }

  display() {
    stroke(0);
    strokeWeight(2);
    for (let wall of this.walls) {
      line(wall.x1, wall.y1, wall.x2, wall.y2);
    }
  }
}

class Wall {
  constructor(x1, y1, x2, y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }
}

class Cell {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.walls = [true, true, true, true];  // Top, right, bottom, left walls
    this.visited = false;
  }

  checkNeighbors() {
    let neighbors = [];

    let top = grid[index(this.x, this.y - 1)];
    let right = grid[index(this.x + 1, this.y)];
    let bottom = grid[index(this.x, this.y + 1)];
    let left = grid[index(this.x - 1, this.y)];

    if (top && !top.visited) neighbors.push(top);
    if (right && !right.visited) neighbors.push(right);
    if (bottom && !bottom.visited) neighbors.push(bottom);
    if (left && !left.visited) neighbors.push(left);

    if (neighbors.length > 0) {
      let r = floor(random(neighbors.length));
      return neighbors[r];
    } else {
      return undefined;
    }
  }
}

function index(x, y) {
  if (x < 0 || y < 0 || x >= cols || y >= rows) {
    return -1;
  }
  return x + y * cols;
}

function removeWalls(a, b) {
  let x = a.x - b.x;
  if (x === 1) {
    a.walls[3] = false;  // Remove left wall of a
    b.walls[1] = false;  // Remove right wall of b
  } else if (x === -1) {
    a.walls[1] = false;
    b.walls[3] = false;
  }

  let y = a.y - b.y;
  if (y === 1) {
    a.walls[0] = false;  // Remove top wall of a
    b.walls[2] = false;  // Remove bottom wall of b
  } else if (y === -1) {
    a.walls[2] = false;
    b.walls[0] = false;
  }
}

// Function to detect collision between a circle and a line segment
function circleLineCollision(cx, cy, radius, x1, y1, x2, y2) {
  // Vector from x1,y1 to x2,y2
  let ac = createVector(cx - x1, cy - y1);
  let ab = createVector(x2 - x1, y2 - y1);
  let abLength = ab.mag();
  ab.normalize();

  // Project ac onto ab, computing the distance from a to the closest point
  let projection = p5.Vector.dot(ac, ab);
  let closest;

  if (projection < 0) {
    closest = createVector(x1, y1);
  } else if (projection > abLength) {
    closest = createVector(x2, y2);
  } else {
    closest = p5.Vector.add(createVector(x1, y1), ab.mult(projection));
  }

  // Compute the distance between circle center and closest point
  let distToCircle = dist(cx, cy, closest.x, closest.y);
  return distToCircle < radius;
}

// Prevent default touch behavior on mobile
function touchStarted() {
  return false;
}

function touchMoved() {
  return false;
}

function touchEnded() {
  return false;
}
"
"2399441","Brownian Cannon","mySketch","// ""Survival"" 🏕 #WCCChallenge 21/10/2024 v.10
// Built by Gonçalo Perdigão https://openprocessing.org/user/392648

let bullets = [];
let blocks = [];
let blockLimit = 10; // Starting blocks
let lives = 3; // Number of lives
let wallX; // Position of the wall
let bulletFrequency = 500; // Bullet fired every 0.5 second
let lastBulletTime = 0;
let blockCooldown = 1000; // Time to gain a new block (1 second)
let lastBlockGainTime = 0;
let blockWidth = 10; // Width of the blocks
let wallHit = false;
let gameIsOver = false; // Flag to track game over state
let score = 0; // Initialize score
let startTime; // Start time for the game

function setup() {
  createCanvas(windowWidth, windowHeight);
  wallX = width * 0.8; // Wall positioned at 80% of canvas width
  strokeWeight(1); // Thin lines for elegant traces
  textSize(14); // Reduced font size for elegance
  startTime = millis(); // Set the game start time
}

function draw() {
  background(20, 40, 70); // Elegant background

  // Draw the wall
  stroke(255); // White wall
  line(wallX, 0, wallX, height); 

  if (gameIsOver) {
    drawGameOverScreen();
    return;
  }

  // Draw blocks
  for (let i = blocks.length - 1; i >= 0; i--) {
    blocks[i].show();
  }

  // Generate new bullet every second
  let currentTime = millis();
  if (currentTime - lastBulletTime > bulletFrequency) {
    bullets.push(new Bullet());
    lastBulletTime = currentTime;
  }

  // Update and show bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    bullets[i].update();
    bullets[i].show();

    // Check collision with blocks
    for (let j = blocks.length - 1; j >= 0; j--) {
      if (bullets[i].hits(blocks[j])) {
        bullets.splice(i, 1); // Bullet is destroyed
        blocks.splice(j, 1); // Block is destroyed
        blockLimit--; // Reduce block count
        score += 20; // Add 20 points for successful block
        break;
      }
    }

    // Check if bullet hits the wall
    if (bullets[i] && bullets[i].x >= wallX) {
      bullets.splice(i, 1); // Remove bullet
      lives--; // Lose 1 life
      wallHit = true; // Trigger animation for wall hit
      if (lives <= 0) {
        gameIsOver = true; // Set game over flag
      }
    }

    // Remove bullets if they touch the top or bottom of the canvas
    if (bullets[i] && (bullets[i].y <= 0 || bullets[i].y >= height)) {
      bullets.splice(i, 1); // Remove bullet
    }
  }

  // Gain new block every second, up to the limit of 10
  if (currentTime - lastBlockGainTime > blockCooldown && blockLimit < 10) {
    blockLimit++;
    lastBlockGainTime = currentTime;
  }

  // Add 1 point per second of game time
  score = floor((millis() - startTime) / 1000) + score % 1; // Ensures score continues correctly

  // Show remaining blocks, lives, and score
  fill(255);
  text(""Blocks Available: "" + blockLimit, 20, 20);
  text(""Lives: "" + lives, 20, 40);
  text(""Score: "" + score, 20, 60); // Display score

  // Handle wall hit animation (brief flash)
  if (wallHit) {
    stroke(255, 0, 0);
    line(wallX, 0, wallX, height); // Flash red wall
    wallHit = false;
  }
}

function mousePressed() {
  if (gameIsOver) {
    restartGame(); // Restart the game if it's over
  } else if (blockLimit > 0 && mouseX < wallX) {
    // Place a block when the mouse is pressed, if blocks are available and inside the canvas
    blocks.push(new Block(mouseX, mouseY));
    blockLimit--;
  }
}

// Bullet class (Brownian motion)
class Bullet {
  constructor() {
    this.x = 0;
    this.y = height / 2;
    this.stepSize = 2; // Speed of the bullet
    this.drift = 0;
    this.trace = [];
  }

  update() {
    // Move the bullet horizontally
    this.x += this.stepSize;

    // Narrow Brownian motion for vertical movement
    this.drift += random(-0.2, 0.2); // Narrow vertical drift for smooth, controlled movement
    this.y += this.drift;

    // Store the trail
    this.trace.push({ x: this.x, y: this.y });
    if (this.trace.length > 200) {
      this.trace.shift();
    }
  }

  show() {
    stroke(255); // Simple white lines for the trail

    // Draw the trail of the bullet
    noFill(); // No filling to avoid visual artifacts
    beginShape();
    for (let i = 0; i < this.trace.length; i++) {
      vertex(this.trace[i].x, this.trace[i].y);
    }
    endShape();

    // Draw the bullet itself
    stroke(255);
    ellipse(this.x, this.y, 5, 5);
  }

  hits(block) {
    // Check if bullet hits a block
    return this.x > block.x && this.x < block.x + blockWidth && this.y > block.y && this.y < block.y + block.height;
  }
}

// Block class
class Block {
  constructor(x, y) {
    this.x = wallX - blockWidth; // Block position at the wall
    this.y = y;
    this.height = 50; // Block height
  }

  show() {
    stroke(100, 200, 255); // Elegant blue block
    fill(100, 200, 255);
    rect(this.x, this.y, blockWidth, this.height);
  }
}

function drawGameOverScreen() {
  fill(255);
  textSize(32);
  text(""Game Over"", width / 2 - 100, height / 2);
  textSize(14); // Reset the text size
  text(""Click to restart"", width / 2 - 60, height / 2 + 30);
}

function restartGame() {
  // Reset all game parameters
  bullets = [];
  blocks = [];
  blockLimit = 10;
  lives = 3;
  lastBulletTime = 0;
  lastBlockGainTime = 0;
  score = 0; // Reset score
  startTime = millis(); // Reset start time
  gameIsOver = false;
  loop(); // Restart the game loop
}
"
"2399405","Probabilistic Drift","mySketch","let balls = []; // Array to hold all the balls
let ballFrequency = 100; // Time interval (in milliseconds) to fire new balls
let lastBallTime = 0; // To keep track of time for new balls
let wallX; // Position of the vertical wall
let wallResolution = 100; // Number of segments in the wall for probability tracking
let wallImpact; // Array to track impact probabilities on the wall

function setup() {
  createCanvas(windowWidth, windowHeight);
  strokeWeight(1); // Thin lines for elegant traces
  noFill();

  // Wall position and setup
  wallX = width * 0.75; // Wall is 75% of the way across the screen
  wallImpact = new Array(wallResolution).fill(0); // Initialize wall impact array with zeros
}

function draw() {
  background(20, 40, 70, 25); // Background fades slightly, leaving a trace of the ball paths
  let currentTime = millis(); // Current time in milliseconds

  // Add a new ball every X seconds
  if (currentTime - lastBallTime > ballFrequency) {
    balls.push(new Ball());
    lastBallTime = currentTime;
  }

  // Update and draw all balls
  for (let i = balls.length - 1; i >= 0; i--) {
    balls[i].update();
    balls[i].show();

    // Check if ball reaches the wall
    if (balls[i].x >= wallX) {
      registerImpact(balls[i].y); // Register impact on the wall
      balls.splice(i, 1); // Remove ball after it hits the wall
    }
  }

  drawWall(); // Draw the probability wall
}

function drawWall() {
  // Draw the wall with a vertical gradient based on impact probability
  for (let i = 0; i < wallResolution; i++) {
    let y1 = map(i, 0, wallResolution, 0, height);
    let y2 = map(i + 1, 0, wallResolution, 0, height);
    let colorVal = map(wallImpact[i], 0, max(wallImpact), 255, 0); // White (0 impact) to Black (high impact)
    stroke(colorVal);
    line(wallX, y1, wallX, y2); // Draw the thin line representing the wall segment
  }
}

function registerImpact(y) {
  // Map the Y position of the ball to a specific segment of the wall
  let wallIndex = floor(map(y, 0, height, 0, wallResolution));

  // Increment the impact count at that wall index (clamp to valid array indices)
  if (wallIndex >= 0 && wallIndex < wallResolution) {
    wallImpact[wallIndex]++;
  }
}

class Ball {
  constructor() {
    this.x = 0; // Start at the left edge
    this.y = height / 2; // Start vertically in the middle
    this.stepSize = 2; // Step size in X direction (how fast it moves horizontally)
    this.drift = 0; // Current random vertical drift (Brownian movement)
    this.trace = []; // Array to hold the trail of positions
  }

  update() {
    // Move the ball horizontally by a constant step size
    this.x += this.stepSize;

    // Apply Brownian movement (small random vertical adjustments)
    this.drift += random(-1, 1); // Slight random change in the Y direction
    this.y += this.drift;

    // Store the current position in the trace
    this.trace.push({ x: this.x, y: this.y });

    // Limit the trace array length to avoid memory issues
    if (this.trace.length > 200) {
      this.trace.shift();
    }
  }

  show() {
    stroke(255, 150); // Soft white trace for elegance

    // Draw the trail of the ball
    beginShape();
    for (let i = 0; i < this.trace.length; i++) {
      vertex(this.trace[i].x, this.trace[i].y);
    }
    endShape();

    // Draw the ball itself
    stroke(255, 255, 255);
    ellipse(this.x, this.y, 5, 5); // Small circle representing the ball
  }
}
"
"2399397","Brownian waves","mySketch","let balls = []; // Array to hold all the balls
let ballFrequency = 500; // Time interval (in milliseconds) to fire new balls
let lastBallTime = 0; // To keep track of time for new balls

function setup() {
  createCanvas(windowWidth, windowHeight);
  strokeWeight(1); // Thin lines for elegant traces
  noFill();
}

function draw() {
  background(20, 40, 70, 25); // Background fades slightly, leaving a trace of the ball paths
  let currentTime = millis(); // Current time in milliseconds
  
  // Add a new ball every 0.5 seconds
  if (currentTime - lastBallTime > ballFrequency) {
    balls.push(new Ball());
    lastBallTime = currentTime;
  }
  
  // Update and draw all balls
  for (let i = balls.length - 1; i >= 0; i--) {
    balls[i].update();
    balls[i].show();

    // Remove the ball once it reaches the right edge of the screen
    if (balls[i].x > width) {
      balls.splice(i, 1);
    }
  }
}

class Ball {
  constructor() {
    this.x = 0; // Start at the left edge
    this.y = height / 2; // Start vertically in the middle
    this.stepSize = 2; // Step size in X direction (how fast it moves horizontally)
    this.drift = 0; // Current random vertical drift (Brownian movement)
    this.trace = []; // Array to hold the trail of positions
  }

  update() {
    // Move the ball horizontally by a constant step size
    this.x += this.stepSize;

    // Apply Brownian movement (small random vertical adjustments)
    this.drift += random(-1, 1); // Slight random change in the Y direction
    this.y += this.drift;

    // Store the current position in the trace
    this.trace.push({ x: this.x, y: this.y });

    // Limit the trace array length to avoid memory issues
    if (this.trace.length > 200) {
      this.trace.shift();
    }
  }

  show() {
    stroke(255, 150); // Soft white trace for elegance
    
    // Draw the trail of the ball
    beginShape();
    for (let i = 0; i < this.trace.length; i++) {
      vertex(this.trace[i].x, this.trace[i].y);
    }
    endShape();
    
    // Draw the ball itself
    stroke(255, 255, 255);
    ellipse(this.x, this.y, 5, 5); // Small circle representing the ball
  }
}
"
"2399391","More waves","mySketch","let waveDetail = 200;
let waveHeight = 100;
let layers = 5; // Number of wave layers
let yOffsetStart = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  stroke(255, 150); // Set stroke color to soft white
  strokeWeight(1); // Keep thin lines for elegance
  noFill();
}

function draw() {
  background(20, 40, 70); // Deep ocean-like background
  translate(0, height / 2); // Center vertically

  for (let l = 0; l < layers; l++) {
    let layerOffset = l * 0.2; // Offset each wave slightly for phase shift

    let frequency = map(mouseX, 0, width, 0.001, 0.05) * (1 + l * 0.3); // Slight variation for each layer
    let amplitude = map(mouseY, 0, height, 20, waveHeight) * (1 - l * 0.15); // Vary amplitude for layers

    beginShape();

    let yOffset = yOffsetStart + layerOffset; // Start with slight offset for each layer

    for (let x = 0; x <= width; x += width / waveDetail) {
      // Create smooth variation using sin() and noise()
      let y = sin(x * frequency + layerOffset) * amplitude + map(noise(yOffset), 0, 1, -50, 50);
      vertex(x, y); // Generate wave vertex
      yOffset += 0.05; // Increment yOffset for smooth noise transition
    }

    endShape();
  }

  yOffsetStart += 0.01; // Smooth motion for Perlin noise
}
"
"2399390","Ocean Waves","mySketch","let yOffsetStart = 0;
let waveDetail = 200;
let waveHeight = 100;

function setup() {
  createCanvas(windowWidth, windowHeight);
  stroke(255, 150); // Set line color to a smooth white with transparency
  strokeWeight(1); // Use thin lines
  noFill();
}

function draw() {
  background(20, 40, 70); // Deep ocean-like background
  translate(0, height / 2); // Move origin to center of the canvas vertically
  
  let frequency = map(mouseX, 0, width, 0.001, 0.05); // Adjust wave frequency with mouseX
  let amplitude = map(mouseY, 0, height, 20, waveHeight); // Adjust wave height with mouseY
  
  beginShape();
  
  let yOffset = yOffsetStart; // Starting point for Perlin noise
  
  for (let x = 0; x <= width; x += width / waveDetail) {
    // Perlin noise creates smooth, flowing variation in the Y direction
    let y = sin(x * frequency) * amplitude + map(noise(yOffset), 0, 1, -50, 50); // Combine sin wave with Perlin noise
    vertex(x, y); // Create the wave vertex point
    yOffset += 0.05; // Increment for smooth noise
  }
  
  endShape();
  
  yOffsetStart += 0.01; // Shift the noise offset gradually to create fluid motion
}
"
"2398679","Bouncing and shifting winds","mySketch","let world;
let balls = [];
let colors = [""#FF6347"", ""#1E90FF"", ""#32CD32"", ""#FFD700"", ""#FF69B4""];
let gravity = 1;
let wind = 0.01;

function setup() {
  let canvas = createCanvas(windowWidth, windowHeight);
  canvas.position(0, 0); // make canvas cover the screen
  canvas.style('z-index', '-1'); // ensure canvas stays behind other elements
  world = new World();
  for (let i = 0; i < 30; i++) {
    let x = random(width);
    let y = random(-100, 0);
    let radius = random(20, 40);
    let color = random(colors);
    balls.push(new Ball(x, y, radius, color));
  }
}

function draw() {
  background(30);
  world.gravity.y = gravity;
  for (let ball of balls) {
    ball.move();
    ball.applyForce(wind, 0);
    ball.display();
  }
}

function mousePressed() {
  let found = false;
  for (let i = balls.length - 1; i >= 0; i--) {
    let ball = balls[i];
    if (dist(mouseX, mouseY, ball.sprite.x, ball.sprite.y) < ball.r) {
      balls.splice(i, 1); // remove ball if clicked
      found = true;
      break;
    }
  }

  if (!found) {
    let radius = random(20, 40);
    let color = random(colors);
    let newBall = new Ball(mouseX, mouseY, radius, color);
    balls.push(newBall); // create a new ball if no object is clicked
  }
}

class Ball {
  constructor(x, y, r, col) {
    this.sprite = new Sprite(x, y, r * 2, r * 2);
    this.sprite.bounciness = 0.8;
    this.r = r;
    this.col = col;
  }

  move() {
    if (this.sprite.x > width || this.sprite.x < 0) {
      wind *= -1;
    }
  }

  applyForce(fx, fy) {
    this.sprite.vel.x += fx;
    this.sprite.vel.y += fy;
  }

  display() {
    noStroke();
    fill(this.col);
    ellipse(this.sprite.x, this.sprite.y, this.r * 2);
  }
}
"
"2396295","Ethereal Pulse Grid","mySketch","// Ethereal Pulse Grid: Interactive Physics-Driven Art

let colors = ['#f56983', '#f71735', '#067bc2', '#ffd91c', '#99d5f7', '#14234f'];
let backgroundColor;
let grid = [];
let gridCount = 20;
let gridSize;
let noiseFilter;
let connections = [];
let mouseInfluenceRadius = 200;
let springConstant = 0.05;
let damping = 0.85;

function setup() {
  createCanvas(900, 900);
  rectMode(CENTER);
  gridSize = width / gridCount;
  backgroundColor = color(20); // Dark background for better visibility
  
  // Initialize grid points with physics properties
  for (let i = 0; i < gridCount; i++) {
    for (let j = 0; j < gridCount; j++) {
      let x = i * gridSize + gridSize / 2;
      let y = j * gridSize + gridSize / 2;
      let type = int(random(0, 25)); // Shape type as per your superShape function
      let c1 = random(colors);
      let c2 = random(colors);
      grid.push(new GridPoint(x, y, gridSize - 4, type, c1, c2));
    }
  }
  
  // Establish connections between neighboring grid points
  for (let i = 0; i < gridCount; i++) {
    for (let j = 0; j < gridCount; j++) {
      let index = i * gridCount + j;
      let current = grid[index];
      
      // Connect to the right neighbor
      if (i < gridCount - 1) {
        let right = grid[(i + 1) * gridCount + j];
        connections.push(new Spring(current, right));
      }
      
      // Connect to the bottom neighbor
      if (j < gridCount - 1) {
        let bottom = grid[i * gridCount + (j + 1)];
        connections.push(new Spring(current, bottom));
      }
      
      // Optionally connect diagonally for a denser network
      if (i < gridCount - 1 && j < gridCount - 1) {
        let diag = grid[(i + 1) * gridCount + (j + 1)];
        connections.push(new Spring(current, diag));
      }
    }
  }
  
  // Initialize noise filter for subtle background texture
  noiseFilter = createImage(width, height);
  noiseFilter.loadPixels();
  for (let i = 0; i < noiseFilter.pixels.length; i += 4) {
    let noiseVal = random(50, 100);
    noiseFilter.pixels[i] = noiseVal;
    noiseFilter.pixels[i + 1] = noiseVal;
    noiseFilter.pixels[i + 2] = noiseVal;
    noiseFilter.pixels[i + 3] = 15; // Low alpha for subtle overlay
  }
  noiseFilter.updatePixels();
}

function draw() {
  // Apply semi-transparent background for trailing effect
  background(backgroundColor.levels[0], backgroundColor.levels[1], backgroundColor.levels[2], 25);
  
  // Overlay noise filter for texture
  image(noiseFilter, 0, 0, width, height);
  
  // Calculate mouse influence
  let mousePos = createVector(mouseX, mouseY);
  
  // Update and display connections (springs)
  for (let spring of connections) {
    spring.update();
    spring.display();
  }
  
  // Update and display grid points
  for (let point of grid) {
    // Apply mouse interaction forces
    let dir = p5.Vector.sub(mousePos, point.pos);
    let distance = dir.mag();
    if (distance < mouseInfluenceRadius) {
      dir.normalize();
      let forceMagnitude = map(distance, 0, mouseInfluenceRadius, 5, 0);
      let force = dir.mult(forceMagnitude);
      point.applyForce(force);
    }
    
    // Apply global damping
    point.vel.mult(damping);
    
    // Update physics
    point.update();
    
    // Display the shape
    point.display();
  }
}

// GridPoint Class with Physics
class GridPoint {
  constructor(x, y, w, type, c1, c2) {
    this.origin = createVector(x, y);
    this.pos = createVector(x, y);
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.w = w;
    this.type = type;
    this.c1 = c1;
    this.c2 = c2;
    this.angle = 0;
    this.angularVel = 0;
    this.angularAcc = 0;
  }
  
  applyForce(force) {
    this.acc.add(force);
  }
  
  update() {
    // Update velocity and position
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
    
    // Update rotation based on velocity
    this.angularAcc = this.vel.x * 0.001;
    this.angularVel += this.angularAcc;
    this.angularVel *= damping;
    this.angle += this.angularVel;
  }
  
  display() {
    push();
    translate(this.pos.x, this.pos.y);
    rotate(this.angle);
    
    // Dynamic coloring based on velocity
    let speed = this.vel.mag();
    let dynamicColor = lerpColor(color(this.c1), color(this.c2), map(speed, 0, 10, 0, 1));
    fill(dynamicColor);
    noStroke();
    
    // Draw the shape based on type
    superShape(0, 0, this.w, this.type, this.c1, this.c2);
    
    pop();
  }
}

// Spring Class to connect two GridPoints
class Spring {
  constructor(a, b) {
    this.a = a;
    this.b = b;
    this.restLength = p5.Vector.dist(a.pos, b.pos);
    this.k = springConstant;
  }
  
  update() {
    let force = p5.Vector.sub(this.b.pos, this.a.pos);
    let currentLength = force.mag();
    let x = currentLength - this.restLength;
    force.normalize();
    force.mult(this.k * x);
    this.a.applyForce(force);
    force.mult(-1);
    this.b.applyForce(force);
  }
  
  display() {
    stroke(200, 100);
    strokeWeight(2);
    line(this.a.pos.x, this.a.pos.y, this.b.pos.x, this.b.pos.y);
  }
}

// Enhanced SuperShape Function with More Visual Variety
function superShape(x, y, w, type, c1, c2) {
  push();
  translate(x, y);
  
  // Optional: Add subtle glow effect
  drawingContext.shadowBlur = 10;
  drawingContext.shadowColor = color(c2).toString();
  
  noStroke();
  
  switch(type) {
    case 0:
      // Checkerboard Pattern
      let n = 4;
      let ww = w / n;
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if ((i + j) % 2 === 0) {
            fill(c1);
          } else {
            fill(c2);
          }
          square(i * ww - w / 2 + ww / 2, j * ww - w / 2 + ww / 2, ww - 2);
        }
      }
      break;
    case 1:
      // Pulsating Triangle
      let offset = sin(frameCount * 0.05 + this.angle) * (w / 4);
      fill(c1);
      triangle(-w / 2, w / 2 + offset, w / 2, w / 2 + offset, 0, -w / 2 - offset);
      break;
    case 2:
      // Clustered Circles
      fill(c2);
      let d = w / 3;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          circle(i * d, j * d, d * 0.8);
        }
      }
      break;
    case 3:
      // Concentric Circles with Dynamic Fill
      noFill();
      stroke(c2);
      strokeWeight(w * 0.05);
      circle(0, 0, w * 0.8);
      fill(c1);
      noStroke();
      circle(0, 0, w * 0.3);
      break;
    case 4:
      // Star-like Shape
      fill(c1);
      beginShape();
      for (let i = 0; i < 5; i++) {
        let angle = radians(i * 72 - 90);
        let x = cos(angle) * (w / 2);
        let y = sin(angle) * (w / 2);
        vertex(x, y);
        angle += radians(36);
        x = cos(angle) * (w / 4);
        y = sin(angle) * (w / 4);
        vertex(x, y);
      }
      endShape(CLOSE);
      break;
    case 5:
      // Rotating Hexagon
      fill(c1);
      beginShape();
      for (let i = 0; i < 6; i++) {
        let angle = radians(i * 60);
        let x = cos(angle) * (w / 2);
        let y = sin(angle) * (w / 2);
        vertex(x, y);
      }
      endShape(CLOSE);
      break;
    case 6:
      // Fractal-like Nested Squares
      fill(c1);
      square(0, 0, w * 0.8);
      fill(c2);
      square(0, 0, w * 0.4);
      break;
    case 7:
      // Dynamic Wave Pattern
      noFill();
      stroke(c2);
      strokeWeight(w * 0.05);
      beginShape();
      for (let i = -w / 2; i <= w / 2; i += 10) {
        let y = sin(i * 0.1 + frameCount * 0.05) * (w / 4);
        vertex(i, y);
      }
      endShape();
      break;
    case 8:
      // Spiral Design
      noFill();
      stroke(c2);
      strokeWeight(w * 0.05);
      beginShape();
      for (let a = 0; a < TWO_PI * 3; a += 0.1) {
        let r = map(a, 0, TWO_PI * 3, 0, w / 2);
        let sx = r * cos(a);
        let sy = r * sin(a);
        vertex(sx, sy);
      }
      endShape();
      break;
    default:
      // Default Shape: Dynamic Polygon
      fill(c1);
      let sides = 5 + int(abs(sin(frameCount * 0.01)) * 5);
      beginShape();
      for (let i = 0; i < sides; i++) {
        let angle = map(i, 0, sides, 0, TWO_PI);
        let radius = w / 2 + sin(frameCount * 0.02 + angle) * (w / 4);
        let sx = radius * cos(angle);
        let sy = radius * sin(angle);
        vertex(sx, sy);
      }
      endShape(CLOSE);
      break;
  }
  
  pop();
}
"
"2396290","Kinetic Grid","mySketch","let backgroundColor;
let shapes = [];
let noiseFilter;
let gridCount = 18;
let gridSize;
let mouseForceRadius = 150;
let gravity;
let colors = ['#f56983', '#f71735', '#067bc2', '#ffd91c', '#99d5f7', '#14234f'];
let damping = 0.9;

function setup() {
  createCanvas(900, 900);
  rectMode(CENTER);
  gridSize = width / gridCount;
  backgroundColor = color(20); // Dark background for better visibility
  noiseFilter = createImage(width, height);
  
  // Initialize noise filter with subtle noise
  noiseFilter.loadPixels();
  for (let i = 0; i < noiseFilter.pixels.length; i += 4) {
    let noiseVal = noise(i * 0.0001, frameCount * 0.001) * 255;
    noiseFilter.pixels[i] = noiseVal;
    noiseFilter.pixels[i + 1] = noiseVal;
    noiseFilter.pixels[i + 2] = noiseVal;
    noiseFilter.pixels[i + 3] = 20; // Low alpha for subtle overlay
  }
  noiseFilter.updatePixels();

  // Initialize shapes grid with physics properties
  for (let i = 0; i < gridCount; i++) {
    for (let j = 0; j < gridCount; j++) {
      let x = i * gridSize + gridSize / 2;
      let y = j * gridSize + gridSize / 2;
      let type = int(random(0, 25)); // Shape type as per your superShape function
      let c1 = random(colors);
      let c2 = random(colors);
      shapes.push(new KineticShape(x, y, gridSize - 4, type, c1, c2));
    }
  }
}

function draw() {
  // Apply a semi-transparent background for trailing effect
  background(backgroundColor.levels[0], backgroundColor.levels[1], backgroundColor.levels[2], 25);
  
  // Overlay noise filter for texture
  image(noiseFilter, 0, 0, width, height);

  // Calculate mouse attraction/repulsion force
  let mousePos = createVector(mouseX, mouseY);
  
  for (let shape of shapes) {
    // Calculate distance to mouse
    let dir = p5.Vector.sub(mousePos, shape.pos);
    let distance = dir.mag();
    
    if (distance < mouseForceRadius) {
      dir.normalize();
      // Stronger force when closer to mouse
      let strength = map(distance, 0, mouseForceRadius, 5, 0);
      // Repel or attract based on mouse interaction
      let force = dir.mult(strength);
      shape.applyForce(force);
    }
    
    // Apply global gravity
    shape.applyForce(createVector(0, 0.05)); // Gentle downward force
    
    // Update physics
    shape.update();
    
    // Display the shape
    shape.display();
  }
}

// Optional: Save the canvas with 'S' key
function keyPressed() {
  if (key === 's' || key === 'S') {
    saveCanvas('InteractiveKineticGrid', 'png');
  }
}

// KineticShape Class with Physics
class KineticShape {
  constructor(x, y, w, type, c1, c2) {
    this.origin = createVector(x, y);
    this.pos = createVector(x, y);
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.w = w;
    this.type = type;
    this.c1 = c1;
    this.c2 = c2;
    this.angle = 0;
    this.angularVel = random(-0.02, 0.02);
    this.angularAcc = 0;
  }
  
  applyForce(force) {
    this.acc.add(force);
  }
  
  update() {
    // Update velocity and position
    this.vel.add(this.acc);
    this.vel.mult(damping); // Damping for friction
    this.pos.add(this.vel);
    this.acc.mult(0);
    
    // Update rotation
    this.angularVel += this.angularAcc;
    this.angularVel *= damping;
    this.angle += this.angularVel;
    this.angularAcc = 0;
    
    // Optional: Oscillate size or color based on movement
    // This can be expanded for more dynamic effects
  }
  
  display() {
    push();
    translate(this.pos.x, this.pos.y);
    rotate(this.angle);
    
    // Dynamic fill based on velocity magnitude
    let speed = this.vel.mag();
    let dynamicColor = lerpColor(color(this.c1), color(this.c2), map(speed, 0, 5, 0, 1));
    fill(dynamicColor);
    noStroke();
    
    // Draw the shape based on type
    superShape(0, 0, this.w, this.type, this.c1, this.c2);
    
    pop();
  }
}

// SuperShape Function with Enhanced Visuals
function superShape(x, y, w, type, c1, c2) {
  push();
  translate(x, y);
  
  // Optional: Add glow effect
  drawingContext.shadowBlur = 20;
  drawingContext.shadowColor = color(c2).toString();
  
  noStroke();
  fill(c1);
  
  switch(type) {
    case 0:
      // Checkerboard Pattern
      let n = 4;
      let ww = w / n;
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          if ((i + j) % 2 === 0) {
            fill(c1);
          } else {
            fill(c2);
          }
          square(i * ww - w / 2 + ww / 2, j * ww - w / 2 + ww / 2, ww - 2);
        }
      }
      break;
    case 1:
      // Dynamic Triangle
      fill(c1);
      let offset = sin(frameCount * 0.05) * (w / 4);
      triangle(-w / 2, w / 2 + offset, w / 2, w / 2 + offset, 0, -w / 2 - offset);
      break;
    case 2:
      // Clustered Circles
      fill(c2);
      let d = w / 3;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          circle(i * d, j * d, d * 0.8);
        }
      }
      break;
    case 3:
      // Concentric Circles with Dynamic Fill
      noFill();
      stroke(c2);
      strokeWeight(w * 0.05);
      circle(0, 0, w * 0.8);
      fill(c1);
      noStroke();
      circle(0, 0, w * 0.3);
      break;
    case 4:
      // Star-like Triangle
      fill(c1);
      triangle(w / 2, w / 2, -w / 2, -w / 2, w / 2, -w / 2);
      break;
    case 5:
      // Pointed Triangle
      fill(c1);
      triangle(w / 2, w / 2, -w / 2, w / 2, 0, -w / 2);
      break;
    case 6:
      // Central Circle
      fill(c1);
      circle(0, 0, w * 0.8);
      break;
    case 7:
      // Cross Lines
      stroke(c2);
      strokeWeight(w * 0.1);
      line(0, w * 0.3, 0, -w * 0.3);
      line(w * 0.3, 0, -w * 0.3, 0);
      break;
    case 8:
      // Grid of Small Circles
      let m = 3;
      let ww_small = (w * 0.8) / m;
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < m; j++) {
          circle(i * ww_small - (w * 0.4) + ww_small / 2, j * ww_small - (w * 0.4) + ww_small / 2, ww_small * 0.75);
        }
      }
      break;
    // Add more cases (9 to 24) with unique visual transformations
    // For brevity, only a few are implemented here
    default:
      // Default Square
      fill(c1);
      square(0, 0, w * 0.8);
      break;
  }
  
  pop();
}
"
"2396279","Luminous Flow","mySketch","let particles = [];
let maxParticles = 500;
let palette = [];
let backgroundColor;
let attractor;

function setup() {
  createCanvas(800, 800);
  colorMode(HSB, 360, 100, 100, 100);
  backgroundColor = color(0, 0, 0);
  
  // Define a vibrant color palette
  palette = [
    color(210, 100, 100, 80),
    color(30, 100, 100, 80),
    color(120, 100, 100, 80),
    color(270, 100, 100, 80),
    color(330, 100, 100, 80)
  ];
  
  // Initialize attractor at the center
  attractor = createVector(width / 2, height / 2);
}

function draw() {
  // Semi-transparent background for trailing effect
  background(backgroundColor.levels[0], backgroundColor.levels[1], backgroundColor.levels[2], 10);
  
  // Update attractor position based on mouse
  attractor.x = mouseX;
  attractor.y = mouseY;
  
  // Emit new particles
  if (particles.length < maxParticles) {
    particles.push(new Particle(attractor.x, attractor.y));
  }
  
  // Update and display particles
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].display();
    if (particles[i].isDead()) {
      particles.splice(i, 1);
    }
  }
  
  // Optional: Visualize the attractor
  noStroke();
  fill(0, 0, 100, 50);
  ellipse(attractor.x, attractor.y, 20, 20);
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    let angle = random(TWO_PI);
    let speed = random(1, 3);
    this.vel = p5.Vector.fromAngle(angle).mult(speed);
    this.acc = createVector(0, 0);
    this.lifespan = 255;
    this.size = random(4, 8);
    this.color = random(palette);
  }
  
  applyForce(force) {
    this.acc.add(force);
  }
  
  update() {
    // Calculate attraction towards attractor
    let force = p5.Vector.sub(attractor, this.pos);
    let distance = force.mag();
    distance = constrain(distance, 5, 25);
    force.normalize();
    let strength = map(distance, 5, 25, 0.5, 0.05);
    force.mult(strength);
    this.applyForce(force);
    
    // Update velocity and position
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
    
    // Apply friction
    this.vel.mult(0.95);
    
    // Fade out
    this.lifespan -= 2;
  }
  
  display() {
    noStroke();
    fill(hue(this.color), saturation(this.color), brightness(this.color), this.lifespan / 2);
    ellipse(this.pos.x, this.pos.y, this.size, this.size);
    
    // Draw trailing lines
    stroke(hue(this.color), saturation(this.color), brightness(this.color), this.lifespan / 2);
    strokeWeight(2);
    line(this.pos.x, this.pos.y, this.pos.x - this.vel.x * 2, this.pos.y - this.vel.y * 2);
  }
  
  isDead() {
    return this.lifespan <= 0;
  }
}

function mousePressed() {
  // On mouse press, emit a burst of particles
  for (let i = 0; i < 50; i++) {
    particles.push(new Particle(mouseX, mouseY));
  }
}

function keyPressed() {
  if (key === 's' || key === 'S') {
    saveCanvas('LuminousFlow', 'png');
  }
}
"
"2396272","Radiant Flux","mySketch","let layers = [];
let numLayers = 5;
let angleOffset = 0;
let colorPalette = [];

function setup() {
  createCanvas(800, 800);
  angleMode(DEGREES);
  noFill();
  
  // Define a vibrant color palette
  colorPalette = [
    color('#FF3CAC'),
    color('#784BA0'),
    color('#2B86C5'),
    color('#56ab2f'),
    color('#f2994a'),
    color('#eb3349'),
    color('#34e89e')
  ];
  
  // Initialize layers with varying properties
  for (let i = 0; i < numLayers; i++) {
    layers.push(new Layer(
      map(i, 0, numLayers, 50, width / 2),
      map(i, 0, numLayers, 3, 1),
      random(3, 6),
      random(colorPalette)
    ));
  }
  
  background(10);
}

function draw() {
  background(10, 20); // Semi-transparent background for motion trails
  
  translate(width / 2, height / 2);
  
  for (let layer of layers) {
    layer.update();
    layer.display();
  }
  
  // Interactive rotation based on mouse position
  let rotationSpeed = map(mouseX, 0, width, -5, 5);
  rotate(rotationSpeed);
}

class Layer {
  constructor(radius, speed, detail, clr) {
    this.radius = radius;
    this.speed = speed;
    this.detail = detail; // Number of points in the polygon
    this.angle = random(360);
    this.clr = clr;
    this.noiseOffset = random(1000);
    this.noiseIncrement = 0.005;
  }
  
  update() {
    this.angle += this.speed;
    // Slight perturbation using noise for organic movement
    this.noiseOffset += this.noiseIncrement;
    this.currentRadius = this.radius + noise(this.noiseOffset) * 20;
  }
  
  display() {
    stroke(this.clr);
    strokeWeight(2);
    beginShape();
    for (let a = 0; a < 360; a += 360 / this.detail) {
      let x = this.currentRadius * cos(a + this.angle);
      let y = this.currentRadius * sin(a + this.angle);
      vertex(x, y);
    }
    endShape(CLOSE);
  }
}

function keyPressed() {
  if (key === 's' || key === 'S') {
    saveCanvas('RadiantFlux', 'png');
  }
}
"
"2396267","Dynamic Harmony","mySketch","let grid = [];
let gridCols = 25;
let gridRows = 25;
let spacing;
let palette = [];
let lineThreshold = 100;

function setup() {
  createCanvas(800, 800);
  colorMode(HSB, 360, 100, 100, 100);
  spacing = width / gridCols;
  
  // Define a vibrant color palette
  palette = [
    color(10, 80, 100, 80),
    color(45, 80, 100, 80),
    color(80, 80, 100, 80),
    color(160, 80, 100, 80),
    color(220, 80, 100, 80),
    color(300, 80, 100, 80)
  ];
  
  // Initialize grid points
  for (let i = 0; i < gridCols; i++) {
    for (let j = 0; j < gridRows; j++) {
      let x = i * spacing + spacing / 2;
      let y = j * spacing + spacing / 2;
      grid.push(new GridPoint(x, y));
    }
  }
  background(0);
}

function draw() {
  background(0, 0, 0, 10); // Semi-transparent background for trailing effect
  for (let point of grid) {
    point.update();
    point.display();
  }
  
  // Draw connections
  strokeWeight(1);
  for (let i = 0; i < grid.length; i++) {
    for (let j = i + 1; j < grid.length; j++) {
      let d = dist(grid[i].currentX, grid[i].currentY, grid[j].currentX, grid[j].currentY);
      if (d < lineThreshold) {
        let alpha = map(d, 0, lineThreshold, 100, 0);
        stroke(200, 30, 100, alpha);
        line(grid[i].currentX, grid[i].currentY, grid[j].currentX, grid[j].currentY);
      }
    }
  }
}

class GridPoint {
  constructor(x, y) {
    this.originX = x;
    this.originY = y;
    this.currentX = x;
    this.currentY = y;
    this.noiseOffsetX = random(1000);
    this.noiseOffsetY = random(2000);
    this.noiseSpeed = 0.002;
    this.sizeBase = spacing * 0.3;
    this.sizeVariation = spacing * 0.2;
    this.hue = random(360);
  }
  
  update() {
    // Drift using Perlin noise
    let noiseX = noise(this.noiseOffsetX) - 0.5;
    let noiseY = noise(this.noiseOffsetY) - 0.5;
    this.currentX = this.originX + noiseX * spacing * 0.5;
    this.currentY = this.originY + noiseY * spacing * 0.5;
    
    // Update noise offsets
    this.noiseOffsetX += this.noiseSpeed;
    this.noiseOffsetY += this.noiseSpeed;
    
    // Update hue for smooth color transitions
    this.hue = (this.hue + 0.1) % 360;
  }
  
  display() {
    noStroke();
    // Calculate size using sine wave for pulsating effect
    let size = this.sizeBase + this.sizeVariation * sin(frameCount * 0.05 + this.originX * 0.1 + this.originY * 0.1);
    fill(this.hue, 80, 100, 80);
    ellipse(this.currentX, this.currentY, size, size);
  }
}
"
"2395984","Magnetic Field and Gravity","mySketch","// Magnetic Field Simulation with Gravity and Interactive Fields

let particles = [];
let magneticFields = [];
let gravity;

const maxParticles = 1000;

let sliders = {};
let params = {
  magneticStrength: 2
};

function setup() {
  createCanvas(800, 600);
  background(0);
  
  // Initialize gravity
  gravity = createVector(0, 0.2);
  
  // Create sliders
  createSliders();
}

function draw() {
  background(0, 20); // Trail effect
  
  // Update magnetic strength from slider
  params.magneticStrength = sliders['magneticStrength'].value();
  
  // Display field strength value
  displayFields();
  
  // Spawn new particles
  if (frameCount % 2 === 0 && particles.length < maxParticles) {
    particles.push(new Particle(random(width), 0));
  }
  
  // Update and display particles
  for (let p of particles) {
    p.applyForce(gravity.copy());
    
    // Apply magnetic forces
    for (let field of magneticFields) {
      let force = field.calculateForce(p);
      p.applyForce(force);
    }
    
    p.update();
    p.display();
  }
  
  // Remove particles that are out of bounds
  particles = particles.filter(p => p.position.y < height + 50);
  
  // Display magnetic fields
  for (let field of magneticFields) {
    field.display();
  }
}

// Particle class
class Particle {
  constructor(x, y) {
    this.position = createVector(x, y);
    this.velocity = createVector(0, random(0.5, 1.5)); // Reduced initial velocity for smoother motion
    this.acceleration = createVector(0, 0);
    this.size = 4;
    this.color = color(0, 255, 255);
  }
  
  applyForce(force) {
    this.acceleration.add(force);
  }
  
  update() {
    this.velocity.add(this.acceleration);
    this.position.add(this.velocity);
    this.acceleration.mult(0); // Reset acceleration
    
    // Keep particles within canvas horizontally
    if (this.position.x > width) this.position.x = 0;
    if (this.position.x < 0) this.position.x = width;
    
    // Optional: Bounce at bottom (disabled to keep particles falling smoothly)
    // if (this.position.y > height) {
    //   this.position.y = height;
    //   this.velocity.y *= -0.5;
    // }
  }
  
  display() {
    noStroke();
    fill(this.color);
    ellipse(this.position.x, this.position.y, this.size);
  }
}

// MagneticField class
class MagneticField {
  constructor(x, y, strength) {
    this.position = createVector(x, y);
    this.strength = strength;
    this.radius = 100;
  }
  
  calculateForce(particle) {
    let dir = p5.Vector.sub(this.position, particle.position);
    let distance = dir.mag();
    if (distance < this.radius && distance > 10) { // Avoid division by zero and extremely strong forces
      // Calculate perpendicular force
      let forceDir = createVector(-dir.y, dir.x);
      forceDir.normalize();
      
      // Force magnitude decreases with distance
      let forceMag = (this.strength * (1 - distance / this.radius));
      let force = forceDir.mult(forceMag);
      
      return force;
    } else {
      return createVector(0, 0);
    }
  }
  
  display() {
    noFill();
    stroke(255, 0, 255);
    strokeWeight(2);
    ellipse(this.position.x, this.position.y, this.radius * 2);
    
    // Magnetic field direction indicator
    push();
    translate(this.position.x, this.position.y);
    rotate(frameCount * 0.05);
    stroke(255, 0, 255);
    line(0, 0, 20, 0);
    pop();
  }
}

// Handle mouse clicks to add/remove magnetic fields
function mousePressed() {
  // Ensure clicks are within the canvas
  if (mouseX < 0 || mouseX > width || mouseY < 0 || mouseY > height) return;
  
  // Check if clicked near an existing field
  let clicked = false;
  for (let i = 0; i < magneticFields.length; i++) {
    let field = magneticFields[i];
    if (p5.Vector.dist(createVector(mouseX, mouseY), field.position) < field.radius) {
      magneticFields.splice(i, 1);
      clicked = true;
      break;
    }
  }
  
  // If not clicked on an existing field, add a new one
  if (!clicked && magneticFields.length < 10) {
    magneticFields.push(new MagneticField(mouseX, mouseY, params.magneticStrength));
  }
}

// Function to create sliders with labels
function createSliders() {
  // Magnetic Field Strength Slider
  let label = createP('Magnetic Field Strength');
  label.style('color', '#00FFFF');
  label.position(20, height + 10); // Positioned below the canvas
  label.style('font-size', '14px');
  
  sliders['magneticStrength'] = createSlider(1, 5, params.magneticStrength, 0.1);
  sliders['magneticStrength'].position(20, height + 30);
  sliders['magneticStrength'].style('width', '200px');
  
  // Instructions
  let instruction = createP('Click on the canvas to add/remove magnetic fields.');
  instruction.style('color', '#00FFFF');
  instruction.position(250, height + 10);
  instruction.style('font-size', '14px');
}

// Function to display current field strength
function displayFields() {
  noStroke();
  fill(0, 255, 255);
  textSize(14);
  text(`Magnetic Strength: ${params.magneticStrength.toFixed(1)}`, 20, height - 20);
}
"
"2395978","Magnetic Field","mySketch","let particles = [];
let fieldStrength = 1;
let sliders = {};

function setup() {
  createCanvas(800, 600);
  background(0);
  createSliders();
  
  // Initialize particles on different field lines
  let numParticles = 5;
  let maxRadius = min(width, height) / 2 - 50;
  let step = maxRadius / numParticles;
  
  for (let i = 1; i <= numParticles; i++) {
    particles.push(new Particle(i * step, fieldStrength));
  }
}

function draw() {
  background(0, 20);
  
  // Update field strength from slider
  fieldStrength = sliders['fieldStrength'].value();
  
  // Draw magnetic field lines
  stroke(0, 255, 255, 100);
  strokeWeight(1);
  noFill();
  let maxRadius = min(width, height) / 2 - 50;
  for (let r = 50; r <= maxRadius; r += 50) {
    ellipse(0, 0, r * 2);
  }
  
  // Update and display particles
  for (let p of particles) {
    p.update(fieldStrength);
    p.display();
  }
  
  // Display slider labels
  fill(0, 255, 255);
  noStroke();
  textSize(14);
  text(""Magnetic Field Strength"", sliders['fieldStrength'].x + 10, sliders['fieldStrength'].y - 10);
}

class Particle {
  constructor(r, field) {
    this.radius = r;
    this.angle = random(TWO_PI);
    this.speed = map(field, 0.1, 5, 0.005, 0.05);
    this.color = color(0, 255, 255);
  }
  
  update(field) {
    this.speed = map(field, 0.1, 5, 0.005, 0.05);
    this.angle += this.speed;
  }
  
  display() {
    let x = this.radius * cos(this.angle);
    let y = this.radius * sin(this.angle);
    
    fill(this.color);
    noStroke();
    ellipse(x, y, 8);
  }
}

function createSliders() {
  // Magnetic Field Strength Slider
  createP('').style('color', '#00FFFF').position(20, height - 60);
  sliders['fieldStrength'] = createSlider(0.1, 5, 1, 0.1);
  sliders['fieldStrength'].position(20, height - 40);
}
"
"2395974","Charged Particle","mySketch","// Charged Particle in Electric and Magnetic Fields

let particle;
let trails = [];
const maxTrails = 500;

let sliders = {};
let params = {
  E_x: 1,
  E_y: 0,
  B_z: 0.5
};

function setup() {
  createCanvas(800, 600);
  background(0);
  
  // Initialize particle at center with zero velocity
  particle = new Particle(createVector(width / 2, height / 2), createVector(0, 0));
  
  // Create sliders
  createSliders();
  
  // Text settings
  textSize(14);
}

function draw() {
  background(0, 20); // Trail effect
  
  // Update parameters from sliders
  params.E_x = sliders['E_x'].value();
  params.E_y = sliders['E_y'].value();
  params.B_z = sliders['B_z'].value();
  
  // Display field values
  displayFields();
  
  // Calculate Lorentz force: F = E + v x B
  let E = createVector(params.E_x, params.E_y);
  let B = createVector(0, 0, params.B_z);
  let v = createVector(particle.velocity.x, particle.velocity.y, 0);
  let F = p5.Vector.add(E, p5.Vector.cross(v, B));
  
  // Update particle with damping
  particle.applyForce(p5.Vector.mult(F, 0.1)); // Scale force
  particle.applyDamping(0.99); // Damping factor
  particle.update();
  particle.display();
  
  // Store trail
  trails.push(particle.position.copy());
  if (trails.length > maxTrails) {
    trails.shift();
  }
  
  // Draw trails
  noFill();
  stroke(0, 255, 255, 100);
  strokeWeight(2);
  beginShape();
  for (let pos of trails) {
    vertex(pos.x, pos.y);
  }
  endShape();
}

// Particle class
class Particle {
  constructor(position, velocity) {
    this.position = position;
    this.velocity = velocity;
    this.mass = 1;
    this.charge = 1;
  }
  
  applyForce(force) {
    // F = m * a => a = F / m
    let acceleration = p5.Vector.div(force, this.mass);
    this.velocity.add(acceleration);
  }
  
  applyDamping(damping) {
    this.velocity.mult(damping);
  }
  
  update() {
    this.position.add(this.velocity);
    
    // Wrap around the edges
    if (this.position.x > width) this.position.x = 0;
    if (this.position.x < 0) this.position.x = width;
    if (this.position.y > height) this.position.y = 0;
    if (this.position.y < 0) this.position.y = height;
  }
  
  display() {
    fill(0, 255, 255);
    noStroke();
    ellipse(this.position.x, this.position.y, 8);
  }
}

// Function to create sliders with labels
function createSliders() {
  // Electric Field X
  createP('Electric Field X (E_x)').style('color', '#00FFFF').position(20, height - 120);
  sliders['E_x'] = createSlider(-5, 5, params.E_x, 0.1);
  sliders['E_x'].position(200, height - 110);
  
  // Electric Field Y
  createP('Electric Field Y (E_y)').style('color', '#00FFFF').position(20, height - 80);
  sliders['E_y'] = createSlider(-5, 5, params.E_y, 0.1);
  sliders['E_y'].position(200, height - 70);
  
  // Magnetic Field Z
  createP('Magnetic Field Z (B_z)').style('color', '#00FFFF').position(20, height - 40);
  sliders['B_z'] = createSlider(-5, 5, params.B_z, 0.1);
  sliders['B_z'].position(200, height - 30);
}

// Function to display field values
function displayFields() {
  noStroke();
  fill(0, 255, 255);
  text(`E_x: ${params.E_x.toFixed(1)}`, 420, height - 100);
  text(`E_y: ${params.E_y.toFixed(1)}`, 420, height - 60);
  text(`B_z: ${params.B_z.toFixed(1)}`, 420, height - 20);
}
"
"2395970","Lorenz Attractor (with sliders))","mySketch","let sliders = {};
let params = {
  sigma: 10,
  rho: 28,
  beta: 8 / 3
};

let x = 0.1;
let y = 0;
let z = 0;

let dt = 0.01;

function setup() {
  // Create the canvas
  createCanvas(800, 600);
  
  // Create sliders with labels and position them below the canvas
  createSliderWithLabel('Sigma (σ)', 0, 50, params.sigma, 0.1, 'sigma', 10);
  createSliderWithLabel('Rho (ρ)', 0, 50, params.rho, 0.1, 'rho', 60);
  createSliderWithLabel('Beta (β)', 0, 10, params.beta, 0.1, 'beta', 110);
  
  // Set background to black
  background(0);
}

function draw() {
  // Update parameters from sliders
  params.sigma = sliders['sigma'].value();
  params.rho = sliders['rho'].value();
  params.beta = sliders['beta'].value();
  
  // Calculate the next point in the Lorenz system
  let dx = params.sigma * (y - x) * dt;
  let dy = (x * (params.rho - z) - y) * dt;
  let dz = (x * y - params.beta * z) * dt;
  
  x += dx;
  y += dy;
  z += dz;
  
  // Map x and y to screen coordinates
  let scaleFactor = 10;
  let screenX = map(x, -30, 30, 0, width);
  let screenY = map(y, -30, 30, height, 0);
  
  // Draw the point
  stroke(0, 255, 255);
  strokeWeight(2);
  point(screenX, screenY);
  
  // Optional: Implement trail effect by using semi-transparent background
  // Uncomment the following line to enable trails
  // background(0, 20);
}

function createSliderWithLabel(labelText, min, max, initial, step, key, yPosition) {
  // Create a label
  let label = createP(labelText);
  label.style('color', '#FFFFFF'); // White color for readability
  label.position(50, height - 150 + yPosition); // Adjust positions based on yPosition
  label.style('font-size', '14px');
  
  // Create a slider
  sliders[key] = createSlider(min, max, initial, step);
  sliders[key].style('width', '200px');
  sliders[key].position(250, height - 135 + yPosition); // Position sliders next to labels
}
"
"2395911","Hypotrochoid","mySketch","let sliders = {};
let params = {
  R: 150,    // Radius of the fixed circle
  r: 75,     // Radius of the rolling circle
  d: 100,    // Distance from the center of the rolling circle to the tracing point
};

let theta = 0;      // Angle parameter
let rotationSpeed = 0.02; // Speed of rotation

let wave = [];      // Array to store wave points

function setup() {
  // Create the canvas
  createCanvas(800, 600); // Increased height to accommodate sliders
  
  // Create sliders with labels and position them below the canvas
  createSliderWithLabel('R (Fixed Circle Radius)', 50, 300, params.R, 1, 'R', 10);
  createSliderWithLabel('r (Rolling Circle Radius)', 10, 150, params.r, 1, 'r', 60);
  createSliderWithLabel('d (Tracing Point Distance)', 10, 200, params.d, 1, 'd', 110);
  
  // Set the initial background
  background(0);
}

function draw() {
  background(0, 20); // Semi-transparent background for trail effect
  
  // Update parameters from sliders
  params.R = sliders['R'].value();
  params.r = sliders['r'].value();
  params.d = sliders['d'].value();
  
  // Translate to the center of the canvas
  translate(width / 2, height / 2 - 50);
  
  // Calculate current position using Hypotrochoid equations
  let x = (params.R - params.r) * cos(theta) + params.d * cos(((params.R - params.r) / params.r) * theta);
  let y = (params.R - params.r) * sin(theta) - params.d * sin(((params.R - params.r) / params.r) * theta);
  
  // Draw the fixed circle
  noFill();
  stroke(255, 100);
  strokeWeight(1);
  ellipse(0, 0, params.R * 2);
  
  // Calculate the position of the rolling circle
  let rollingX = (params.R - params.r) * cos(theta);
  let rollingY = (params.R - params.r) * sin(theta);
  
  // Draw the rolling circle
  stroke(255, 100);
  ellipse(rollingX, rollingY, params.r * 2);
  
  // Draw the line from the center of the rolling circle to the tracing point
  stroke(255);
  line(rollingX, rollingY, x, y);
  
  // Draw the tracing point
  fill(255);
  noStroke();
  ellipse(x, y, 5);
  
  // Store the y-coordinate for the wave
  wave.unshift(y);
  
  // Translate to draw the wave on the side
  push();
  translate(params.R + 50, 0);
  
  // Draw the wave line
  stroke(0, 255, 255);
  line(0, 0, 0, wave[0]);
  
  // Draw the wave
  beginShape();
  noFill();
  stroke(0, 255, 255);
  for (let i = 0; i < wave.length; i++) {
    vertex(i, wave[i]);
  }
  endShape();
  pop();
  
  // Increment theta
  theta += rotationSpeed;
  
  // Limit the wave array length
  if (wave.length > width - (params.R * 2)) {
    wave.pop();
  }
}

// Function to create a slider with its label and position it
function createSliderWithLabel(labelText, min, max, initial, step, key, yPosition) {
  // Create a label
  let label = createP(labelText);
  label.style('color', '#BBBBBB');
  label.position(50, height - 200 + yPosition); // Position labels below the canvas
  label.style('font-size', '14px');
  
  // Create a slider
  sliders[key] = createSlider(min, max, initial, step);
  sliders[key].style('width', '200px');
  sliders[key].position(250, height - 185 + yPosition); // Position sliders next to labels
}
"
"2395910","Superformula","mySketch","let sliders = {};
let params = {
  m: 6,
  a: 1,
  b: 1,
  n1: 1,
  n2: 7,
  n3: 1.5
};

let angle = 0;

function setup() {
  // Create the canvas
  createCanvas(800, 600); // Increased height to accommodate sliders
  
  // Create sliders with labels and position them below the canvas
  createSliderWithLabel('m (Symmetry)', 0, 12, params.m, 1, 'm', 10);
  createSliderWithLabel('a (Scale X)', 0.1, 2, params.a, 0.1, 'a', 60);
  createSliderWithLabel('b (Scale Y)', 0.1, 2, params.b, 0.1, 'b', 110);
  createSliderWithLabel('n1 (Shape)', 0.1, 10, params.n1, 0.1, 'n1', 160);
  createSliderWithLabel('n2 (Shape)', 0.1, 10, params.n2, 0.1, 'n2', 210);
  createSliderWithLabel('n3 (Shape)', 0.1, 10, params.n3, 0.1, 'n3', 260);
  
  // Set the initial background
  background(0);
}

function draw() {
  background(0, 20); // Semi-transparent background for trail effect
  
  // Translate to the center of the canvas
  translate(width / 2, height / 2 - 50);
  
  // Apply rotation for dynamic effect
  rotate(angle);
  
  // Update parameters from sliders
  params.m = sliders['m'].value();
  params.a = sliders['a'].value();
  params.b = sliders['b'].value();
  params.n1 = sliders['n1'].value();
  params.n2 = sliders['n2'].value();
  params.n3 = sliders['n3'].value();
  
  // Draw the Superformula shape
  noFill();
  stroke(0, 255, 255);
  strokeWeight(2);
  beginShape();
  for (let theta = 0; theta < TWO_PI; theta += 0.01) {
    let r = superformula(theta, params);
    let x = r * cos(theta);
    let y = r * sin(theta);
    vertex(x, y);
  }
  endShape(CLOSE);
  
  // Increment the rotation angle
  angle += 0.005;
}

// Function to compute the Superformula
function superformula(theta, params) {
  let part1 = abs((1 / params.a) * cos(params.m * theta / 4));
  part1 = pow(part1, params.n2);
  
  let part2 = abs((1 / params.b) * sin(params.m * theta / 4));
  part2 = pow(part2, params.n3);
  
  let r = pow(part1 + part2, -1 / params.n1);
  return r;
}

// Function to create a slider with its label and position it
function createSliderWithLabel(labelText, min, max, initial, step, key, yPosition) {
  // Create a label
  let label = createP(labelText);
  label.style('color', '#BBBBBB');
  label.position(50, height - 200 + yPosition); // Position labels below the canvas
  label.style('font-size', '14px');
  
  // Create a slider
  sliders[key] = createSlider(min, max, initial, step);
  sliders[key].style('width', '200px');
  sliders[key].position(200, height - 185 + yPosition); // Position sliders next to labels
}
"
"2395900","Lissajous Curve Controls","mySketch","let time = 0;
let wave = [];
let sliders = {};
let params = {
  freqX: 3,
  freqY: 2,
  phase: 0,
  amplitudeX: 75,
  amplitudeY: 75,
  speed: 0.02
};

function setup() {
  // Create the canvas
  createCanvas(800, 500); // Increased height to accommodate sliders
  
  // Create sliders with labels and position them below the canvas
  createSliderWithLabel('Frequency X', 1, 10, params.freqX, 1, 'freqX', 10);
  createSliderWithLabel('Frequency Y', 1, 10, params.freqY, 1, 'freqY', 60);
  createSliderWithLabel('Phase Shift', 0, TWO_PI, params.phase, 0.01, 'phase', 110);
  createSliderWithLabel('Amplitude X', 50, 150, params.amplitudeX, 1, 'amplitudeX', 160);
  createSliderWithLabel('Amplitude Y', 50, 150, params.amplitudeY, 1, 'amplitudeY', 210);
  createSliderWithLabel('Speed', 0.01, 0.1, params.speed, 0.005, 'speed', 260);
  
  // Set the initial background
  background(0);
}

function draw() {
  background(0, 50); // Semi-transparent background for trail effect
  translate(150, height / 2 - 50); // Adjusted translation for increased canvas height

  // Update parameters from sliders
  params.freqX = sliders.freqX.value();
  params.freqY = sliders.freqY.value();
  params.phase = sliders.phase.value();
  params.amplitudeX = sliders.amplitudeX.value();
  params.amplitudeY = sliders.amplitudeY.value();
  params.speed = sliders.speed.value();

  // Draw X oscillation
  let xPrev = 0;
  let xRadius = params.amplitudeX;
  stroke(255, 100);
  noFill();
  ellipse(xPrev, 0, xRadius * 2);
  let x = xRadius * cos(params.freqX * time);
  stroke(255);
  line(xPrev, 0, x, 0);
  fill(255);
  ellipse(x, 0, 8);

  // Draw Y oscillation
  let yPrev = 0;
  let yRadius = params.amplitudeY;
  stroke(255, 100);
  noFill();
  ellipse(x, 0, yRadius * 2);
  let y = yRadius * sin(params.freqY * time + params.phase);
  stroke(255);
  line(x, yPrev, x, y);
  fill(255);
  ellipse(x, y, 8);

  // Draw the resulting wave
  wave.unshift(y);

  translate(200, 0);
  stroke(255);
  line(x, y, 0, wave[0]);

  // Draw the Lissajous curve
  beginShape();
  noFill();
  stroke(0, 255, 0);
  for (let i = 0; i < wave.length; i++) {
    vertex(i, wave[i]);
  }
  endShape();

  time += params.speed;

  // Limit the wave array length
  if (wave.length > width - 200) {
    wave.pop();
  }
}

// Function to create a slider with its label and position it
function createSliderWithLabel(labelText, min, max, initial, step, key, yPosition) {
  // Create a label
  let label = createP(labelText);
  label.style('color', '#fff');
  label.position(10, height - 240 + yPosition); // Adjusted position based on yPosition
  
  // Create a slider
  sliders[key] = createSlider(min, max, initial, step);
  sliders[key].style('width', '150px');
  sliders[key].position(100, height - 230 + yPosition); // Position slider next to label
}
"
"2395873","Harmonic Flow","mySketch","let particles = [];
let numParticles = 500;
let t = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 1); // Set color mode to HSB with alpha from 0 to 1
  background(0);
  noStroke();
  
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  // Semi-transparent background for trailing effect
  background(0, 0, 0, 0.05);
  t += 0.01;

  for (let p of particles) {
    p.update();
    p.show();
  }
}

function mouseMoved() {
  interactWithParticles(mouseX, mouseY);
}

function touchMoved() {
  interactWithParticles(mouseX, mouseY);
  return false; // Prevent default behavior
}

function interactWithParticles(x, y) {
  for (let p of particles) {
    let d = dist(p.pos.x, p.pos.y, x, y);
    if (d < 100) {
      let angle = atan2(p.pos.y - y, p.pos.x - x);
      p.vel.x += cos(angle) * 0.5;
      p.vel.y += sin(angle) * 0.5;
    }
  }
}

class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(0, 0);
    this.size = random(2, 5);
    this.hue = random(360);
  }

  update() {
    let angle = noise(this.pos.x * 0.005, this.pos.y * 0.005, t) * TWO_PI * 2;
    let v = p5.Vector.fromAngle(angle);
    v.mult(0.5);
    this.vel.add(v);
    this.vel.limit(2);
    this.pos.add(this.vel);

    // Wrap around the edges
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }

  show() {
    fill((this.hue + frameCount * 0.5) % 360, 80, 100, 0.8);
    ellipse(this.pos.x, this.pos.y, this.size);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2392444","Snow Simulation","mySketch","let Engine = Matter.Engine,
    Render = Matter.Render,
    World = Matter.World,
    Bodies = Matter.Bodies,
    Body = Matter.Body,
    Composite = Matter.Composite,
    Composites = Matter.Composites,
    Common = Matter.Common,
    Events = Matter.Events;

let engine;
let world;
let particles = [];
let obstacles = [];
let ground;
let timer = 0;
let resetTime = 20000; // 20 seconds in milliseconds

function setup() {
  createCanvas(600, 800);
  engine = Engine.create();
  world = engine.world;
  world.gravity.y = 1;

  // Create ground
  ground = Bodies.rectangle(width / 2, height + 50, width, 100, {
    isStatic: true,
    render: { visible: false }
  });
  World.add(world, ground);

  // Create obstacles
  createObstacles();

  // Run the engine
  Engine.run(engine);
}

function draw() {
  background(30, 144, 255);

  // Add water particles
  if (frameCount % 2 === 0) {
    let particle = Bodies.circle(random(0, width), -50, 5, {
      restitution: 0.1,
      friction: 0.1,
      density: 0.001,
      render: { fillStyle: 'aqua' }
    });
    particles.push(particle);
    World.add(world, particle);
  }

  // Draw particles
  fill(173, 216, 230);
  noStroke();
  for (let i = 0; i < particles.length; i++) {
    let pos = particles[i].position;
    ellipse(pos.x, pos.y, 10);
  }

  // Draw obstacles
  fill(139, 69, 19);
  for (let i = 0; i < obstacles.length; i++) {
    drawVertices(obstacles[i].vertices);
  }

  // Draw ground
  fill(0, 100, 0);
  drawVertices(ground.vertices);

  // Timer to reset simulation
  timer += deltaTime;
  if (timer > resetTime) {
    resetSimulation();
    timer = 0;
  }
}

function createObstacles() {
  // Clear existing obstacles
  for (let i = 0; i < obstacles.length; i++) {
    World.remove(world, obstacles[i]);
  }
  obstacles = [];

  // Create new obstacles with random sizes and positions
  for (let i = 0; i < 12; i++) {
    let w = random(50, 150);
    let h = random(20, 50);
    let x = random(50, width - 50);
    let y = random(height / 4, (3 * height) / 4);
    let angle = random(-PI / 4, PI / 4);
    let obstacle = Bodies.rectangle(x, y, w, h, {
      isStatic: true,
      angle: angle,
      render: { fillStyle: 'brown' }
    });
    obstacles.push(obstacle);
    World.add(world, obstacle);
  }
}

function drawVertices(vertices) {
  beginShape();
  for (let i = 0; i < vertices.length; i++) {
    vertex(vertices[i].x, vertices[i].y);
  }
  endShape(CLOSE);
}

function resetSimulation() {
  // Remove all particles
  for (let i = 0; i < particles.length; i++) {
    World.remove(world, particles[i]);
  }
  particles = [];

  // Remove and recreate obstacles
  createObstacles();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2392424","Rainfall","mySketch","let Engine = Matter.Engine,
    World = Matter.World,
    Bodies = Matter.Bodies,
    Body = Matter.Body,
    Events = Matter.Events;

let engine;
let world;

let raindrops = [];
let ripples = [];
let pondObject;

function setup() {
  createCanvas(600, 800);

  // Initialize Matter.js engine and world
  engine = Engine.create();
  world = engine.world;
  world.gravity.y = 1; // Gravity

  // Create pond object
  pondObject = new Pond();

  // Collision event for raindrops and pond
  Events.on(engine, 'collisionStart', function(event) {
    let pairs = event.pairs;
    for (let i = 0; i < pairs.length; i++) {
      let bodyA = pairs[i].bodyA;
      let bodyB = pairs[i].bodyB;

      if ((bodyA === pondObject.body && bodyB.label === 'raindrop') ||
          (bodyB === pondObject.body && bodyA.label === 'raindrop')) {

        let raindropBody = (bodyA === pondObject.body) ? bodyB : bodyA;
        let raindrop = raindrops.find(r => r.body === raindropBody);

        if (raindrop) {
          // Create ripple effect
          ripples.push(new Ripple(raindrop.body.position.x, pondObject.position.y - pondObject.height / 2));

          // Increase pond height
          pondObject.rise(0.1);

          // Remove raindrop
          raindrop.removeFromWorld();
          raindrops.splice(raindrops.indexOf(raindrop), 1);
        }
      }
    }
  });
}

function draw() {
  background(200, 200, 255); // Light blue sky

  Engine.update(engine);

  // Generate new raindrops
  if (frameCount % 1 === 0) {
    raindrops.push(new Raindrop(random(width), -10, 3));
  }

  // Display pond
  pondObject.show();

  // Display ripples
  for (let i = ripples.length - 1; i >= 0; i--) {
    let ripple = ripples[i];
    ripple.expand();
    ripple.show();
    if (ripple.isFinished()) {
      ripples.splice(i, 1);
    }
  }

  // Display and update raindrops
  for (let i = raindrops.length - 1; i >= 0; i--) {
    let raindrop = raindrops[i];
    raindrop.show();
    if (raindrop.isOffScreen()) {
      raindrop.removeFromWorld();
      raindrops.splice(i, 1);
    }
  }
}

// Raindrop class
class Raindrop {
  constructor(x, y, r) {
    this.body = Bodies.circle(x, y, r, {
      restitution: 0.1,
      friction: 0.001
    });
    this.body.label = 'raindrop';
    this.r = r;
    World.add(world, this.body);
  }

  isOffScreen() {
    return this.body.position.y > height + 50;
  }

  show() {
    fill(0, 0, 255);
    noStroke();
    let pos = this.body.position;
    ellipse(pos.x, pos.y, this.r * 2);
  }

  removeFromWorld() {
    World.remove(world, this.body);
  }
}

// Ripple class
class Ripple {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 1;
    this.lifespan = 255;
  }

  expand() {
    this.radius += 2;
    this.lifespan -= 4;
  }

  isFinished() {
    return this.lifespan < 0;
  }

  show() {
    stroke(0, 0, 255, this.lifespan);
    noFill();
    ellipse(this.x, this.y, this.radius * 2);
  }
}

// Pond class
class Pond {
  constructor() {
    this.height = 20;
    this.position = createVector(width / 2, height - this.height / 2);

    // Create pond body
    let pondOptions = {
      isStatic: true,
      isSensor: true
    };
    this.body = Bodies.rectangle(this.position.x, this.position.y, width, this.height, pondOptions);
    World.add(world, this.body);
  }

  rise(amount) {
    this.height += amount;
    this.position.y -= amount / 2;

    // Update pond body
    Body.setPosition(this.body, { x: this.position.x, y: this.position.y });
    Body.setVertices(this.body, [
      { x: 0, y: this.position.y - this.height / 2 },
      { x: width, y: this.position.y - this.height / 2 },
      { x: width, y: this.position.y + this.height / 2 },
      { x: 0, y: this.position.y + this.height / 2 }
    ]);
  }

  show() {
    fill(0, 0, 200);
    noStroke();
    rectMode(CENTER);
    rect(this.position.x, this.position.y, width, this.height);
  }
}"
"2389142","Asteroid Dodger","mySketch","let spaceship;
let asteroids = [];
let score = 0;
let gameIsOver = false;
let asteroidFrequency = 60;

function setup() {
  createCanvas(500, 700);  // Increased canvas size for better visibility
  spaceship = new Spaceship();
  frameRate(60);
}

function draw() {
  background(0);
  stroke(255);
  noFill();
  rect(0, 0, width, height);  // Draw a square around the canvas

  fill(255);
  textSize(35);
  textAlign(CENTER);
  text(""Asteroid Dodger"", width / 2, 40);  // Fancy name at the top

  if (!gameIsOver) {
    fill(255);
    textSize(20);
    textAlign(LEFT);
    text(""Score: "" + score, 10, 60);  // Score displayed below the title

    spaceship.show();
    spaceship.move();
    
    // Add new asteroids periodically
    if (frameCount % asteroidFrequency === 0) {
      asteroids.push(new Asteroid());
      score += 1;
      // Increase speed of all asteroids every level
      for (let asteroid of asteroids) {
        asteroid.speed += 0.2;
      }
      // Increase the frequency of new asteroids to make it harder
      if (asteroidFrequency > 20) {
        asteroidFrequency -= 2;
      }
    }

    // Update asteroids and check collisions
    for (let i = asteroids.length - 1; i >= 0; i--) {
      asteroids[i].show();
      asteroids[i].update();

      if (asteroids[i].hits(spaceship)) {
        gameIsOver = true;
      }
      
      if (asteroids[i].offscreen()) {
        asteroids.splice(i, 1);
      }
    }
  } else {
    fill(255, 0, 0);
    textSize(30);
    textAlign(CENTER);
    text(""Game Over"", width / 2, height / 2);
    textSize(20);
    text(""Press 'R' to Restart"", width / 2, height / 2 + 40);
  }
}

function keyPressed() {
  if (key === 'R' || key === 'r') {
    gameIsOver = false;
    score = 0;
    asteroids = [];
    spaceship = new Spaceship();
    asteroidFrequency = 60;  // Reset asteroid frequency
  }
}

class Spaceship {
  constructor() {
    this.x = width / 2;
    this.y = height - 50;
    this.width = 40;
    this.height = 60;
    this.speed = 5;
  }

  show() {
    fill(0, 255, 0);
    noStroke();
    triangle(this.x, this.y - this.height / 2, this.x - this.width / 2, this.y + this.height / 2, this.x + this.width / 2, this.y + this.height / 2);
  }

  move() {
    if (keyIsDown(LEFT_ARROW) && this.x > this.width / 2) {
      this.x -= this.speed;
    }
    if (keyIsDown(RIGHT_ARROW) && this.x < width - this.width / 2) {
      this.x += this.speed;
    }
  }
}

class Asteroid {
  constructor() {
    this.x = random(20, width - 20);
    this.y = -20;
    this.size = random(20, 50);
    this.speed = random(2, 5);
  }

  show() {
    fill(255, 165, 0);
    noStroke();
    ellipse(this.x, this.y, this.size);
  }

  update() {
    this.y += this.speed;
  }

  offscreen() {
    return this.y > height + this.size;
  }

  hits(spaceship) {
    let d = dist(this.x, this.y, spaceship.x, spaceship.y);
    return d < this.size / 2 + spaceship.width / 2;
  }
}"
"2389128","Retro Penalty Game","mySketch","let ball;
let goalie;
let goal;
let kick;
let ballSpeed = 10;
let ballShot = false;
let goals = 0;
let totalShots = 0;
let angle = 0;
let goalState = false;
let blockState = false;

function setup() {
  createCanvas(400, 400);
  ball = createVector(width / 2, height - 50);
  goalie = createVector(width / 2, 80);
  goal = [80, 320]; // Made the goal larger
  kick = 0;
}

function draw() {
  background(34, 139, 34); // Green field like grass
  drawGoal();
  moveGoalie();
  drawGoalie();
  drawBall();
  if (ballShot) {
    moveBall();
  } else {
    drawShotPreview(); // Only draw the preview line when ball is not shot
  }
  drawOverlay();
}

function drawGoal() {
  // Goal
  stroke(255);
  noFill();
  rect(goal[0], 50, goal[1] - goal[0], 10);
}

function moveGoalie() {
  // Smarter Goalie Movement
  if (!goalState && !blockState) { // Prevent goalie movement during goal/block state
    let targetX = ballShot ? ball.x : width / 2;
    let speed = 2;
    if (goalie.x < targetX) {
      goalie.x += speed;
    } else if (goalie.x > targetX) {
      goalie.x -= speed;
    }
    goalie.x = constrain(goalie.x, goal[0] + 10, goal[1] - 10);
  }
}

function drawGoalie() {
  // Draw Goalie
  fill(0, 0, 255); // Blue color for goalkeeper
  ellipse(goalie.x, goalie.y, 30, 30);
}

function drawBall() {
  // Draw Ball (white only)
  push();
  translate(ball.x, ball.y);
  fill(255);
  stroke(0);
  strokeWeight(2);
  ellipse(0, 0, 20, 20);
  pop();
}

function moveBall() {
  // Ball movement
  ball.y -= ballSpeed;
  ball.x += kick;

  // Check if ball hits the goal, misses, or hits the goalie
  if (ball.y <= 80) {
    totalShots++;
    if (dist(ball.x, ball.y, goalie.x, goalie.y) < 20) {
      console.log('Blocked!');
      blockState = true;
      setTimeout(resetBall, 1000); // Wait 1 second before resetting
    } else if (ball.x >= goal[0] && ball.x <= goal[1]) {
      console.log('Goal!');
      goals++;
      goalState = true;
      ball.y = 60; // Keep the ball inside the goal for 1 second
      setTimeout(resetBall, 1000); // Wait 1 second before resetting
    } else {
      console.log('Missed!');
      setTimeout(resetBall, 1000); // Wait 1 second before resetting
    }
    ballShot = false;
  }
}

function drawOverlay() {
  // Scoreboard
  textAlign(CENTER);
  fill(255);
  text('Press SPACE to shoot (control direction with mouse)', width / 2, height - 10);
  text('Goals: ' + goals + ' / Shots: ' + totalShots, width / 2, height - 30);
}

function drawShotPreview() {
  // Draw shot direction preview
  stroke(255, 100);
  line(ball.x, ball.y, ball.x + angle * 20, ball.y - 40);
}

function mouseMoved() {
  // Set angle based on mouse position
  angle = map(mouseX, 0, width, -2, 2);
}

function keyPressed() {
  if (key == ' ') {
    kick = angle;
    ballShot = true;
  }
}

function resetBall() {
  goalState = false;
  blockState = false;
  ball.set(width / 2, height - 50);
}"
"2388050","Super Car Game","mySketch","let car;
let roadLines = [];
let otherCars = [];

let speed = 5;
let score = 0;

function setup() {
  createCanvas(400, 600);
  car = new Car();
  for (let i = 0; i < height; i += 40) {
    roadLines.push(new RoadLine(i));
  }
}

function draw() {
  background(50, 150, 50);

  fill(50);
  rect(100, 0, 200, height);

  for (let line of roadLines) {
    line.update();
    line.show();
  }

  if (frameCount % 60 === 0) {
    otherCars.push(new OtherCar());
  }

  for (let i = otherCars.length - 1; i >= 0; i--) {
    otherCars[i].update();
    otherCars[i].show();

    if (otherCars[i].hits(car)) {
      noLoop();
      textSize(32);
      fill(255, 0, 0);
      textAlign(CENTER);
      text('Game Over', width / 2, height / 2);
      return;
    }

    if (otherCars[i].offScreen()) {
      otherCars.splice(i, 1);
      score++;
      speed += 0.2;
    }
  }

  car.show();

  if (keyIsDown(LEFT_ARROW)) {
    car.move(-5);
  }
  if (keyIsDown(RIGHT_ARROW)) {
    car.move(5);
  }

  fill(255);
  textSize(16);
  textAlign(LEFT);
  text('Score: ' + score, 10, 20);
}

class Car {
  constructor() {
    this.x = width / 2;
    this.y = height - 70;
    this.width = 40;
    this.height = 70;
  }

  move(dir) {
    this.x += dir;
    this.x = constrain(this.x, 110, 250);
  }

  show() {
    fill(255, 0, 0);
    noStroke();
    rect(this.x, this.y, this.width, this.height, 10);
  }
}

class RoadLine {
  constructor(y) {
    this.x = width / 2;
    this.y = y;
    this.width = 10;
    this.height = 20;
  }

  update() {
    this.y += speed;
    if (this.y > height) {
      this.y = -this.height;
    }
  }

  show() {
    fill(255);
    noStroke();
    rect(this.x - this.width / 2, this.y, this.width, this.height);
  }
}

class OtherCar {
  constructor() {
    let laneWidth = 200 / 3;
    this.x = 100 + laneWidth * floor(random(0, 3)) + laneWidth / 2 - 20;
    this.y = -80;
    this.width = 40;
    this.height = 70;
    this.color = color(random(255), random(255), random(255));
  }

  update() {
    this.y += speed;
  }

  offScreen() {
    return this.y > height;
  }

  hits(car) {
    return (
      car.x < this.x + this.width &&
      car.x + car.width > this.x &&
      car.y < this.y + this.height &&
      car.y + car.height > this.y
    );
  }

  show() {
    fill(this.color);
    noStroke();
    rect(this.x, this.y, this.width, this.height);
  }
}"
"2359850","Whisker Chase","mySketch","// Whisker Chase Game

let cat;
let mice = [];
let score = 0;
let level = 1;
const MAX_MICE = 7;
let energy = 100;
const MAX_ENERGY = 100;
const ENERGY_DEPLETION_RATE = 0.1; // Energy decreases over time
const ENERGY_INCREASE = 20; // Energy gained per catch
let lives = 7;
let gameOver = false;

// Scaling factors based on screen size
let isMobile = false;
let scaleFactor = 1;
let catSize;
let mouseSize;
let hudScale;
let hudTextSize;
let gameOverTextSize;

function setup() {
  createCanvas(windowWidth, windowHeight);
  determineDevice();
  cat = new Cat();
  
  // Initialize mice
  for (let i = 0; i < MAX_MICE; i++) {
    mice.push(new Mouse());
  }
}

function draw() {
  background(200, 220, 255); // Light blue background
  
  if (!gameOver) {
    // Display score, level, energy, and lives
    displayHUD();
  
    // Update and display cat
    cat.update();
    cat.display();
  
    // Update and display mice
    for (let i = 0; i < mice.length; i++) {
      let mouseObj = mice[i];
      mouseObj.update();
      mouseObj.display();
      
      // Check for collision
      if (cat.collidesWith(mouseObj)) {
        score++;
        energy = min(energy + ENERGY_INCREASE, MAX_ENERGY); // Regain energy
        mice[i] = new Mouse(); // Replace caught mouse
    
        // Increase difficulty every 5 points
        if (score % 5 === 0) {
          level++;
          increaseDifficulty();
        }
      }
    }
  
    // Deplete energy over time
    energy -= ENERGY_DEPLETION_RATE;
    energy = max(energy, 0);
  
    // Check energy and lives
    if (energy <= 0) {
      lives--;
      if (lives > 0) {
        energy = MAX_ENERGY; // Reset energy
        // Optionally, add a brief pause or reset positions
      } else {
        gameOver = true;
      }
    }
  } else {
    // Display Game Over Screen
    displayGameOver();
  }
}

function determineDevice() {
  // Simple mobile detection based on window width
  if (windowWidth < 600) {
    isMobile = true;
    scaleFactor = 0.6;
  } else {
    isMobile = false;
    scaleFactor = 1;
  }
  
  // Set sizes based on device
  catSize = 80 * scaleFactor;
  mouseSize = 40 * scaleFactor;
  hudScale = scaleFactor;
  hudTextSize = isMobile ? 16 : 24;
  gameOverTextSize = isMobile ? 32 : 48;
}

function displayHUD() {
  push();
  scale(hudScale);
  fill(0);
  textSize(hudTextSize);
  textAlign(LEFT, TOP);
  text(`Score: ${score}`, 20, 20);
  text(`Level: ${level}`, 20, 50);
  text(`Lives: ${lives}`, 20, 80);
  
  // Draw Energy Bar
  fill(255);
  stroke(0);
  rect(20, 120, 200, 25);
  fill(0, 255, 0);
  noStroke();
  let energyWidth = map(energy, 0, MAX_ENERGY, 0, 200);
  rect(20, 120, energyWidth, 25);
  fill(0);
  textSize(hudTextSize * 0.8);
  text(`Energy: ${floor(energy)}`, 230, 122);
  pop();
}

function displayGameOver() {
  push();
  fill(50, 50, 50, 200); // Semi-transparent overlay
  noStroke();
  rect(0, 0, width, height);
  
  fill(255);
  textSize(gameOverTextSize);
  textAlign(CENTER, CENTER);
  text(""Game Over"", width / 2, height / 2 - 50);
  
  textSize(isMobile ? 24 : 32);
  text(`Final Score: ${score}`, width / 2, height / 2);
  
  textSize(isMobile ? 18 : 24);
  text(""Refresh the page to play again!"", width / 2, height / 2 + 50);
  pop();
}

// Increase game difficulty by enhancing mouse speed and behavior
function increaseDifficulty() {
  // Increase speed of existing and future mice
  mice.forEach(mouse => {
    mouse.speed += 0.5;
  });
  // Enable fleeing behavior
  mice.forEach(mouse => {
    mouse.flee = true;
  });
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  determineDevice();
  // Optionally, adjust cat and mice positions to stay within new window size
}

// Cat Class
class Cat {
  constructor() {
    this.x = width / 2;
    this.y = height / 2;
    this.size = catSize;
    this.speed = 5 * scaleFactor;
  
    // Animation parameters
    this.legAngle = 0;
    this.legDirection = 1;
    this.tailAngle = 0;
    this.tailDirection = 1;
  }

  update() {
    // Move cat towards mouse position with smoothing
    let targetX = mouseX;
    let targetY = mouseY;

    let dx = targetX - this.x;
    let dy = targetY - this.y;
    let angle = atan2(dy, dx);

    this.x += cos(angle) * this.speed;
    this.y += sin(angle) * this.speed;

    // Keep the cat within the canvas
    this.x = constrain(this.x, this.size / 2, width - this.size / 2);
    this.y = constrain(this.y, this.size / 2, height - this.size / 2);

    // Animate legs
    this.legAngle += 0.1 * this.legDirection;
    if (abs(this.legAngle) > PI / 6) {
      this.legDirection *= -1;
    }

    // Animate tail
    this.tailAngle += 0.05 * this.tailDirection;
    if (abs(this.tailAngle) > PI / 4) {
      this.tailDirection *= -1;
    }
  }

  display() {
    push();
    translate(this.x, this.y);
  
    // Body
    fill(150, 100, 50); // Brown color
    ellipse(0, 0, this.size, this.size * 0.6);
  
    // Head
    ellipse(40 * scaleFactor, -20 * scaleFactor, this.size * 0.5, this.size * 0.5);
  
    // Ears
    triangle(30 * scaleFactor, -35 * scaleFactor, 35 * scaleFactor, -45 * scaleFactor, 40 * scaleFactor, -35 * scaleFactor);
    triangle(50 * scaleFactor, -35 * scaleFactor, 55 * scaleFactor, -45 * scaleFactor, 60 * scaleFactor, -35 * scaleFactor);
  
    // Eyes
    fill(255);
    ellipse(35 * scaleFactor, -25 * scaleFactor, 10 * scaleFactor, 10 * scaleFactor);
    ellipse(45 * scaleFactor, -25 * scaleFactor, 10 * scaleFactor, 10 * scaleFactor);
    fill(0);
    ellipse(35 * scaleFactor, -25 * scaleFactor, 5 * scaleFactor, 5 * scaleFactor);
    ellipse(45 * scaleFactor, -25 * scaleFactor, 5 * scaleFactor, 5 * scaleFactor);
  
    // Mouth
    noFill();
    stroke(0);
    arc(40 * scaleFactor, -15 * scaleFactor, 10 * scaleFactor, 10 * scaleFactor, 0, PI);
  
    // Legs
    stroke(100, 50, 20);
    strokeWeight(4 * scaleFactor);
    // Front left leg
    push();
    rotate(this.legAngle);
    line(-20 * scaleFactor, 30 * scaleFactor, -20 * scaleFactor, 50 * scaleFactor);
    pop();
    // Front right leg
    push();
    rotate(-this.legAngle);
    line(20 * scaleFactor, 30 * scaleFactor, 20 * scaleFactor, 50 * scaleFactor);
    pop();
    // Back left leg
    push();
    rotate(-this.legAngle);
    line(-20 * scaleFactor, 30 * scaleFactor, -20 * scaleFactor, 50 * scaleFactor);
    pop();
    // Back right leg
    push();
    rotate(this.legAngle);
    line(20 * scaleFactor, 30 * scaleFactor, 20 * scaleFactor, 50 * scaleFactor);
    pop();
  
    // Tail
    noFill();
    stroke(150, 100, 50);
    strokeWeight(4 * scaleFactor);
    push();
    rotate(this.tailAngle);
    line(-40 * scaleFactor, 0, -60 * scaleFactor, 10 * scaleFactor);
    pop();
  
    pop();
  }

  collidesWith(mouseObj) {
    let distance = dist(this.x, this.y, mouseObj.x, mouseObj.y);
    return distance < (this.size / 2 + mouseObj.size / 2);
  }
}

// Mouse Class
class Mouse {
  constructor() {
    this.size = mouseSize;
    this.x = random(this.size, width - this.size);
    this.y = random(this.size, height - this.size);
    this.speed = random(2, 4 + level * 0.5) * scaleFactor;
    this.direction = p5.Vector.random2D();
    this.flee = false; // Determines if the mouse flees from the cat

    // Animation parameters
    this.legAngle = 0;
    this.legDirection = 1;
  }

  update() {
    if (this.flee) {
      // Calculate vector away from the cat
      let fleeVector = createVector(this.x - cat.x, this.y - cat.y);
      if (fleeVector.mag() === 0) {
        fleeVector = p5.Vector.random2D();
      }
      fleeVector.normalize();
      fleeVector.mult(this.speed);
      this.x += fleeVector.x;
      this.y += fleeVector.y;
    } else {
      // Move mouse in current direction
      this.x += this.direction.x * this.speed;
      this.y += this.direction.y * this.speed;
    }

    // Ensure the mouse stays within the canvas boundaries
    this.x = constrain(this.x, this.size / 2, width - this.size / 2);
    this.y = constrain(this.y, this.size / 2, height - this.size / 2);

    // Bounce off walls by reflecting direction
    let bounced = false;

    if (this.x <= this.size / 2 || this.x >= width - this.size / 2) {
      this.direction.x *= -1;
      bounced = true;
    }
    if (this.y <= this.size / 2 || this.y >= height - this.size / 2) {
      this.direction.y *= -1;
      bounced = true;
    }

    if (bounced) {
      // Slightly alter direction to prevent getting stuck in corners
      this.direction.rotate(random(-PI / 6, PI / 6));
      this.direction.normalize();
    }

    // Ensure mice are always moving and not stuck
    if (this.direction.mag() === 0) {
      this.direction = p5.Vector.random2D();
    }

    // Animate legs
    this.legAngle += 0.2 * this.legDirection;
    if (abs(this.legAngle) > PI / 6) {
      this.legDirection *= -1;
    }
  }

  display() {
    push();
    translate(this.x, this.y);
  
    // Body
    fill(100);
    ellipse(0, 0, this.size, this.size * 0.5);
  
    // Head
    ellipse(-15 * scaleFactor, -10 * scaleFactor, this.size * 0.3, this.size * 0.3);
  
    // Ears
    ellipse(-20 * scaleFactor, -15 * scaleFactor, this.size * 0.1, this.size * 0.1);
    ellipse(-10 * scaleFactor, -15 * scaleFactor, this.size * 0.1, this.size * 0.1);
  
    // Eyes
    fill(255);
    ellipse(-16 * scaleFactor, -12 * scaleFactor, 5 * scaleFactor, 5 * scaleFactor);
    fill(0);
    ellipse(-16 * scaleFactor, -12 * scaleFactor, 2 * scaleFactor, 2 * scaleFactor);
  
    // Nose
    fill(255, 0, 0);
    ellipse(-18 * scaleFactor, -10 * scaleFactor, 3 * scaleFactor, 3 * scaleFactor);
  
    // Tail
    noFill();
    stroke(100);
    strokeWeight(2 * scaleFactor);
    line(20 * scaleFactor, 0, 30 * scaleFactor, 10 * scaleFactor);
  
    // Legs
    stroke(100);
    strokeWeight(2 * scaleFactor);
    // Front left leg
    push();
    rotate(this.legAngle);
    line(-10 * scaleFactor, 20 * scaleFactor, -10 * scaleFactor, 30 * scaleFactor);
    pop();
    // Front right leg
    push();
    rotate(-this.legAngle);
    line(10 * scaleFactor, 20 * scaleFactor, 10 * scaleFactor, 30 * scaleFactor);
    pop();
  
    pop();
  }
}
"
"2359635","Mini car racing","mySketch","let car;
let track;
let trackRadius = 200;
let trackCenterX = 300;
let trackCenterY = 300;
let lapCount = 0;
let startTime;
let lapTimes = [];
let totalLaps = 3;
let raceFinished = false;

function setup() {
  createCanvas(600, 600);
  angleMode(DEGREES);
  car = new Car();
  track = new Track();
  startTime = millis();
}

function draw() {
  background(0, 153, 0); // Retro-style green background
  
  track.display();
  car.update();
  car.display();
  displayLapInfo();

  // Check if the race is finished
  if (lapCount >= totalLaps) {
    raceFinished = true;
    noLoop(); // Stop the draw loop when race is finished
    displayRaceFinished();
  }
}

function displayLapInfo() {
  fill(255);
  textSize(16);
  textAlign(LEFT);
  let currentTime = millis();
  let lapTime = nf((currentTime - startTime) / 1000, 1, 2);
  text(`Lap: ${lapCount + 1}/${totalLaps}`, 10, 20);
  text(`Current Lap Time: ${lapTime} sec`, 10, 40);
  if (lapTimes.length > 0) {
    for (let i = 0; i < lapTimes.length; i++) {
      text(`Lap ${i + 1}: ${lapTimes[i]} sec`, 10, 60 + i * 20);
    }
  }
}

function displayRaceFinished() {
  fill(255, 0, 0);
  textSize(32);
  textAlign(CENTER);
  text(""Race Finished!"", width / 2, height / 2);
}

class Track {
  display() {
    fill(100, 100, 100);
    noStroke();
    ellipse(trackCenterX, trackCenterY, trackRadius * 2); // Draw the track
    fill(0, 153, 0);
    ellipse(trackCenterX, trackCenterY, (trackRadius - 50) * 2); // Draw inner grass area
    
    // Draw start/finish line crossing the track
    stroke(255);
    strokeWeight(2);
    line(trackCenterX, trackCenterY - trackRadius, trackCenterX, trackCenterY + trackRadius); // Vertical line crossing the circuit
  }
}

class Car {
  constructor() {
    this.width = 30;
    this.height = 15;
    this.x = trackCenterX; // Start at the center of the track
    this.y = trackCenterY - trackRadius / 2; // Place the car inside the circuit
    this.angle = 0;
    this.speed = 0;
    this.maxSpeed = 8; // Increase max speed to make the car faster
    this.lastLapCrossed = false;
  }

  update() {
    if (raceFinished) {
      return;
    }

    if (keyIsDown(UP_ARROW)) {
      this.speed += 0.2; // Increase acceleration to make the car faster
    }
    if (keyIsDown(DOWN_ARROW)) {
      this.speed -= 0.2;
    }
    if (keyIsDown(LEFT_ARROW)) {
      this.angle -= 3;
    }
    if (keyIsDown(RIGHT_ARROW)) {
      this.angle += 3;
    }

    this.speed = constrain(this.speed, -this.maxSpeed / 2, this.maxSpeed);
    this.x += this.speed * cos(this.angle);
    this.y += this.speed * sin(this.angle);

    // Keep car on the track
    let distance = dist(this.x, this.y, trackCenterX, trackCenterY);
    if (this.isOffTrack(distance)) {
      this.speed = 0.5; // Stop the car if it goes out of the track
    }

    // Check if the car crossed the start/finish line
    let crossingLine = this.isCrossingStartFinishLine();
    if (crossingLine && !this.lastLapCrossed) {
      lapCount++;
      let currentTime = millis();
      let lapTime = nf((currentTime - startTime) / 1000, 1, 2);
      lapTimes.push(lapTime);
      startTime = currentTime;
    }
    this.lastLapCrossed = crossingLine;
  }

  isOffTrack(distance) {
    return distance > trackRadius - this.width / 2 || distance < trackRadius - 50 + this.width / 2;
  }

  isCrossingStartFinishLine() {
    let dx = this.x - trackCenterX;
    return abs(dx) < 5 && this.y > trackCenterY - trackRadius && this.y < trackCenterY + trackRadius;
  }

  display() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);
    fill(255, 0, 0);
    rectMode(CENTER);
    rect(0, 0, this.width, this.height);
    pop();
  }
}"
"2359609","Funny Rhino","mySketch","// Variáveis para controlar a boca do rinoceronte
let mouthOpen = false;
let mouthTimer = 0;
const MOUTH_DURATION = 500; // Duração em milissegundos que a boca permanece aberta

// Variáveis para controlar o movimento do rinoceronte
let rhinoX;
let rhinoY;
let rhinoSpeed = 2; // Velocidade de movimento
let direction = 1; // 1 para direita, -1 para esquerda

function setup() {
  createCanvas(800, 400);
  // Inicializar a posição do rinoceronte no centro vertical e um pouco à esquerda horizontalmente
  rhinoX = width / 2 - 100;
  rhinoY = height / 2;
  
  // Definir o modo de desenho no centro para facilitar o posicionamento
  rectMode(CENTER);
  ellipseMode(CENTER);
}

function draw() {
  background(200, 220, 255); // Cor de fundo agradável

  // Atualizar a posição do rinoceronte
  rhinoX += rhinoSpeed * direction;

  // Verificar limites para inverter a direção
  if (rhinoX > width - 100 || rhinoX < 100) {
    direction *= -1;
  }

  // Desenhar o rinoceronte na posição atual
  drawRhino(rhinoX, rhinoY, 200);

  // Verificar se o tempo para fechar a boca passou
  if (mouthOpen) {
    if (millis() - mouthTimer > MOUTH_DURATION) {
      mouthOpen = false;
    }
  }
}

// Função para desenhar o rinoceronte
function drawRhino(x, y, size) {
  push();
  translate(x, y);
  scale(size / 200); // Escalar o desenho baseado no tamanho

  // Corpo
  fill(150, 150, 150);
  ellipse(0, 20, 100, 60);

  // Cabeça
  ellipse(-50, 0, 80, 60);

  // Olhos
  fill(0);
  ellipse(-60, -10, 10, 10);

  // Chifre
  fill(100, 80, 50);
  triangle(-80, -10, -100, -30, -80, -30);

  // Orelhas
  ellipse(-40, -20, 20, 30);

  // Focinho
  fill(150, 150, 150);
  ellipse(-80, 10, 30, 20);

  // Boca
  if (mouthOpen) {
    // Boca aberta
    arc(-80, 20, 20, 10, 0, PI, CHORD);
  } else {
    // Boca fechada
    line(-90, 20, -70, 20);
  }

  // Pernas (simples animação de caminhada)
  // As pernas podem oscilar para dar a impressão de movimento
  let legSwing = sin(frameCount * 0.2) * 10;

  fill(150, 150, 150);
  // Frente esquerda
  rect(-30, 50 + legSwing, 10, 40);
  // Frente direita
  rect(30, 50 - legSwing, 10, 40);

  pop();
}

// Função para detectar cliques ou toques
function mousePressed() {
  if (isMouseOverRhino(mouseX, mouseY)) {
    mouthOpen = true;
    mouthTimer = millis();
  }
}

function touchStarted() {
  if (isMouseOverRhino(touchX, touchY)) {
    mouthOpen = true;
    mouthTimer = millis();
  }
  // Evitar comportamento padrão em dispositivos móveis
  return false;
}

// Função para verificar se o mouse está sobre o rinoceronte
function isMouseOverRhino(mx, my) {
  // Calcular a distância do mouse para a posição atual do rinoceronte
  let dx = abs(mx - rhinoX);
  let dy = abs(my - rhinoY);

  // Definir a área aproximada do rinoceronte (ajustada para o movimento)
  if (dx < 100 && dy < 100) {
    return true;
  }
  return false;
}
"
"2359508","Lemming Drop","mySketch","// Importação das classes do Matter.js
let Engine = Matter.Engine,
    World = Matter.World,
    Bodies = Matter.Bodies,
    Events = Matter.Events;

// Variáveis do jogo
let currentLevel = 1;
let gameLost = false;
let gameWon = false;

let availableBalls = 200;
let totalBalls = 200;
let ballsToPut;
let blocksAvailable = 100;

let engine;
let world;
let lemmings = [];
let blocks = [];
let goalBody;
let startPoint;
let score = 0;
let level = 1;

let topWall, bottomWall, leftWall, rightWall;

// Variáveis de estilo
let bgColor;
let lemmingColor;
let blockColor;
let goalColor;
let dashboardColor;

function setup() {
    createCanvas(windowWidth, windowHeight);

    // Paleta de cores
    bgColor = color(20, 20, 40);         // Fundo escuro
    lemmingColor = color(255, 85, 85);   // Lemmings vermelhos brilhantes
    blockColor = color(85, 255, 85);     // Blocos verdes brilhantes
    goalColor = color(85, 85, 255);      // Objetivo azul brilhante
    dashboardColor = color(255, 255, 255, 50); // Fundo semi-transparente para o dashboard

    textFont('monospace'); // Usa fonte monospace padrão

    initializeLevel(currentLevel);

    engine = Engine.create();
    world = engine.world;

    // Criar paredes
    createWalls();

    startTime = millis();

    // Criar objetivo e obter goalPosX
    let goalPosX = createGoal();

    // Gerar startPoint.x não alinhado com goalPosX
    startPoint = { x: generateNonAlignedX(goalPosX), y: 150 };

    // Eventos de colisão
    Events.on(engine, 'collisionStart', function(event) {
        handleCollisions(event);
    });
}

function createWalls() {
    topWall = Bodies.rectangle(width / 2, -10, width, 20, { isStatic: true });
    bottomWall = Bodies.rectangle(width / 2, height + 10, width, 20, { isStatic: true });
    leftWall = Bodies.rectangle(-10, height / 2, 20, height, { isStatic: true });
    rightWall = Bodies.rectangle(width + 10, height / 2, 20, height, { isStatic: true });
    World.add(world, [topWall, bottomWall, leftWall, rightWall]);
}

function createGoal() {
    let goalRadius = 50; // Raio para o objetivo em forma de funil
    let goalPosX = random(60, width - 60);

    // Criar um objetivo em forma de funil usando vértices personalizados
    let funnelVertices = [
        { x: -goalRadius, y: 0 },
        { x: -goalRadius / 2, y: -100 },
        { x: goalRadius / 2, y: -100 },
        { x: goalRadius, y: 0 }
    ];

    goalBody = Bodies.fromVertices(goalPosX, height - 10, funnelVertices, {
        isStatic: true,
        label: 'goal'
    }, true);

    World.add(world, goalBody);
    
    return goalPosX;
}

function generateNonAlignedX(goalX, minDistance = 100) {
    let newX;
    do {
        newX = random(60, width - 60);
    } while (abs(newX - goalX) < minDistance);
    return newX;
}

function handleCollisions(event) {
    let pairs = event.pairs;
    for (let i = 0; i < pairs.length; i++) {
        let bodyA = pairs[i].bodyA;
        let bodyB = pairs[i].bodyB;

        // Verifica se um lemming colide com a parede inferior (errou o objetivo)
        if ((bodyA === bottomWall && bodyB.label === 'lemming') ||
            (bodyB === bottomWall && bodyA.label === 'lemming')) {
            // Remove o lemming do mundo e do array de lemmings
            let lemmingBody = bodyA.label === 'lemming' ? bodyA : bodyB;
            removeLemming(lemmingBody);
        }

        // Verifica se um lemming entra no objetivo
        if ((bodyA.label === 'goal' && bodyB.label === 'lemming') ||
            (bodyB.label === 'goal' && bodyA.label === 'lemming')) {
            score++;
            // Remove lemming do mundo e do array de lemmings
            let lemmingBody = bodyA.label === 'lemming' ? bodyA : bodyB;
            removeLemming(lemmingBody);
        }
    }
}

function removeLemming(lemmingBody) {
    World.remove(world, lemmingBody);
    // Remove do array de lemmings
    for (let i = 0; i < lemmings.length; i++) {
        if (lemmings[i] === lemmingBody) {
            lemmings.splice(i, 1);
            break;
        }
    }
}

function areLemmingsStill() {
    for (let lemming of lemmings) {
        if (lemming.speed > 0.5) {
            return false;
        }
    }
    return true;
}

function draw() {
    background(bgColor);

    Engine.update(engine);

    // Condições de término do jogo
    if (availableBalls === 0 && areLemmingsStill() && !gameWon && !gameLost) {
        gameLost = true;
        noLoop();
    }

    if (ballsToPut == score && !gameWon && !gameLost) {
        gameWon = true;
        noLoop();
    }

    // Exibir mensagens de fim de jogo
    if (gameWon) {
        displayMessage('LEVEL COMPLETE!\nPress any key to continue');
        return;
    }

    if (gameLost) {
        displayMessage('GAME OVER\nPress any key to restart');
        return;
    }

    // Exibir dashboard
    displayDashboard();

    // Spawn de lemmings
    if (frameCount % 30 == 0 && availableBalls > 0) {
        let lemming = Bodies.circle(startPoint.x, startPoint.y, 7.5, {
            friction: 0.001,
            restitution: 0.5,
            label: 'lemming'
        });
        World.add(world, lemming);
        lemmings.push(lemming);
        availableBalls--;
    }

    // Renderizar lemmings
    renderLemmings();

    // Exibir ponto de entrada
    fill(255, 200, 0);
    noStroke();
    ellipse(startPoint.x, startPoint.y, 30, 30);

    // Exibir objetivo
    renderGoal();

    // Exibir blocos
    renderBlocks();
}

function displayMessage(msg) {
    textSize(20);
    fill(255);
    textAlign(CENTER, CENTER);
    text(msg, width / 2, height / 2);
}

function displayDashboard() {
    // Fundo do dashboard
    fill(dashboardColor);
    noStroke();
    rectMode(CORNER);
    rect(0, 0, width, 50);

    // Texto do dashboard
    fill(255);
    textSize(isMobileDevice() ? 12 : 14); // Reduzir tamanho da fonte para mobile
    textAlign(LEFT, CENTER);
    let dashboardText;

    if (isMobileDevice()) {
        // Texto abreviado para mobile
        dashboardText = `LV:${currentLevel} G:${ballsToPut} S:${score} B:${max(0, availableBalls)} BK:${blocksAvailable}`;
    } else {
        // Texto completo para desktop
        dashboardText = `LEVEL: ${currentLevel}    GOAL: ${ballsToPut}    SCORED: ${score}    BALLS LEFT: ${max(0, availableBalls)}    BLOCKS: ${blocksAvailable}`;
    }

    text(dashboardText, 10, 25);
}

function renderLemmings() {
    let lemmingSize = isMobileDevice() ? width * 0.03 : 15;
    fill(lemmingColor);
    noStroke();
    for (let lemming of lemmings) {
        ellipse(lemming.position.x, lemming.position.y, lemmingSize);
    }
}

function renderGoal() {
    fill(goalColor);
    noStroke();
    beginShape();
    for (let v of goalBody.vertices) {
        vertex(v.x, v.y);
    }
    endShape(CLOSE);
}

function renderBlocks() {
    fill(blockColor);
    noStroke();
    for (let block of blocks) {
        push();
        translate(block.position.x, block.position.y);
        rotate(block.angle);
        rectMode(CENTER);
        rect(0, 0, 60, 10); // Aumenta a largura dos blocos para melhor jogabilidade
        pop();
    }
}

function placeBlock() {
    if (blocksAvailable > 0) {
        let block = Bodies.rectangle(mouseX, mouseY, 60, 10, { // Aumenta a largura dos blocos
            isStatic: true,
            angle: 0,
            label: 'block'
        });
        World.add(world, block);
        blocks.push(block);
        blocksAvailable--;
    }
}

function mousePressed() {
    if (gameWon) {
        levelUp();
    } else if (gameLost) {
        restartGame();
    } else {
        placeBlock();
    }
}

function touchStarted() {
    if (gameWon) {
        levelUp();
    } else if (gameLost) {
        restartGame();
    } else {
        placeBlock();
    }
    return false; // Prevenir comportamento padrão
}

function keyPressed() {
    if (gameWon) {
        levelUp();
    } else if (gameLost) {
        restartGame();
    }
}

function initializeLevel(level) {
    ballsToPut = level;
    blocksAvailable = max(100 - level + 1, 1);
}

function levelUp() {
    level++;
    currentLevel = level;
    score = 0;
    availableBalls = 200;
    gameWon = false;

    initializeLevel(level);

    // Remover lemmings do mundo
    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];

    // Remover blocos do mundo
    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];

    // Remover objetivo anterior
    World.remove(world, goalBody);
    
    // Criar novo objetivo e obter goalPosX
    let goalPosX = createGoal();

    // Gerar startPoint.x não alinhado com goalPosX
    startPoint.x = generateNonAlignedX(goalPosX);

    loop();
}

function restartGame() {
    gameLost = false;
    gameWon = false;
    level = 1;
    currentLevel = level;
    score = 0;
    availableBalls = 200;

    initializeLevel(level);

    // Remover lemmings do mundo
    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];

    // Remover blocos do mundo
    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];

    // Remover objetivo anterior
    World.remove(world, goalBody);
    
    // Criar novo objetivo e obter goalPosX
    let goalPosX = createGoal();

    // Gerar startPoint.x não alinhado com goalPosX
    startPoint.x = generateNonAlignedX(goalPosX);

    loop();
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    // Recriar paredes e ajustar posições
    World.remove(world, [topWall, bottomWall, leftWall, rightWall]);
    createWalls();
}

// Função de detecção de dispositivo
function isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);
}
"
"2355314","G power","mySketch.js","// Neon Rotating ""G"" Animation in p5.js

let angle = 0; // Rotation angle
let fontSize = 200; // Base font size
let glowLayers = 10; // Number of glow layers
let neonColor;

function setup() {
  createCanvas(windowWidth, windowHeight);
  angleMode(DEGREES);
  textAlign(CENTER, CENTER);
  textFont('Arial'); // You can choose any font you like
  neonColor = color(0, 255, 255); // Cyan neon color
  background(10); // Dark background to enhance neon effect
}

function draw() {
  background(10, 10, 10, 50); // Semi-transparent background for trailing effect

  push();
  translate(width / 2, height / 2);
  rotate(angle);
  
  // Draw multiple layers for the neon glow
  for (let i = glowLayers; i > 0; i--) {
    let layerColor = lerpColor(color(0, 255, 255, 50 / i), neonColor, 1);
    fill(layerColor);
    noStroke();
    textSize(fontSize + i * 5); // Slightly increase size for outer glow
    text('G', 0, 0);
  }

  // Draw the main ""G""
  fill(neonColor);
  noStroke();
  textSize(fontSize);
  text('G', 0, 0);
  
  pop();

  angle += 0.5; // Adjust rotation speed here
}

// Adjust canvas size when the window is resized
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"2355106","Lemming Drop","mySketch.js","// Variables
let currentLevel = 1;
let gameLost = false;
let gameWon = false;

let availableBalls = 200;
let totalBalls = 200;
let ballsToPut;
let blocksAvailable = 100;

let Engine = Matter.Engine,
    World = Matter.World,
    Bodies = Matter.Bodies,
    Events = Matter.Events;

let engine;
let world;
let lemmings = [];
let blocks = [];
let goalBody;
let startPoint;
let score = 0;
let level = 1;

let topWall, bottomWall, leftWall, rightWall;

// Style Variables
let bgColor;
let lemmingColor;
let blockColor;
let goalColor;
let dashboardColor;

function setup() {
    createCanvas(windowWidth, windowHeight);

    // Color palette
    bgColor = color(20, 20, 40);         // Dark background
    lemmingColor = color(255, 85, 85);   // Bright red lemmings
    blockColor = color(85, 255, 85);     // Bright green blocks
    goalColor = color(85, 85, 255);      // Bright blue goal
    dashboardColor = color(255, 255, 255, 50); // Semi-transparent white for dashboard background

    textFont('monospace'); // Use default monospace font

    initializeLevel(currentLevel);

    engine = Engine.create();
    world = engine.world;

    // Create walls
    createWalls();

    startTime = millis();
    startPoint = { x: random(60, width - 60), y: 150 };

    // Create goal with enhanced visuals
    createGoal();

    // Collision event handling
    Events.on(engine, 'collisionStart', function(event) {
        handleCollisions(event);
    });
}

function createWalls() {
    topWall = Bodies.rectangle(width / 2, -10, width, 20, { isStatic: true });
    bottomWall = Bodies.rectangle(width / 2, height + 10, width, 20, { isStatic: true });
    leftWall = Bodies.rectangle(-10, height / 2, 20, height, { isStatic: true });
    rightWall = Bodies.rectangle(width + 10, height / 2, 20, height, { isStatic: true });
    World.add(world, [topWall, bottomWall, leftWall, rightWall]);
}

function createGoal() {
    let goalRadius = 50; // Radius for the funnel-shaped goal
    let goalPosX = random(60, width - 60);

    // Create a funnel-shaped goal using a custom vertex shape
    let funnelVertices = [
        { x: -goalRadius, y: 0 },
        { x: -goalRadius / 2, y: -100 },
        { x: goalRadius / 2, y: -100 },
        { x: goalRadius, y: 0 }
    ];

    goalBody = Bodies.fromVertices(goalPosX, height - 10, funnelVertices, {
        isStatic: true,
        label: 'goal'
    }, true);

    World.add(world, goalBody);
}

function handleCollisions(event) {
    let pairs = event.pairs;
    for (let i = 0; i < pairs.length; i++) {
        let bodyA = pairs[i].bodyA;
        let bodyB = pairs[i].bodyB;

        // Check if lemming hits the bottom wall (missed goal)
        if ((bodyA === bottomWall && bodyB.label === 'lemming') ||
            (bodyB === bottomWall && bodyA.label === 'lemming')) {
            // Remove the lemming from the world and from the lemmings array
            let lemmingBody = bodyA.label === 'lemming' ? bodyA : bodyB;
            removeLemming(lemmingBody);
        }

        // Check if lemming enters the goal
        if ((bodyA.label === 'goal' && bodyB.label === 'lemming') ||
            (bodyB.label === 'goal' && bodyA.label === 'lemming')) {
            score++;
            // Remove lemming from world and lemmings array
            let lemmingBody = bodyA.label === 'lemming' ? bodyA : bodyB;
            removeLemming(lemmingBody);
        }
    }
}

function removeLemming(lemmingBody) {
    World.remove(world, lemmingBody);
    // Remove from lemmings array
    for (let i = 0; i < lemmings.length; i++) {
        if (lemmings[i] === lemmingBody) {
            lemmings.splice(i, 1);
            break;
        }
    }
}

function areLemmingsStill() {
    for (let lemming of lemmings) {
        if (lemming.speed > 0.5) {
            return false;
        }
    }
    return true;
}

function draw() {
    background(bgColor);

    Engine.update(engine);

    // Game over conditions
    if (availableBalls === 0 && areLemmingsStill() && !gameWon && !gameLost) {
        gameLost = true;
        noLoop();
    }

    if (ballsToPut == score && !gameWon && !gameLost) {
        gameWon = true;
        noLoop();
    }

    // Display game over messages
    if (gameWon) {
        displayMessage('LEVEL COMPLETE!\nPress any key to continue');
        return;
    }

    if (gameLost) {
        displayMessage('GAME OVER\nPress any key to restart');
        return;
    }

    // Display dashboard
    displayDashboard();

    // Spawn lemmings
    if (frameCount % 30 == 0 && availableBalls > 0) {
        let lemming = Bodies.circle(startPoint.x, startPoint.y, 7.5, {
            friction: 0.001,
            restitution: 0.5,
            label: 'lemming'
        });
        World.add(world, lemming);
        lemmings.push(lemming);
        availableBalls--;
    }

    // Render lemmings
    renderLemmings();

    // Display entry point
    fill(255, 200, 0);
    noStroke();
    ellipse(startPoint.x, startPoint.y, 30, 30);

    // Display goal
    renderGoal();

    // Display blocks
    renderBlocks();
}

function displayMessage(msg) {
    textSize(20);
    fill(255);
    textAlign(CENTER, CENTER);
    text(msg, width / 2, height / 2);
}

function displayDashboard() {
    // Dashboard background
    fill(dashboardColor);
    noStroke();
    rectMode(CORNER);
    rect(0, 0, width, 50);

    // Dashboard text
    fill(255);
    textSize(14);
    textAlign(LEFT, CENTER);
    let dashboardText = `LEVEL: ${currentLevel}    GOAL: ${ballsToPut}    SCORED: ${score}    BALLS LEFT: ${max(0, availableBalls)}    BLOCKS: ${blocksAvailable}`;
    text(dashboardText, 10, 25);
}

function renderLemmings() {
    let lemmingSize = isMobileDevice() ? width * 0.03 : 15;
    fill(lemmingColor);
    noStroke();
    for (let lemming of lemmings) {
        ellipse(lemming.position.x, lemming.position.y, lemmingSize);
    }
}

function renderGoal() {
    fill(goalColor);
    noStroke();
    beginShape();
    for (let v of goalBody.vertices) {
        vertex(v.x, v.y);
    }
    endShape(CLOSE);
}

function renderBlocks() {
    fill(blockColor);
    noStroke();
    for (let block of blocks) {
        push();
        translate(block.position.x, block.position.y);
        rotate(block.angle);
        rectMode(CENTER);
        rect(0, 0, 60, 10); // Increased block width for better gameplay
        pop();
    }
}

function placeBlock() {
    if (blocksAvailable > 0) {
        let block = Bodies.rectangle(mouseX, mouseY, 60, 10, { // Increased block width
            isStatic: true,
            angle: 0,
            label: 'block'
        });
        World.add(world, block);
        blocks.push(block);
        blocksAvailable--;
    }
}

function mousePressed() {
    if (gameWon) {
        levelUp();
    } else if (gameLost) {
        restartGame();
    } else {
        placeBlock();
    }
}

function touchStarted() {
    if (gameWon) {
        levelUp();
    } else if (gameLost) {
        restartGame();
    } else {
        placeBlock();
    }
    return false; // Prevent default behavior
}

function keyPressed() {
    if (gameWon) {
        levelUp();
    } else if (gameLost) {
        restartGame();
    }
}

function initializeLevel(level) {
    ballsToPut = level;
    blocksAvailable = max(100 - level + 1, 1);
}

function levelUp() {
    level++;
    currentLevel = level;
    score = 0;
    availableBalls = 200;
    gameWon = false;

    initializeLevel(level);

    // Remove lemmings from world
    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];

    // Remove blocks from world
    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];

    // Randomize startPoint and goal position
    startPoint.x = random(60, width - 60);

    World.remove(world, goalBody);
    createGoal();

    loop();
}

function restartGame() {
    gameLost = false;
    gameWon = false;
    level = 1;
    currentLevel = level;
    score = 0;
    availableBalls = 200;

    initializeLevel(level);

    // Remove lemmings from world
    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];

    // Remove blocks from world
    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];

    // Randomize startPoint and goal position
    startPoint.x = random(60, width - 60);

    World.remove(world, goalBody);
    createGoal();

    loop();
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    // Re-create walls and adjust positions
    World.remove(world, [topWall, bottomWall, leftWall, rightWall]);
    createWalls();
}

// Device detection function
function isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);
}
"
"2355090","Lemming drop","mySketch","// Variables
let currentLevel = 1;
let gameLost = false;
let gameWon = false;

let availableBalls = 200;
let totalBalls = 200;
let ballsToPut;
let blocksAvailable = 100;

let Engine = Matter.Engine,
    World = Matter.World,
    Bodies = Matter.Bodies,
    Events = Matter.Events;

let engine;
let world;
let lemmings = [];
let blocks = [];
let goalBody, goalLipLeft, goalLipRight;
let startPoint;
let score = 0;
let level = 1;

let goalWidth, goalHeight, goalLipThickness;
let topWall, bottomWall, leftWall, rightWall;

function isMobileDevice() {
    return windowWidth <= 800;
}

function setup() {
    createCanvas(windowWidth, windowHeight);
    initializeLevel(currentLevel);

    // Adjust goal dimensions based on device
    if (isMobileDevice()) {
        goalWidth = width * 0.08;
        goalHeight = height * 0.15;
        goalLipThickness = goalWidth * 0.3;
    } else {
        goalWidth = width * 0.05;
        goalHeight = height * 0.1;
        goalLipThickness = goalWidth * 0.25;
    }

    engine = Engine.create();
    world = engine.world;

    // Create walls
    topWall = Bodies.rectangle(width / 2, -10, width, 20, { isStatic: true });
    bottomWall = Bodies.rectangle(width / 2, height + 10, width, 20, { isStatic: true });
    leftWall = Bodies.rectangle(-10, height / 2, 20, height, { isStatic: true });
    rightWall = Bodies.rectangle(width + 10, height / 2, 20, height, { isStatic: true });
    World.add(world, [topWall, bottomWall, leftWall, rightWall]);

    startTime = millis();
    startPoint = { x: random(20, width - 20), y: 120 };

    // Create goal
    let goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);

    goalBody = Bodies.rectangle(goalPosX, height - 10, goalWidth, goalHeight - goalLipThickness, {
        isStatic: true,
        label: 'goal'
    });

    goalLipLeft = Bodies.rectangle(goalPosX - goalWidth / 2, height - 10 - (goalHeight - goalLipThickness) / 2, goalLipThickness, goalHeight - goalLipThickness, {
        isStatic: true,
        label: 'block'
    });

    goalLipRight = Bodies.rectangle(goalPosX + goalWidth / 2, height - 10 - (goalHeight - goalLipThickness) / 2, goalLipThickness, goalHeight - goalLipThickness, {
        isStatic: true,
        label: 'block'
    });

    World.add(world, [goalBody, goalLipLeft, goalLipRight]);

    // Collision event handling
    Events.on(engine, 'collisionStart', function(event) {
        let pairs = event.pairs;
        for (let i = 0; i < pairs.length; i++) {
            let bodyA = pairs[i].bodyA;
            let bodyB = pairs[i].bodyB;

            // Check if lemming hits the bottom wall (missed goal)
            if ((bodyA === bottomWall && bodyB.label === 'lemming') ||
                (bodyB === bottomWall && bodyA.label === 'lemming')) {
                // Remove the lemming from the world and from the lemmings array
                let lemmingBody = bodyA.label === 'lemming' ? bodyA : bodyB;
                removeLemming(lemmingBody);
            }

            // Check if lemming enters the goal
            if ((bodyA.label === 'goal' && bodyB.label === 'lemming') ||
                (bodyB.label === 'goal' && bodyA.label === 'lemming')) {
                score++;
                // Remove lemming from world and lemmings array
                let lemmingBody = bodyA.label === 'lemming' ? bodyA : bodyB;
                removeLemming(lemmingBody);
            }
        }
    });
}

function removeLemming(lemmingBody) {
    World.remove(world, lemmingBody);
    // Remove from lemmings array
    for (let i = 0; i < lemmings.length; i++) {
        if (lemmings[i] === lemmingBody) {
            lemmings.splice(i, 1);
            break;
        }
    }
}

function areLemmingsStill() {
    for (let lemming of lemmings) {
        if (lemming.speed > 0.5) { // Adjusted speed threshold
            return false; // A lemming is still moving
        }
    }
    return true; // No lemmings are moving
}

function draw() {
    background(0);

    Engine.update(engine);

    // Game over conditions
    if (availableBalls === 0 && areLemmingsStill() && !gameWon && !gameLost) {
        gameLost = true;
        noLoop();
    }

    if (ballsToPut == score && !gameWon && !gameLost) {
        gameWon = true;
        noLoop();
    }

    // Display game over messages
    if (gameWon) {
        textSize(32);
        fill(255);
        textAlign(CENTER, CENTER);
        text('You won level ' + level + ', press any key to level up', width / 2, height / 2);
        noLoop();
        return;
    }

    if (gameLost) {
        textSize(32);
        fill(255);
        textAlign(CENTER, CENTER);
        text('Game over, press any key to restart', width / 2, height / 2);
        noLoop();
        return;
    }

    // Display game information
    fill(255);
    textSize(20);
    textAlign(LEFT, TOP);
    text(""Current level: "" + currentLevel, 10, 10);
    text(""Goal: Get "" + ballsToPut + "" ball(s)"", 10, 35);
    text(""Remaining balls: "" + max(0, availableBalls), 10, 60);
    text(""Balls scored: "" + score, 10, 85);
    text(""Blocks still available: "" + blocksAvailable, 10, 110);

    // Spawn lemmings
    if (frameCount % 30 == 0 && availableBalls > 0) {
        let lemming = Bodies.circle(startPoint.x, startPoint.y, 7.5, {
            friction: 0.001,
            restitution: 0.5,
            label: 'lemming'
        });
        World.add(world, lemming);
        lemmings.push(lemming);
        availableBalls--;
    }

    // Render lemmings
    let lemmingSize = isMobileDevice() ? width * 0.03 : 15;
    fill(0, 255, 255);
    noStroke();
    for (let lemming of lemmings) {
        ellipse(lemming.position.x, lemming.position.y, lemmingSize);
    }

    // Display entry point
    fill(255, 255, 0);
    ellipse(startPoint.x, startPoint.y, 40, 40);

    // Display goal
    rectMode(CENTER);
    fill(0, 255, 255);
    rect(goalBody.position.x, goalBody.position.y, goalWidth, goalHeight - goalLipThickness);

    // Display goal lips
    fill(255, 255, 0);
    rect(goalLipLeft.position.x, goalLipLeft.position.y, goalLipThickness, goalHeight - goalLipThickness);
    rect(goalLipRight.position.x, goalLipRight.position.y, goalLipThickness, goalHeight - goalLipThickness);

    // Display blocks
    fill(255, 255, 0);
    for (let block of blocks) {
        push();
        translate(block.position.x, block.position.y);
        rotate(block.angle);
        rect(0, 0, 40, 10);
        pop();
    }
}

function placeBlock() {
    if (blocksAvailable > 0) {
        let block = Bodies.rectangle(mouseX, mouseY, 40, 10, {
            isStatic: true,
            angle: 0,
            label: 'block'
        });
        World.add(world, block);
        blocks.push(block);
        blocksAvailable--;
    }
}

function mousePressed() {
    if (gameWon) {
        levelUp();
    } else if (gameLost) {
        restartGame();
    } else {
        placeBlock();
    }
}

function touchStarted() {
    if (gameWon) {
        levelUp();
    } else if (gameLost) {
        restartGame();
    } else {
        placeBlock();
    }
    return false; // Prevent default behavior
}

function keyPressed() {
    if (gameWon) {
        levelUp();
    } else if (gameLost) {
        restartGame();
    }
}

function initializeLevel(level) {
    ballsToPut = level;  // Increase balls required with each level
    blocksAvailable = max(100 - level + 1, 1);  // Decrease blocks available with each level, minimum 1
}

function levelUp() {
    level++;
    currentLevel = level;
    score = 0;
    availableBalls = 200;
    gameWon = false;

    initializeLevel(level);

    // Remove lemmings from world
    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];

    // Remove blocks from world
    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];

    // Randomize startPoint and goal position
    startPoint.x = random(20, width - 20);

    let goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);
    Matter.Body.setPosition(goalBody, { x: goalPosX, y: goalBody.position.y });
    Matter.Body.setPosition(goalLipLeft, { x: goalPosX - goalWidth / 2, y: goalLipLeft.position.y });
    Matter.Body.setPosition(goalLipRight, { x: goalPosX + goalWidth / 2, y: goalLipRight.position.y });

    loop();
}

function restartGame() {
    gameLost = false;
    gameWon = false;
    level = 1;
    currentLevel = level;
    score = 0;
    availableBalls = 200;

    initializeLevel(level);

    // Remove lemmings from world
    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];

    // Remove blocks from world
    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];

    // Randomize startPoint and goal position
    startPoint.x = random(20, width - 20);

    let goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);
    Matter.Body.setPosition(goalBody, { x: goalPosX, y: goalBody.position.y });
    Matter.Body.setPosition(goalLipLeft, { x: goalPosX - goalWidth / 2, y: goalLipLeft.position.y });
    Matter.Body.setPosition(goalLipRight, { x: goalPosX + goalWidth / 2, y: goalLipRight.position.y });

    loop();
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    // Also, re-create the walls and adjust positions
    World.remove(world, [topWall, bottomWall, leftWall, rightWall]);

    topWall = Bodies.rectangle(width / 2, -10, width, 20, { isStatic: true });
    bottomWall = Bodies.rectangle(width / 2, height + 10, width, 20, { isStatic: true });
    leftWall = Bodies.rectangle(-10, height / 2, 20, height, { isStatic: true });
    rightWall = Bodies.rectangle(width + 10, height / 2, 20, height, { isStatic: true });
    World.add(world, [topWall, bottomWall, leftWall, rightWall]);
}
"
"2355070","Hypercube Flux","mySketch","// Hypercube Flux
// Visualizing a rotating hypercube projected onto 3D space with interactive 3D navigation.

let easycam;
let particles = [];
let numParticles = 500;
let hypercubeVertices = [];
let angle = 0;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  colorMode(HSB, 360, 100, 100, 100);

  // Initialize EasyCam for 3D navigation
  easycam = createEasyCam();
  document.oncontextmenu = function() { return false; } // Disable right-click context menu

  // Initialize particles
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle());
  }

  background(0);
}

function draw() {
  background(0, 0, 0, 20); // Slight trail effect

  // Update and draw hypercube
  hypercubeVertices = generateHypercubeVertices(angle);
  angle += 0.01;

  // Draw particles
  for (let p of particles) {
    p.update(hypercubeVertices);
    p.show();
  }
}

class Particle {
  constructor() {
    this.pos = createVector(0, 0, 0);
    this.vel = p5.Vector.random3D().mult(random(0.5, 1.5));
    this.color = color(random(360), 80, 100, 80);
    this.size = random(2, 5);
  }

  update(vertices) {
    // Attract particle towards a random hypercube vertex
    let target = random(vertices);
    let force = p5.Vector.sub(target, this.pos);
    force.setMag(0.05);
    this.vel.add(force);
    this.vel.limit(5);
    this.pos.add(this.vel);

    // Wrap around space
    if (this.pos.mag() > 500) {
      this.pos.mult(-1);
    }
  }

  show() {
    push();
    noStroke();
    fill(this.color);
    translate(this.pos.x, this.pos.y, this.pos.z);
    sphere(this.size);
    pop();
  }
}

function generateHypercubeVertices(a) {
  let vertices = [];
  let coords = [-1, 1];
  for (let x of coords) {
    for (let y of coords) {
      for (let z of coords) {
        for (let w of coords) {
          // 4D rotation matrices (rotation in the wx and yz planes)
          let r = 200;
          let x1 = x * cos(a) - w * sin(a);
          let w1 = x * sin(a) + w * cos(a);
          let y1 = y * cos(a) - z * sin(a);
          let z1 = y * sin(a) + z * cos(a);

          // Project from 4D to 3D space (ignoring w1)
          let factor = r / (r + w1);
          let x2 = x1 * factor;
          let y2 = y1 * factor;
          let z2 = z1 * factor;

          vertices.push(createVector(x2, y2, z2));
        }
      }
    }
  }
  return vertices;
}
"
"2355067","Kaleidoscopic Vortex","mySketch","// Kaleidoscopic Vortex Particle System
// Particles are influenced by dynamic vortices, creating intense and colorful swirling patterns.

let particles = [];
let numParticles = 1000;
let time = 0;
let timeIncrement = 0.01;

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);
  
  // Initialize particles
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }
  
  background(0);
}

function draw() {
  background(0, 0, 0, 25); // Slight trail effect with higher opacity for intense colors
  
  for (let p of particles) {
    p.update();
    p.show();
  }
  
  time += timeIncrement;
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.prevPos = this.pos.copy();
    this.speed = random(2, 5);
    this.color = color(random(360), 100, 100, 80);
  }
  
  update() {
    let angle = getVortexAngle(this.pos.x, this.pos.y, time);
    let vel = p5.Vector.fromAngle(angle);
    vel.mult(this.speed);
    this.prevPos = this.pos.copy();
    this.pos.add(vel);
    
    // Wrap around edges
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }
  
  show() {
    stroke(this.color);
    strokeWeight(2);
    line(this.prevPos.x, this.prevPos.y, this.pos.x, this.pos.y);
  }
}

function getVortexAngle(x, y, t) {
  // Create dynamic vortices influenced by mouse position and time
  let dx = x - mouseX;
  let dy = y - mouseY;
  let distance = sqrt(dx * dx + dy * dy);
  let angle = atan2(dy, dx);
  
  // Vortex intensity decreases with distance from mouse
  let intensity = constrain(200 / (distance + 50), 0, 10);
  
  // Add time-based variation for dynamic effect
  angle += sin(t * 5 + distance * 0.02) * intensity;
  
  return angle;
}

function mousePressed() {
  // Add burst of particles at mouse position
  for (let i = 0; i < 50; i++) {
    let p = new Particle(mouseX, mouseY);
    particles.push(p);
  }
}
"
"2355065","Quasicrystal Flow","mySketch","// Quasicrystal Flow Particle System
// Particles move according to a dynamic flow field generated by superimposing multiple sine waves with irrational frequencies.

let particles = [];
let numParticles = 500;
let flowFieldScale = 0.01;
let time = 0;
let timeIncrement = 0.01;
let coefficients = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 100, 100, 100);
  
  // Initialize particles
  for (let i = 0; i < numParticles; i++) {
    particles.push(new Particle(random(width), random(height)));
  }
  
  // Initialize coefficients with irrational ratios
  for (let i = 0; i < 5; i++) {
    coefficients.push({
      k: random(0.5, 1.5) * PI,
      l: random(0.5, 1.5) * PI,
      m: random(0.5, 1.5) * PI
    });
  }
  
  background(0);
}

function draw() {
  noStroke();
  fill(0, 0, 0, 5); // Slightly fade the background to create trails
  rect(0, 0, width, height);
  
  for (let p of particles) {
    p.update();
    p.show();
  }
  
  time += timeIncrement;
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.prevPos = this.pos.copy();
    this.speed = random(1, 3);
    this.color = color(random(360), 80, 100, 50);
  }
  
  update() {
    let angle = getFlowFieldAngle(this.pos.x, this.pos.y, time);
    let vel = p5.Vector.fromAngle(angle);
    vel.mult(this.speed);
    this.prevPos = this.pos.copy();
    this.pos.add(vel);
    
    // Wrap around edges
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }
  
  show() {
    stroke(this.color);
    line(this.prevPos.x, this.pos.y, this.pos.x, this.pos.y);
  }
}

function getFlowFieldAngle(x, y, t) {
  let angle = 0;
  for (let coeff of coefficients) {
    angle += sin(coeff.k * x * flowFieldScale + coeff.l * y * flowFieldScale + coeff.m * t);
  }
  return angle;
}

function mouseMoved() {
  // Influence flow field coefficients based on mouse position
  for (let coeff of coefficients) {
    coeff.k += (mouseX - width / 2) * 0.00001;
    coeff.l += (mouseY - height / 2) * 0.00001;
  }
}

function mousePressed() {
  // Add new particles at mouse position
  for (let i = 0; i < 10; i++) {
    particles.push(new Particle(mouseX, mouseY));
  }
}
"
"2355059","Aggressive Audio-Reactive Particle System","mySketch.js","let mic, fft;
let particles = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  noStroke();

  // Initialize microphone input
  mic = new p5.AudioIn();
  mic.start();

  // Initialize FFT analyzer with lower smoothing for faster response
  fft = new p5.FFT(0.7, 128); // Decreased smoothing, increased bins
  fft.setInput(mic);

  // Create more particles for a denser effect
  for (let i = 0; i < 800; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  background(0, 40); // Lower alpha for longer trails

  // Analyze the audio input
  let spectrum = fft.analyze();
  let bassEnergy = fft.getEnergy(""bass"");
  let trebleEnergy = fft.getEnergy(""treble"");
  let midEnergy = fft.getEnergy(""mid"");

  // Update and display particles
  particles.forEach((p, index) => {
    let freqIndex = map(index, 0, particles.length, 0, spectrum.length);
    let energy = spectrum[floor(freqIndex)];
    p.update(energy, bassEnergy, midEnergy, trebleEnergy);
    p.show();
  });
}

class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = p5.Vector.random2D();
    this.acc = createVector(0, 0);
    this.size = random(1, 3);
    this.color = [random(255), random(255), random(255)];
  }

  update(energy, bass, mid, treble) {
    // Movement influenced by audio energy and randomness
    let angle = noise(this.pos.x * 0.01, this.pos.y * 0.01) * TWO_PI * 4;
    this.acc = p5.Vector.fromAngle(angle);
    this.acc.mult(energy * 0.01); // Increased multiplier for aggressiveness

    // Adding randomness to movement for unpredictability
    let randomForce = p5.Vector.random2D().mult(0.5);
    this.acc.add(randomForce);

    this.vel.add(this.acc);
    this.vel.limit(map(energy, 0, 255, 2, 12)); // Higher max speed

    this.pos.add(this.vel);

    // Change size based on combined energies
    this.size = map(energy, 0, 255, 2, 25); // Larger size for impact

    // Dynamic color changes based on different frequency energies
    this.color = [
      map(bass, 0, 255, 50, 255),  // Red channel reacts to bass
      map(mid, 0, 255, 50, 255),   // Green channel reacts to mid frequencies
      map(treble, 0, 255, 50, 255) // Blue channel reacts to treble
    ];

    // Edge wrapping
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;

    // Reset acceleration
    this.acc.mult(0);
  }

  show() {
    fill(this.color[0], this.color[1], this.color[2], 220);
    ellipse(this.pos.x, this.pos.y, this.size);
  }
}
"
"2353611","Product adoption","mySketch","let particles = [];
let totalParticles = 300;
let adoptionThreshold = 0.2; // Critical mass threshold
let adoptionRate = 0.05;     // Base adoption probability
let churnRate = 0.01;        // Probability of churn per frame

function setup() {
  createCanvas(800, 600);
  // Initialize particles
  for (let i = 0; i < totalParticles; i++) {
    particles.push(new Particle());
  }
  // Introduce initial adopters
  for (let i = 0; i < 5; i++) {
    particles[i].state = 'adopted';
  }
}

function draw() {
  background(30);
  
  // Calculate current adoption percentage
  let adoptedCount = particles.filter(p => p.state === 'adopted').length;
  let adoptionPercentage = adoptedCount / totalParticles;
  
  // Adjust adoption rate based on critical mass
  let currentAdoptionRate = adoptionRate;
  if (adoptionPercentage > adoptionThreshold) {
    currentAdoptionRate += (adoptionPercentage - adoptionThreshold) * 0.5;
  }
  
  // Update and display particles
  for (let particle of particles) {
    particle.update(currentAdoptionRate);
    particle.display();
  }
  
  // Display adoption stats
  fill(255);
  noStroke();
  textSize(16);
  text(`Adoption: ${(adoptionPercentage * 100).toFixed(1)}%`, 10, height - 20);
}

function mousePressed() {
  // Introduce new adopters where the mouse is clicked
  for (let particle of particles) {
    let d = dist(mouseX, mouseY, particle.position.x, particle.position.y);
    if (d < 50) {
      particle.state = 'adopted';
    }
  }
}

// Particle class
class Particle {
  constructor() {
    this.position = createVector(random(width), random(height));
    this.velocity = p5.Vector.random2D();
    this.velocity.setMag(1);
    this.state = 'nonAdopted'; // States: 'nonAdopted', 'adopted', 'churned'
    this.timer = 0;
  }
  
  update(adoptionRate) {
    // Move particle
    this.position.add(this.velocity);
    this.edges();
    
    // Interaction with other particles
    if (this.state === 'nonAdopted') {
      for (let other of particles) {
        if (other.state === 'adopted') {
          let d = dist(this.position.x, this.position.y, other.position.x, other.position.y);
          if (d < 20 && random() < adoptionRate) {
            this.state = 'adopted';
            break;
          }
        }
      }
    } else if (this.state === 'adopted') {
      // Churn process
      if (random() < churnRate) {
        this.state = 'churned';
      }
    }
  }
  
  display() {
    noStroke();
    if (this.state === 'nonAdopted') {
      fill(200);
    } else if (this.state === 'adopted') {
      fill(100, 200, 100);
    } else if (this.state === 'churned') {
      fill(200, 100, 100);
    }
    ellipse(this.position.x, this.position.y, 8, 8);
  }
  
  edges() {
    // Wrap around edges
    if (this.position.x > width) this.position.x = 0;
    if (this.position.x < 0) this.position.x = width;
    if (this.position.y > height) this.position.y = 0;
    if (this.position.y < 0) this.position.y = height;
  }
}
"
"2353608","Clifford Attractor","mySketch","let a = -1.4;
let b = 1.6;
let c = 1.0;
let d = 0.7;

let x, y;
let points = [];

function setup() {
  createCanvas(800, 800);
  background(0);
  colorMode(HSB, 360, 100, 100, 100);
  x = random(-1, 1);
  y = random(-1, 1);
  
  // Generate points
  for (let i = 0; i < 1000000; i++) {
    let x1 = Math.sin(a * y) + c * Math.cos(a * x);
    let y1 = Math.sin(b * x) + d * Math.cos(b * y);
    x = x1;
    y = y1;
    points.push({ x: x, y: y });
  }
}

function draw() {
  background(0, 0, 0, 10); // Slight fade for trailing effect

  translate(width / 2, height / 2);
  scale(180); // Scale up the attractor for better visibility

  noStroke();
  
  for (let i = 0; i < points.length; i++) {
    let px = points[i].x;
    let py = points[i].y;
    let hue = map(i, 0, points.length, 0, 360);
    fill(hue, 80, 100, 50);
    ellipse(px, py, 0.005, 0.005);
  }

  noLoop(); // Stop draw() after rendering all points
}
"
"2353606","Reaction-Diffusion Algorithm","mySketch","let grid, nextGrid;
let dA = 1.0;
let dB = 0.5;
let feed = 0.055;
let kill = 0.062;
let width = 200;
let height = 200;

function setup() {
  createCanvas(600, 600);
  pixelDensity(1);
  grid = [];
  nextGrid = [];

  // Initialize the grids
  for (let x = 0; x < width; x++) {
    grid[x] = [];
    nextGrid[x] = [];
    for (let y = 0; y < height; y++) {
      grid[x][y] = { a: 1, b: 0 };
      nextGrid[x][y] = { a: 1, b: 0 };
    }
  }

  // Seed the grid with a circle of ""B"" chemical
  for (let i = -10; i < 10; i++) {
    for (let j = -10; j < 10; j++) {
      let x = width / 2 + i;
      let y = height / 2 + j;
      if (x >= 0 && x < width && y >= 0 && y < height) {
        grid[x][y].b = 1;
      }
    }
  }
}

function draw() {
  background(0);

  // Run the reaction-diffusion algorithm
  for (let x = 1; x < width - 1; x++) {
    for (let y = 1; y < height - 1; y++) {
      let a = grid[x][y].a;
      let b = grid[x][y].b;

      // Laplacian diffusion
      let lapA = laplaceA(x, y);
      let lapB = laplaceB(x, y);

      // Reaction-diffusion equations
      let reaction = a * b * b;
      nextGrid[x][y].a =
        a +
        (dA * lapA - reaction + feed * (1 - a)) * 1;
      nextGrid[x][y].b =
        b +
        (dB * lapB + reaction - (kill + feed) * b) * 1;

      // Constrain values between 0 and 1
      nextGrid[x][y].a = constrain(nextGrid[x][y].a, 0, 1);
      nextGrid[x][y].b = constrain(nextGrid[x][y].b, 0, 1);
    }
  }

  // Swap the grids
  let temp = grid;
  grid = nextGrid;
  nextGrid = temp;

  loadPixels();
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      let pix = (x + y * width) * 4;
      let a = grid[x][y].a;
      let b = grid[x][y].b;
      let c = floor((a - b) * 255);
      c = constrain(c, 0, 255);
      pixels[pix + 0] = c;
      pixels[pix + 1] = c;
      pixels[pix + 2] = c;
      pixels[pix + 3] = 255;
    }
  }
  updatePixels();

  // Display the simulation scaled up
  noSmooth();
  image(
    get(0, 0, width, height),
    0,
    0,
    width * 3,
    height * 3
  );

  // Interaction with the mouse
  if (mouseIsPressed) {
    let mx = floor(map(mouseX, 0, width * 3, 0, width));
    let my = floor(map(mouseY, 0, height * 3, 0, height));
    for (let i = -2; i <= 2; i++) {
      for (let j = -2; j <= 2; j++) {
        let x = mx + i;
        let y = my + j;
        if (x >= 0 && x < width && y >= 0 && y < height) {
          grid[x][y].b = 1;
        }
      }
    }
  }
}

// Laplacian functions for A and B chemicals
function laplaceA(x, y) {
  let sumA = 0;
  sumA += grid[x][y].a * -1;
  sumA += grid[x - 1][y].a * 0.2;
  sumA += grid[x + 1][y].a * 0.2;
  sumA += grid[x][y + 1].a * 0.2;
  sumA += grid[x][y - 1].a * 0.2;
  sumA += grid[x - 1][y - 1].a * 0.05;
  sumA += grid[x + 1][y - 1].a * 0.05;
  sumA += grid[x + 1][y + 1].a * 0.05;
  sumA += grid[x - 1][y + 1].a * 0.05;
  return sumA;
}

function laplaceB(x, y) {
  let sumB = 0;
  sumB += grid[x][y].b * -1;
  sumB += grid[x - 1][y].b * 0.2;
  sumB += grid[x + 1][y].b * 0.2;
  sumB += grid[x][y + 1].b * 0.2;
  sumB += grid[x][y - 1].b * 0.2;
  sumB += grid[x - 1][y - 1].b * 0.05;
  sumB += grid[x + 1][y - 1].b * 0.05;
  sumB += grid[x + 1][y + 1].b * 0.05;
  sumB += grid[x - 1][y + 1].b * 0.05;
  return sumB;
}
"
"2353605","Effects of gravitational waves","mySketch","let masses = [];
let clickCount = 0;

function setup() {
  createCanvas(800, 600);
  background(0);
}

function draw() {
  background(0, 20); // Fade effect to visualize waves over time
  noStroke();
  
  // Update and display all masses
  for (let mass of masses) {
    mass.update();
    mass.display();
  }
}

function mousePressed() {
  clickCount++;
  let massValue = clickCount * 10; // Mass increases with each click
  masses.push(new Mass(mouseX, mouseY, massValue));
}

// Mass class representing an object affecting the gravitational field
class Mass {
  constructor(x, y, mass) {
    this.position = createVector(x, y);
    this.mass = mass;
    this.time = 0;
  }
  
  update() {
    this.time += 0.05; // Increment time to animate waves
  }
  
  display() {
    // Simulate gravitational waves as expanding circles
    let maxRadius = this.mass * 5;
    for (let r = 0; r < maxRadius; r += 5) {
      let alpha = map(r, 0, maxRadius, 255, 0);
      stroke(100, 150, 255, alpha);
      noFill();
      ellipse(this.position.x, this.position.y, r * 2 + this.time * 10, r * 2 + this.time * 10);
    }
  }
}
"
"2353604","Meissner effect","mySketch","let numLines = 30;
let angle = 0;

function setup() {
  createCanvas(800, 600, WEBGL);
  smooth();
}

function draw() {
  background(0);
  orbitControl(); // Permite controlar a câmera com o mouse
  rotateY(angle);
  angle += 0.005;

  // Desenha o supercondutor
  noStroke();
  fill(50, 50, 200);
  push();
  translate(0, 50, 0);
  box(200, 20, 200);
  pop();

  // Desenha as linhas de campo magnético
  stroke(200, 50, 50);
  noFill();
  for (let i = -numLines; i <= numLines; i++) {
    beginShape();
    for (let y = -300; y <= 50; y += 5) {
      let x = i * 6;
      let z = campoMagnetico(x, y);
      vertex(x, y, z);
    }
    endShape();
  }
}

// Função que simula a repulsão do campo magnético pelo supercondutor
function campoMagnetico(x, y) {
  let scY = 50; // Posição Y do topo do supercondutor
  let distancia = dist(x, y, 0, scY);
  let intensidade = 0;
  
  if (y > scY) {
    // Abaixo do supercondutor, o campo magnético é zero
    intensidade = 0;
  } else {
    // Acima do supercondutor, o campo é repelido
    intensidade = 10000 / (distancia + 1);
  }
  
  // Calcula o desvio em Z para representar a repulsão
  let z = sin((x + frameCount) * 0.01) * intensidade * 0.01;
  return z;
}
"
"2314528","Respirar","mySketch","let FA, I, P, NAF, GSA;
let TR, FR;

function setup() {
  createCanvas(800, 600);
  noStroke();
  
  createP(""<ul style='color: white;'>"")
    .position(10, 10)
    .style('font-size', '16px');

  createP(""<li>Frequência de ataques de ansiedade (0-10):</li>"")
    .position(10, 40)
    .style('color', 'white');
  FA = createSlider(0, 10, 5);
  FA.position(320, 55);
  
  createP(""<li>Idade:</li>"")
    .position(10, 70)
    .style('color', 'white');
  I = createSlider(0, 100, 30);
  I.position(320, 85);
  
  createP(""<li>Peso (kg):</li>"")
    .position(10, 100)
    .style('color', 'white');
  P = createSlider(30, 150, 70);
  P.position(320, 115);
  
  createP(""<li>Nível de atividade física (0-10):</li>"")
    .position(10, 130)
    .style('color', 'white');
  NAF = createSlider(0, 10, 5);
  NAF.position(320, 145);
  
  createP(""<li>Grau de severidade dos sintomas de ansiedade (0-10):</li>"")
    .position(10, 160)
    .style('color', 'white');
  GSA = createSlider(0, 10, 6);
  GSA.position(320, 175);

  createP(""</ul>"").position(10, 190).style('color', 'white');
}

function draw() {
  background(0);
  
  let faValue = FA.value();
  let iValue = I.value();
  let pValue = P.value();
  let nafValue = NAF.value();
  let gsaValue = GSA.value();
  
  [TR, FR] = recomendarRespiracao(faValue, iValue, pValue, nafValue, gsaValue);
  
  let t = millis() / 1000;
  let breathCycle = 60 / FR;
  let phase = (t % breathCycle) / breathCycle;
  
  let size;
  if (TR === ""Respiração 4-7-8"") {
    size = tamanhoRespiracao478(phase);
  } else {
    size = tamanhoRespiracaoDiafragmatica(phase);
  }

  drawParticles(size);
  
  fill(255);
  textSize(16);
  text(`Tipo de Respiração: ${TR}`, 10, height - 50);
  text(`Frequência de Respiração: ${FR.toFixed(2)} respirações por minuto`, 10, height - 30);
}

function recomendarRespiracao(FA, I, P, NAF, GSA) {
  let TR;
  if (GSA >= 7) {
    TR = ""Respiração 4-7-8"";
  } else {
    TR = ""Respiração diafragmática"";
  }
  
  let FR = max(6, min(10, 10 - (FA / 2) - (GSA / 2) - (I / 100) - (P / 200)));
  return [TR, FR];
}

function tamanhoRespiracao478(phase) {
  if (phase < 4/19) {
    return sin(map(phase, 0, 4/19, 0, PI / 2));
  } else if (phase < 11/19) {
    return 1;
  } else {
    return sin(map(phase, 11/19, 1, PI / 2, 0));
  }
}

function tamanhoRespiracaoDiafragmatica(phase) {
  return sin(PI * phase);
}

function drawParticles(size) {
  let numParticles = 100;
  for (let i = 0; i < numParticles; i++) {
    let angle = TWO_PI * i / numParticles;
    let x = width / 2 + cos(angle) * 200 * size;
    let y = height / 2 + sin(angle) * 200 * size;
    fill(255, 100);
    ellipse(x, y, 10, 10);
  }
}
"
"2106394","Lemming Labyrinth","mySketch.js","let currentLevel = 1;
let gameLost = false;

let availableBalls = 200;
let totalBalls = 200;
let ballsToPut;
let blocksAvailable = 100;
let Engine = Matter.Engine,
    World = Matter.World,
    Bodies = Matter.Bodies,
    Events = Matter.Events;
let gameWon = false;
let engine;
let world;
let lemmings = [];
let blocks = [];
let goalBody, goalLipLeft, goalLipRight;
let startPoint;
let score = 0;
let level = 1;

function isMobileDevice() {
    return windowWidth <= 800;
}

function setup() {
    createCanvas(windowWidth, windowHeight);
    initializeLevel(currentLevel);

	if (isMobileDevice) {
    goalWidth = width * 0.08;
    goalHeight = height * 0.15;
    goalLipThickness = goalWidth * 0.3;
}
else {
    goalWidth = width * 0.05;
    goalHeight = height * 0.1;
    goalLipThickness = goalWidth * 0.25;
}

    engine = Engine.create();
    world = engine.world;

  let topWall = Bodies.rectangle(width / 2, -10, width, 20, { isStatic: true });
  let bottomWall = Bodies.rectangle(width / 2, height + 10, width, 20, { isStatic: true });
  let leftWall = Bodies.rectangle(-10, height / 2, 20, height, { isStatic: true });
  let rightWall = Bodies.rectangle(width + 10, height / 2, 20, height, { isStatic: true });
  World.add(world, [topWall, bottomWall, leftWall, rightWall]);

  startTime = millis();
startPoint = { x: random(20, width - 20), y: 120 };  // Moves it down below the top bar

  goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);

  // The main ""cup"" body
  goalBody = Bodies.rectangle(goalPosX, height - 10, goalWidth, goalHeight - goalLipThickness, { 
    isStatic: true,
    label: 'goal'
  });

  // Left lip of the cup
  goalLipLeft = Bodies.rectangle(goalPosX - goalWidth/2, height - 10 - (goalHeight - goalLipThickness) / 2, goalLipThickness, goalHeight - goalLipThickness, { 
    isStatic: true,
    label: 'block'
  });

  // Right lip of the cup
  goalLipRight = Bodies.rectangle(goalPosX + goalWidth/2, height - 10 - (goalHeight - goalLipThickness) / 2, goalLipThickness, goalHeight - goalLipThickness, { 
    isStatic: true,
    label: 'block'
  });

  World.add(world, [goalBody, goalLipLeft, goalLipRight]);

Events.on(engine, 'collisionStart', (function(event) {
  let pairs = event.pairs;
  for (let i = 0; i < pairs.length; i++) {
    if ((pairs[i].bodyA === bottomWall && pairs[i].bodyB.label !== 'block') || 
        (pairs[i].bodyB === bottomWall && pairs[i].bodyA.label !== 'block')) {
      availableBalls--
    }
    if (pairs[i].bodyA.label === 'goal' && pairs[i].bodyB.label !== 'block') {
      score++;
      World.remove(world, pairs[i].bodyB);
    } else if (pairs[i].bodyB.label === 'goal' && pairs[i].bodyA.label !== 'block') {
      score++;
      World.remove(world, pairs[i].bodyA);
    }
  }
}).bind(this));


}

function areLemmingsStill() {
    for (let lemming of lemmings) {
        if (lemming.speed > 4) { 
            return false; // A lemming is still moving
        }
    }
    return true; // No lemmings are moving
}


function draw() {
  background(0);


	if (availableBalls === 0 && areLemmingsStill()) {
    gameWon = false;
    gameLost = true;
    noLoop();
}

	
if (ballsToPut == score) {
   gameWon = true;
   noLoop(); // Stop the draw loop
}

	if (gameWon) {
  textSize(20);
	fill(255);
  text('You won level ' + level + ', press any key to level up', width / 2 - 200, height / 2);
  noLoop(); // Stop the draw loop.
} 

	if (gameLost) {
    textSize(20);
		fill(255);
    text('Game over, press any key to restart', width / 2 - 250, height / 2);
    noLoop();
}

    Engine.update(engine);
	

fill(0);  // Black text color
textSize(20);  // Increase the text size for better readability

// Adjusting the y-coordinate to 35 centers the text vertically within the rectangle.
text(""Current level: "" + currentLevel, 10, 35);
text(""Goal: Get "" + ballsToPut + "" ball(s)"", 10, 70);
text(""Remaining balls: "" + max(0, availableBalls), 10, 105);
text(""Balls scored: "" + score, 10, 140);
text(""Blocks still available: "" + blocksAvailable, 10, 175);
updateIndicators();

  


if (frameCount % 30 == 0 && availableBalls > 0) {
   let lemming = Bodies.circle(startPoint.x, startPoint.y, 7.5, {
     friction: 0.001 
   });
   World.add(world, lemming);
   lemmings.push(lemming);
   availableBalls--;
}

    let lemmingSize;
    if (isMobileDevice()) {
        lemmingSize = width * 0.03;   // 3% of screen width for mobile
    } else {
        lemmingSize = 15;             // fixed size for desktop
    }

    // Display lemmings with adjusted size
   fill(0, 255, 255);
    for (let i = lemmings.length - 1; i >= 0; i--) {
        let lemming = lemmings[i];
        ellipse(lemming.position.x, lemming.position.y, lemmingSize);
    }
	
if (score < 100) {
  timeToReach100 = (millis() - startTime) / 1000; // Keep updating until 100 balls
}
	
  // Display entry point
  fill(255, 255, 0);
  ellipse(startPoint.x, startPoint.y, 40, 40);

  // Display tunnel (goal)
  fill(0, 255, 255);
  rectMode(CENTER);
  rect(goalBody.position.x, goalBody.position.y, goalWidth, goalHeight - goalLipThickness);
  
  // Display the lips of the cup
  fill(255, 255, 0);
  rect(goalLipLeft.position.x, goalLipLeft.position.y, goalLipThickness, goalHeight - goalLipThickness);
  rect(goalLipRight.position.x, goalLipRight.position.y, goalLipThickness, goalHeight - goalLipThickness);

  // Display blocks
  fill(255, 255, 0);
  for (let block of blocks) {
    rect(block.position.x, block.position.y, 40, 10);
  }
}
	
function mousePressed() {
    placeBlock();
}

function touchStarted() {
    if (gameWon || gameLost) {
        handleGameStateOnTouch();
        return false; // Prevents default behavior
    } else {
        placeBlock();
        return false; // To prevent any default action for this touch event
    }
}

function handleGameStateOnTouch() {
    if (gameWon) {
        levelUp();
    } else if (gameLost) {
        restartGame();
    }
}

function updateIndicators() {
    document.getElementById('currentLevel').innerText = ""Current level: "" + currentLevel;
    document.getElementById('goal').innerText = ""Goal: Get "" + ballsToPut + "" ball(s)"";
    document.getElementById('remainingBalls').innerText = ""Remaining balls: "" + Math.max(0, availableBalls);
    document.getElementById('ballsScored').innerText = ""Balls scored: "" + score;
    document.getElementById('blocksAvailable').innerText = ""Blocks still available: "" + blocksAvailable;
}

// Call this function whenever these values change in your game
updateIndicators();


function placeBlock() {
    if (blocksAvailable > 0) {
        let block = Bodies.rectangle(mouseX, mouseY, 40, 10, { isStatic: true });
        World.add(world, block);
        blocks.push(block);
        blocksAvailable--;
    }
}

function initializeLevel(level) {
    ballsToPut = level;  // +1 ball for each level
    blocksAvailable = 101 - level;  // Blocks decrease by 1 each level
}


function levelUp() {
    level++;  // Increase the level by 1
    currentLevel = level; // Update the current level. This is used in displaying the level text.

    score = 0;
    availableBalls = 200;
    gameWon = false;

    // Update ballsToPut and blocksAvailable based on the new level
    initializeLevel(level);
    
    // Remove all the lemmings from the world and empty the lemmings array
    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];
    
    // Remove all blocks from the world and empty the blocks array
    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];
    
    // Move the door that releases the balls to a new position
    startPoint.x = random(20, width - 20);
    
    // Move the cup to a new position
    let goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);
    Matter.Body.setPosition(goalBody, { x: goalPosX, y: goalBody.position.y });
    Matter.Body.setPosition(goalLipLeft, { x: goalPosX - goalWidth/2, y: goalLipLeft.position.y });
    Matter.Body.setPosition(goalLipRight, { x: goalPosX + goalWidth/2, y: goalLipRight.position.y });

    loop();  // Restart the draw loop.
}



function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
    if (gameWon) {
        levelUp();
    } else {
        placeBlock();
    }
}

function restartGame() {
    gameLost = false;
    gameWon = false;
    level = 1;
    score = 0;
    availableBalls = 200;
    blocksAvailable = 100;
    initializeLevel(level);

    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];

    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];

    startPoint.x = random(20, width - 20);
    let goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);
    Matter.Body.setPosition(goalBody, { x: goalPosX, y: goalBody.position.y });
    Matter.Body.setPosition(goalLipLeft, { x: goalPosX - goalWidth/2, y: goalLipLeft.position.y });
    Matter.Body.setPosition(goalLipRight, { x: goalPosX + goalWidth/2, y: goalLipRight.position.y });

    loop();
}


function keyPressed() {
    if (gameWon) {
        levelUp();
    }
    if (gameLost) {
        restartGame();
    }
}
"
"2106394","Lemming Labyrinth","style.css","body {
    background-color: #000;
    color: #fff;
    font-family: 'Press Start 2P', cursive;
    text-align: center;
}

#game-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    border: 1px solid #fff;
    background-color: #111;
}

#game-header h1 {
    color: #ff0;
    text-shadow: 3px 3px 0px #0f0;
}

#game-header p {
    color: #0ff;
    margin-bottom: 20px;
}

.indicator {
    background-color: #222;
    border: 1px solid #fff;
    padding: 10px;
    margin-bottom: 10px;
    text-shadow: 1px 1px 0px #f00;
}

#game-canvas {
    margin-top: 20px;
}

/* Add any additional styling you need here */
"
"2106394","Lemming Labyrinth","index.html","<!DOCTYPE html>
<html>
<head>
    <title>Lemming Labyrinth Game</title>
    <link href=""https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"" rel=""stylesheet"">
    <script src=""https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js""></script>
    <script src=""https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js""></script>
    <link rel=""stylesheet"" type=""text/css"" href=""style.css"">
</head>
<body>
    <div id=""game-container"">
        <div id=""game-header"">
            <h1>Lemming Labyrinth</h1>
            <p>Guide the balls to the goal. Use limited blocks wisely, across increasingly challenging levels.</p>
					<p>A game by Gonçalo Perdigão from Algorithm G Studios</p>
        </div>
        <div id=""game-indicators"">
            <div id=""currentLevel"" class=""indicator""></div>
            <div id=""goal"" class=""indicator""></div>
            <div id=""remainingBalls"" class=""indicator""></div>
            <div id=""ballsScored"" class=""indicator""></div>
            <div id=""blocksAvailable"" class=""indicator""></div>
        </div>
        <div id=""game-canvas"">
            <script src=""mySketch.js""></script>
        </div>
    </div>
</body>
</html>
"
"2100932","Lemmings v2","mySketch.js","let currentLevel = 1;
let gameLost = false;
let availableBalls = 200;
let ballsToPut;
let blocksAvailable = 100;
let Engine = Matter.Engine,
    World = Matter.World,
    Bodies = Matter.Bodies,
    Events = Matter.Events;
let gameWon = false;
let engine;
let world;
let lemmings = [];
let blocks = [];
let goalBody, goalLipLeft, goalLipRight;
let startPoint;
let score = 0;
let level = 1;
let retroFont; // Declare a variable for the custom font

let popcornImg; // Declare a variable to hold the popcorn image
let butterImg; // Declare a variable to hold the butter image
let panImg; // Declare a variable to hold the pan image
let cupImg; // Declare a variable to hold the cup image
let bgImg; // Declare a variable for the background image

function preload() {
    popcornImg = loadImage('popcorn.png'); // Load the popcorn image
	    butterImg = loadImage('butter.png'); // Load the butter image
	  panImg = loadImage('pan.png'); // Load the pan image
	 cupImg = loadImage('cup2.png'); // Load the cup image
	 bgImg = loadImage('back7.png'); // Adjust the path as necessary
	retroFont = loadFont('font.ttf'); // Load the custom font
}

function isMobileDevice() {
    return windowWidth <= 800;
}

function setup() {
  let canvas = createCanvas(1400, 800);
    initializeLevel(currentLevel);
  textFont(retroFont); // Set the font for text
	
    if (isMobileDevice) {
        goalWidth = width * 0.08;
        goalHeight = height * 0.15;
        goalLipThickness = goalWidth * 0.3;
    }
    else {
        goalWidth = width * 0.05;
        goalHeight = height * 0.1;
        goalLipThickness = goalWidth * 0.25;
    }

    engine = Engine.create();
    world = engine.world;

  let topWall = Bodies.rectangle(width / 2, -10, width, 20, { isStatic: true });
  let bottomWall = Bodies.rectangle(width / 2, height + 10, width, 20, { isStatic: true });
  let leftWall = Bodies.rectangle(-10, height / 2, 20, height, { isStatic: true });
  let rightWall = Bodies.rectangle(width + 10, height / 2, 20, height, { isStatic: true });
  World.add(world, [topWall, bottomWall, leftWall, rightWall]);

  startTime = millis();
startPoint = { x: random(20, width - 20), y: 120 };  // Moves it down below the top bar

  goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);

  // The main ""cup"" body
  goalBody = Bodies.rectangle(goalPosX, height - 10, goalWidth, goalHeight - goalLipThickness, { 
    isStatic: true,
    label: 'goal'
  });

  // Left lip of the cup
  goalLipLeft = Bodies.rectangle(goalPosX - goalWidth/2, height - 10 - (goalHeight - goalLipThickness) / 2, goalLipThickness, goalHeight - goalLipThickness, { 
    isStatic: true,
    label: 'block'
  });

  // Right lip of the cup
  goalLipRight = Bodies.rectangle(goalPosX + goalWidth/2, height - 10 - (goalHeight - goalLipThickness) / 2, goalLipThickness, goalHeight - goalLipThickness, { 
    isStatic: true,
    label: 'block'
  });

  World.add(world, [goalBody, goalLipLeft, goalLipRight]);

Events.on(engine, 'collisionStart', (function(event) {
  let pairs = event.pairs;
  for (let i = 0; i < pairs.length; i++) {
    if ((pairs[i].bodyA === bottomWall && pairs[i].bodyB.label !== 'block') || 
        (pairs[i].bodyB === bottomWall && pairs[i].bodyA.label !== 'block')) {
      availableBalls--
    }
    if (pairs[i].bodyA.label === 'goal' && pairs[i].bodyB.label !== 'block') {
      score++;
      World.remove(world, pairs[i].bodyB);
    } else if (pairs[i].bodyB.label === 'goal' && pairs[i].bodyA.label !== 'block') {
      score++;
      World.remove(world, pairs[i].bodyA);
    }
  }
}).bind(this));
  imageMode(CORNER);

}

function areLemmingsStill() {
    for (let lemming of lemmings) {
        if (lemming.speed > 0.5) { 
            return false; // A lemming is still moving
        }
    }
    return true; // No lemmings are moving
}


function draw() {
  clear();
	displayBackground();
  handleGameStates();
  updatePhysics();
  displayTopBar();
  generateLemmings();
  displayLemmings();
  displayStartPoint();
  displayGoal();
  displayBlocks();
}

function displayBackground() {
  image(bgImg, 700, 400, 1400, 800); // Draw the full background image
}

function handleGameStates() {
  if (availableBalls === 0 && areLemmingsStill()) {
    gameWon = false;
    gameLost = true;
    noLoop();
  }
  
  if (ballsToPut == score) {
    gameWon = true;
    noLoop(); // Stop the draw loop
  }
  
  if (gameWon) {
    displayWinMessage();
  } else if (gameLost) {
    displayLoseMessage();
  }
}

function updatePhysics() {
  Engine.update(engine);
}

function displayTopBar() {
  fill(255, 255, 0); // Set text color to neon yellow for an 80s vibe
  textSize(30); // Set text size for better readability
  

  // Display game information with a shadow for a neon effect
  textShadow();
  text(""Level: "" + currentLevel, 10, 35);
  text(""Target Popcorns: "" + ballsToPut, 10, 70);
  text(""Popcorns Left: "" + availableBalls, 10, 105);
  text(""Popcorns In: "" + score, 10, 140);
  text(""Butter Blocks Left: "" + blocksAvailable, 10, 175);
}

function textShadow() {
  fill(0);
  for (let i = 0; i < 5; i++) {
    text(""Level: "" + currentLevel, 10 - i, 35 - i);
    text(""Target Popcorns: "" + ballsToPut, 10 - i, 70 - i);
    text(""Popcorns Left: "" + availableBalls, 10 - i, 105 - i);
    text(""Popcorns In: "" + score, 10 - i, 140 - i);
    text(""Butter Blocks Left: "" + blocksAvailable, 10 - i, 175 - i);
  }
  // Reset fill color for the main text
  fill(255, 255, 0);
}

function generateLemmings() {
  if (frameCount % 30 == 0 && availableBalls > 0) {
    let lemming = Bodies.circle(startPoint.x, startPoint.y, 7.5, { friction: 0.001 });
    World.add(world, lemming);
    lemmings.push(lemming);
    availableBalls--;
  }
}

function displayLemmings() {
  let lemmingSize = isMobileDevice() ? width * 0.03 : 15;
  for (let lemming of lemmings) {
    image(popcornImg, lemming.position.x - lemmingSize / 2, lemming.position.y - lemmingSize / 2, lemmingSize, lemmingSize); 
  }
}

function displayStartPoint() {
  image(panImg, startPoint.x - 20, startPoint.y - 20, 120, 120);
}

function displayGoal() {
  imageMode(CENTER);
  image(cupImg, goalBody.position.x, goalBody.position.y, goalWidth, goalHeight);
}

function displayBlocks() {
  for (let block of blocks) {
    image(butterImg, block.position.x - 20, block.position.y - 5, 40, 10);
  }
}

function displayWinMessage() {
  textSize(32);
  text('You won level ' + level + ', press any key to level up', width / 2 - 200, height / 2);
}

function displayLoseMessage() {
  textSize(32);
  text('Game over, press any key to restart', width / 2 - 250, height / 2);
}

	
function mousePressed() {
    if (gameWon) {
        levelUp();
    } else if (!gameLost) { // Added condition to avoid placing blocks when the game is lost
        placeBlock();
    }
}

function touchStarted() {
  placeBlock();
  return false; // To prevent any default action for this touch event
}

function placeBlock() {
    if (blocksAvailable > 0) {
        let block = Bodies.rectangle(mouseX, mouseY, 40, 10, { isStatic: true });
        World.add(world, block);
        blocks.push(block);
        blocksAvailable--;
    }
}

function initializeLevel(level) {
    clear();
		ballsToPut = level;  // +1 ball for each level
    blocksAvailable = 101 - level;  // Blocks decrease by 1 each level
}


function levelUp() {
    level++;  // Increase the level by 1
    currentLevel = level; // Update the current level. This is used in displaying the level text.

    score = 0;
    availableBalls = 200;
    gameWon = false;

    // Update ballsToPut and blocksAvailable based on the new level
    initializeLevel(level);
    
    // Remove all the lemmings from the world and empty the lemmings array
    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];
    
    // Remove all blocks from the world and empty the blocks array
    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];
    
    // Move the door that releases the balls to a new position
   startPoint = { x: random(20, 1400 - 20), y: 120 }; // Adjusted for new canvas size
    
    // Move the cup to a new position
    let goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);
    Matter.Body.setPosition(goalBody, { x: goalPosX, y: goalBody.position.y });
    Matter.Body.setPosition(goalLipLeft, { x: goalPosX - goalWidth/2, y: goalLipLeft.position.y });
    Matter.Body.setPosition(goalLipRight, { x: goalPosX + goalWidth/2, y: goalLipRight.position.y });

    loop();  // Restart the draw loop.
}



function windowResized() {
    resizeCanvas(1400, 800);
}

function restartGame() {
    clear();
		gameLost = false;
    gameWon = false;
    level = 1;
    score = 0;
    availableBalls = 200;
    blocksAvailable = 100;
    initializeLevel(level);

    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];

    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];

    startPoint.x = random(20, width - 20);
    let goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);
    Matter.Body.setPosition(goalBody, { x: goalPosX, y: goalBody.position.y });
    Matter.Body.setPosition(goalLipLeft, { x: goalPosX - goalWidth/2, y: goalLipLeft.position.y });
    Matter.Body.setPosition(goalLipRight, { x: goalPosX + goalWidth/2, y: goalLipRight.position.y });

    loop();
}

function keyPressed() {
    if (gameWon) {
        levelUp();
    }
    if (gameLost) {
        restartGame();
    }
}
"
"2085389","Mister DJ","mySketch","let mic, fft, amplitude;
let particles = [];

function setup() {
  createCanvas(710, 400);

  mic = new p5.AudioIn();
  mic.start();

  fft = new p5.FFT();
  fft.setInput(mic);

  amplitude = new p5.Amplitude();
  amplitude.setInput(mic);

  for (let i = 0; i < 100; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  background(200);
  let level = amplitude.getLevel();
  let spectrum = fft.analyze();

  for (let particle of particles) {
    particle.update(level);
    particle.show();
  }

  visualizeFrequency(spectrum);
}

function visualizeFrequency(spectrum) {
  noStroke();
  fill(255, 0, 0);
  for (let i = 0; i < spectrum.length; i++) {
    let x = map(i, 0, spectrum.length, 0, width);
    let h = -height + map(spectrum[i], 0, 255, height, 0);
    rect(x, height, width / spectrum.length, h);
  }
}

class Particle {
  constructor() {
    this.position = createVector(random(width), random(height));
    this.velocity = createVector(random(-1, 1), random(-1, 1));
    this.size = random(5, 20);
  }

  update(level) {
    this.position.add(this.velocity);
    this.size = map(level, 0, 1, 5, 50);

    // Boundary conditions
    if (this.position.x > width || this.position.x < 0) {
      this.velocity.x *= -1;
    }
    if (this.position.y > height || this.position.y < 0) {
      this.velocity.y *= -1;
    }
  }

  show() {
    noStroke();
    fill(255);
    ellipse(this.position.x, this.position.y, this.size, this.size);
  }
}
"
"2054539","Counter","index.html","<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>Counters</title>
    <link href=""https://fonts.googleapis.com/css2?family=Lato:wght@400&display=swap"" rel=""stylesheet"">
    <style>
        html, body {
            font-family: 'Lato', sans-serif;
            font-size: 3vw;  /* Use viewport width for responsive font size */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            margin: 0;
            overflow: hidden;
            height: 100%;
        }

        .counter-container {
            display: flex;
            flex-direction: column;
            gap: 1.5vw; /* Adjusted for responsive spacing */
            padding: 2vw;
        }

        .counter {
            text-align: center;
        }

        .counter-label {
            display: block;
            text-transform: none;
            margin-bottom: 0.5vw;
        }

        .bold-num {
            font-weight: bold;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 600px) {
            html, body {
                font-size: 5vw; /* Increase font size for smaller screens */
            }

            .counter-container {
                gap: 1vw;
                padding: 1vw;
            }
        }
    </style>
</head>
<body>

<div class=""counter-container"">
    <div style=""text-align: center;"">Our portfolio boasts an aggregated:</div>
    <div class=""counter"">
        <span class=""counter-label""><span class=""bold-num"" id=""projectsCounter"">0</span> startups</span>
    </div>
    <div class=""counter"">
        <span class=""counter-label""><span class=""bold-num"" id=""investmentCounter"">0</span>-digit investment</span>
    </div>
    <div class=""counter"">
        <span class=""counter-label""><span class=""bold-num"" id=""turnoverCounter"">0</span>-digit turnover</span>
    </div>
    <div class=""counter"">
        <span class=""counter-label""><span class=""bold-num"" id=""valuationCounter"">0</span>-digit valuation</span>
    </div>
    <div class=""counter"">
        <span class=""counter-label"">+<span class=""bold-num"" id=""inventorsCounter"">0</span> full-time talented inventors, entrepreneurs and builders from all over the world</span>
    </div>
</div>

<script>
    function createCounter(startValue, endValue, duration, elementId) {
        const increment = endValue / (duration / 100);  // Slowed down the counters

        function updateCounter() {
            startValue += increment;
            if (startValue <= endValue) {
                document.getElementById(elementId).textContent = Math.round(startValue);
                setTimeout(updateCounter, 100); // Slowed down the counters
            } else {
                document.getElementById(elementId).textContent = endValue;
            }
        }

        updateCounter();
    }

    window.onload = function() {
        createCounter(0, 6, 5000, 'projectsCounter');  // Increased duration to slow down the counters
        createCounter(0, 7, 5000, 'investmentCounter');
        createCounter(0, 7, 5000, 'turnoverCounter');
        createCounter(0, 8, 5000, 'valuationCounter');
        createCounter(0, 30, 5000, 'inventorsCounter');
    };
</script>

</body>
</html>
"
"2003997","Real-time Face Emoji Mimic","mySketch","let video;
let faceapi;
let detections = [];

function setup() {
  createCanvas(400, 400);
  video = createCapture(VIDEO);
  video.size(width, height);
  video.hide();
  faceapi = ml5.faceApi(video, modelReady);
}

function modelReady() {
  faceapi.detect(gotResults);
}

function gotResults(err, result) {
  if (err) {
    console.log(err);
    return;
  }
  detections = result;
  faceapi.detect(gotResults);
}

function draw() {
  image(video, 0, 0, width, height);
  if (detections.length > 0) {
    let points = detections[0].landmarks.positions;
    // Use points to determine facial expression and draw corresponding emoji
    // This is a simplified example, in reality, you'd need more logic to determine the expression
    if (points[20].y < points[21].y) {
      text(""😊"", width / 2, height / 2);
    } else {
      text(""😐"", width / 2, height / 2);
    }
  }
}
"
"2003993","Quantum Tunneling","mySketch","let barrier;
let particles = [];

function setup() {
  createCanvas(800, 400);
  barrier = new Barrier(width / 2, height / 2, 20, 100);
}

function draw() {
  background(220);

  barrier.show();

  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].show();

    if (particles[i].x > width) {
      particles.splice(i, 1);
    }
  }

  if (random() < 0.05) {
    particles.push(new Particle(50, height / 2));
  }
}

class Barrier {
  constructor(x, y, w, h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }

  show() {
    fill(255, 0, 0);
    rect(this.x, this.y - this.h / 2, this.w, this.h);
  }
}

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.speed = 2;
    this.tunneled = false;
  }

  update() {
    if (this.x > barrier.x && this.x < barrier.x + barrier.w && !this.tunneled) {
      if (random() < 0.01) { // 1% chance to tunnel
        this.y = barrier.y + barrier.h / 2 + 10;
        this.tunneled = true;
      }
    }
    this.x += this.speed;
  }

  show() {
    fill(0, 0, 255);
    ellipse(this.x, this.y, 10);
  }
}
"
"2003991","Chaotic Pendulum","mySketch","let pendulum;

function setup() {
  createCanvas(600, 600);
  pendulum = new DoublePendulum(width / 2, height / 4);
}

function draw() {
  background(220);
  pendulum.update();
  pendulum.show();
}

class DoublePendulum {
  constructor(x, y) {
    this.origin = createVector(x, y);
    this.r1 = 125;
    this.r2 = 75;
    this.angle1 = PI / 4;
    this.angle2 = PI / 4;
    this.aVel1 = 0;
    this.aVel2 = 0;
    this.aAcc1 = 0;
    this.aAcc2 = 0;
    this.g = 0.4;
  }

  update() {
    let num1 = -this.g * (2 * sin(this.angle1) + sin(this.angle2));
    let num2 = -sin(this.angle1 - this.angle2);
    let num3 = this.aVel2 * this.aVel2 * this.r2 + this.aVel1 * this.aVel1 * this.r1 * cos(this.angle1 - this.angle2);
    let den = this.r1 * (2 - cos(this.angle1 - this.angle2));
    this.aAcc1 = (num1 + num2 * num3) / den;

    num1 = 2 * sin(this.angle1 - this.angle2);
    num2 = this.aVel1 * this.aVel1 * this.r1 + this.g * cos(this.angle1);
    num3 = this.aVel2 * this.aVel2 * this.r2 * cos(this.angle1 - this.angle2);
    den = this.r2 * (2 - cos(this.angle1 - this.angle2));
    this.aAcc2 = (num1 * (num2 + num3)) / den;

    this.angle1 += this.aVel1;
    this.angle2 += this.aVel2;

    this.aVel1 += this.aAcc1;
    this.aVel2 += this.aAcc2;

    this.aVel1 *= 0.99;
    this.aVel2 *= 0.99;
  }

  show() {
    let x1 = this.origin.x + this.r1 * sin(this.angle1);
    let y1 = this.origin.y + this.r1 * cos(this.angle1);

    let x2 = x1 + this.r2 * sin(this.angle2);
    let y2 = y1 + this.r2 * cos(this.angle2);

    fill(127);
    stroke(0);
    strokeWeight(2);
    line(this.origin.x, this.origin.y, x1, y1);
    ellipse(x1, y1, 16, 16);

    line(x1, y1, x2, y2);
    ellipse(x2, y2, 16, 16);
  }
}
"
"2003089","Vector Fields and Flow","mySketch","let cols, rows;
let resolution = 20;
let vectors = [];
let particles = [];
let particleCount = 100;

function setup() {
  createCanvas(600, 400);
  cols = floor(width / resolution);
  rows = floor(height / resolution);
  initializeVectors();
  for (let i = 0; i < particleCount; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  background(220);
  displayVectors();
  for (let p of particles) {
    p.follow(vectors);
    p.update();
    p.display();
  }
}

function mousePressed() {
  particles.push(new Particle(createVector(mouseX, mouseY)));
}

function initializeVectors() {
  for (let x = 0; x < cols; x++) {
    vectors[x] = [];
    for (let y = 0; y < rows; y++) {
      let v = p5.Vector.fromAngle(random(TWO_PI));
      vectors[x][y] = v;
    }
  }
}

function displayVectors() {
  for (let x = 0; x < vectors.length; x++) {
    for (let y = 0; y < vectors[x].length; y++) {
      push();
      let posX = x * resolution;
      let posY = y * resolution;
      translate(posX, posY);
      let hueValue = map(vectors[x][y].heading(), 0, TWO_PI, 0, 360);
      stroke(hueValue, 100, 100);
      rotate(vectors[x][y].heading());
      let len = vectors[x][y].mag() * resolution;
      line(0, 0, len, 0);
      pop();
    }
  }
}

class Particle {
  constructor(position = createVector(random(width), random(height))) {
    this.pos = position;
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
  }

  follow(vectors) {
    let x = floor(this.pos.x / resolution);
    let y = floor(this.pos.y / resolution);
    let force = vectors[x][y];
    this.acc.add(force);
  }

  update() {
    this.vel.add(this.acc);
    this.vel.limit(4);
    this.pos.add(this.vel);
    this.acc.mult(0);
    this.edges();
  }

  edges() {
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }

  display() {
    noStroke();
    fill(0, 5);
    ellipse(this.pos.x, this.pos.y, 4);
  }
}
"
"2003088","Möbius Transformations and Inversion","mySketch","let gridSize = 10;
let spacing;
let points = [];

let a_real, a_imag, b_real, b_imag, c_real, c_imag, d_real, d_imag;

function setup() {
  createCanvas(400, 400);
  spacing = width / gridSize;

  // Create sliders
  a_real = createSlider(-2, 2, 1, 0.1);
  a_imag = createSlider(-2, 2, 0, 0.1);
  b_real = createSlider(-2, 2, 0, 0.1);
  b_imag = createSlider(-2, 2, 0, 0.1);
  c_real = createSlider(-2, 2, 0, 0.1);
  c_imag = createSlider(-2, 2, 0, 0.1);
  d_real = createSlider(-2, 2, 1, 0.1);
  d_imag = createSlider(-2, 2, 0, 0.1);

  // Arrange sliders
  let yOff = height + 20;
  let gap = 20;
  arrangeSlider(a_real, ""a_real"", 0, yOff);
  arrangeSlider(a_imag, ""a_imag"", 1, yOff);
  arrangeSlider(b_real, ""b_real"", 2, yOff);
  arrangeSlider(b_imag, ""b_imag"", 3, yOff);
  arrangeSlider(c_real, ""c_real"", 4, yOff);
  arrangeSlider(c_imag, ""c_imag"", 5, yOff);
  arrangeSlider(d_real, ""d_real"", 6, yOff);
  arrangeSlider(d_imag, ""d_imag"", 7, yOff);
}

function draw() {
  background(220);

  stroke(0);
  strokeWeight(2);

  // Draw original points grid
  for (let x = 0; x < width; x += spacing) {
    for (let y = 0; y < height; y += spacing) {
      point(x, y);
      let z = complex(x / width * 4 - 2, y / height * 4 - 2); // Convert pixel coordinates to complex plane
      let w = mobiusTransform(z);
      let px = map(w.re, -2, 2, 0, width);
      let py = map(w.im, -2, 2, 0, height);
      stroke(lerpColor(color(255, 0, 0), color(0, 0, 255), (x+y) / (width+height)));
      point(px, py);
    }
  }
}

function complex(re, im) {
  return { re: re, im: im };
}

function complexMult(a, b) {
  return {
    re: a.re * b.re - a.im * b.im,
    im: a.re * b.im + a.im * b.re
  };
}

function complexAdd(a, b) {
  return {
    re: a.re + b.re,
    im: a.im + b.im
  };
}

function complexDiv(a, b) {
  let denom = b.re * b.re + b.im * b.im;
  return {
    re: (a.re * b.re + a.im * b.im) / denom,
    im: (a.im * b.re - a.re * b.im) / denom
  };
}

function mobiusTransform(z) {
  let a = complex(a_real.value(), a_imag.value());
  let b = complex(b_real.value(), b_imag.value());
  let c = complex(c_real.value(), c_imag.value());
  let d = complex(d_real.value(), d_imag.value());

  let numerator = complexAdd(complexMult(a, z), b);
  let denominator = complexAdd(complexMult(c, z), d);

  return complexDiv(numerator, denominator);
}

function arrangeSlider(slider, label, index, startY) {
  let gap = 25;
  slider.position(10, startY + index * gap);
  createDiv(label).position(slider.x * 2 + slider.width, slider.y);
}

"
"2003085","Sinusoidal Functions","mySketch","let angle = 0;
let speed = 0.05;
let circleRadius = 100;
let waveLength = 200;

function setup() {
  createCanvas(600, 400);
  createP(""Adjust Speed:"");
  let speedSlider = createSlider(0, 0.2, 0.05, 0.01);
  speedSlider.input(() => {
    speed = speedSlider.value();
  });
}

function draw() {
  background(220);

  // Draw the circle for unit circle representation
  translate(width / 4, height / 2);
  stroke(50);
  noFill();
  ellipse(0, 0, circleRadius * 2);

  // Calculate x, y for the rotating line
  let x = circleRadius * cos(angle);
  let y = circleRadius * sin(angle);

  // Draw rotating line
  strokeWeight(2);
  line(0, 0, x, y);

  // Draw horizontal cosine line
  stroke(255, 0, 0); // Red for cosine
  line(x, 0, x, y);

  // Draw vertical sine line
  stroke(0, 0, 255); // Blue for sine
  line(0, y, x, y);

  // Draw sine wave
  stroke(0, 0, 255); // Blue for sine
  for (let i = 0; i < waveLength; i++) {
    let sinVal = sin(angle + (speed * i));
    point(circleRadius + 50 + i, sinVal * circleRadius);
  }

  // Draw cosine wave
  stroke(255, 0, 0); // Red for cosine
  for (let i = 0; i < waveLength; i++) {
    let cosVal = cos(angle + (speed * i));
    point(circleRadius + 50 + i, cosVal * circleRadius);
  }

  angle += speed;
}
"
"2003084","Golden Ratio and Fibonacci","mySketch","let fibs = [1, 1];
let maxFibs = 10;

function setup() {
  createCanvas(400, 400);
  background(220);
  noLoop();
  noFill();
}

function draw() {
  background(220);

  // Calculate Fibonacci sequence
  while (fibs.length < maxFibs) {
    let nextFib = fibs[fibs.length - 1] + fibs[fibs.length - 2];
    fibs.push(nextFib);
  }

  let x = 0;
  let y = height;
  let w = fibs[fibs.length - 1];
  let h = fibs[fibs.length - 1];

  for (let i = fibs.length - 1; i >= 0; i--) {
    let prevX = x;
    let prevY = y;

    stroke(50);
    strokeWeight(2);
    rect(x, y - h, w, h);

    fill(255, 100, 150, 150);
    beginShape();
    for (let angle = 0; angle < TWO_PI; angle += 0.01) {
      let xOffset = cos(angle) * fibs[i];
      let yOffset = sin(angle) * fibs[i];
      vertex(prevX + xOffset, prevY - yOffset);
    }
    endShape();

    switch (i % 4) {
      case 0:
        y -= h;
        break;
      case 1:
        x += w;
        break;
      case 2:
        x -= fibs[i];
        w = fibs[i];
        break;
      case 3:
        y += fibs[i];
        h = fibs[i];
        x += fibs[i - 1];
        w = fibs[i];
        break;
    }
  }
}

function mousePressed() {
  if (maxFibs < 15) {
    maxFibs++;
    fibs = [1, 1];
  } else {
    maxFibs = 2;
  }
  redraw();
}
"
"2003083","Pythagoras Theorem","mySketch","let a = 150;
let b = 100;
let c;

function setup() {
  createCanvas(400, 400);
  c = sqrt(a*a + b*b);
}

function draw() {
  background(220);

  let movablePointX = constrain(mouseX, 0, width);
  let movablePointY = constrain(mouseY, 0, height);
  
  a = movablePointX;
  b = height - movablePointY;
  c = sqrt(a*a + b*b);

  fill(100, 100, 255, 150);
  rect(0, height, a, -b); // Draw the rectangle representing 'a' and 'b'

  stroke(255, 0, 0);
  line(0, height, movablePointX, movablePointY); // Hypotenuse

  fill(0);
  text(`a: ${round(a)}`, a / 2 - 20, height - 10);
  text(`b: ${round(b)}`, a + 10, height - (b / 2));
  text(`c: ${round(c)}`, a / 2 - 30, height - (b / 2));

  text('Drag the red point to change the values of a and b', 10, 10);
  ellipse(movablePointX, movablePointY, 8); // Movable point
}

function mouseDragged() {
  redraw();
}
"
"1998126","Mesmerizing effect","mySketch","let particles = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
  for (let i = 0; i < 100; i++) {
    particles.push(new Particle());
  }
}

function draw() {
  background(0, 25); // Slight transparency for a trail effect
  
  for (let particle of particles) {
    particle.attracted(createVector(mouseX, mouseY));
    particle.update();
    particle.show();
  }
}

class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.prev = this.pos.copy();
    this.vel = createVector();
    this.acc = createVector();
  }
  
  attracted(target) {
    let force = p5.Vector.sub(target, this.pos);
    let dsquared = force.magSq();
    dsquared = constrain(dsquared, 25, 500); 
    let strength = 6 / dsquared;
    force.setMag(strength);
    this.acc = force;
  }
  
  update() {
    this.vel.add(this.acc);
    this.vel.limit(5); // Limit speed
    this.pos.add(this.vel);
  }
  
  show() {
    stroke(255, 150);
    strokeWeight(4);
    line(this.pos.x, this.pos.y, this.prev.x, this.prev.y);
    this.prev = this.pos.copy();
  }
}
"
"1996504","Algorithm G website","mySketch.js","let frameCounter = 0;
let particles = [];
let numParticles = 40;  // default for desktop
let yOffset = 0;  // To keep track of the parallax effect
const targetText = ""ALGORITHM G"";
const targetElement = document.querySelector('.typing');
let index = 0;
let formulas = [
    ""Ψ(t) = ĤΨ(t)"",  // Schrödinger Equation (simplified representation)
    ""ρ(∂v/∂t + v·∇v) = -∇p + μ∇²v"",  // Navier-Stokes (simplified representation)
    ""Gμν = 8πGTμν/c⁴"",  // Einstein Field Equations (simplified representation)
    ""L = T - V"",  // Lagrangian in Classical Mechanics
    ""F(k) = ∫f(x)e⁻²πikx dx"",  // Fourier Transform (simplified representation)
    ""∮E·dA = Q_enc/ε₀"",  // Maxwell's Equations (one of them, simplified representation)
    ""S = k ln(W)"",  // Boltzmann's Entropy Formula
    ""sin²(θ) + cos²(θ) = 1"",  // Pythagorean Trigonometric Identity
    ""ROI = (Net Profit / Cost) x 100"",  // Return on Investment
    ""SWOT = S + W + O + T"",  // SWOT Analysis
    ""CAGR = (EV/BV)^(1/n) - 1"",  // Compound Annual Growth Rate
    ""P = R - C"",  // Profit = Revenue - Costs
    ""MVP = Viable( Minimum( Product ) )"",  // Minimum Viable Product
    ""5P = Product + Price + Place + Promotion + People"",  // Marketing Mix
    ""BCG = Stars + ? + Cash Cows + Dogs"",  // BCG Matrix
    ""USP = Unique( Selling Proposition )"",  // Unique Selling Proposition
    ""Design = Function + Aesthetics"",  // Design Principles
    ""Tech = Tool + Innovation"",  // Simplified representation of Technology
    ""Strategy = Vision + Execution"",  // Strategic Formulation
    ""Data = Information + Context"",  // Data Interpretation
    ""Value = Quality / Price"",  // Value Proposition
    ""Change = ΔKnowledge + ΔBehavior + ΔResults""  // Change Management
];

if (window.innerWidth <= 768) {  // Assuming 768px is the breakpoint for mobile
    numParticles = 40;  // You can adjust this number as required
}

function typeText() {
    if (index < targetText.length) {
        targetElement.textContent += targetText[index];
        index++;
        setTimeout(typeText, 150);  // Adjust speed as needed
    } else {
        // Stop the blinking cursor after typing completes
        targetElement.classList.remove('typing');
    }
}

typeText();

function setup() {
    createCanvas(windowWidth, windowHeight);
    for (let i = 0; i < numParticles; i++) {
        particles.push(new Particle());
    }
}
function windowResized() {
    let docHeight = document.body.scrollHeight;
    resizeCanvas(windowWidth, docHeight);
    yOffset = window.scrollY * 0.3;  // 0.5 for a subtle effect
}

window.addEventListener('scroll', function() {
    yOffset = window.scrollY * 0.3;  // Adjust based on scroll
});

function draw() {
    background(255);  // This should be white or a very light gray.
    for (let particle of particles) {
        particle.attract(mouseX, mouseY);
        particle.update();
        particle.show();
        particle.connect(particles);
    }
}

class Particle {
    constructor() {
        this.pos = createVector(random(width), random(height));
        this.vel = createVector();
        this.acc = createVector();
        this.formula = random(formulas);  // Assign a random formula from the list
    }

    update() {
        this.vel.add(this.acc);
        this.pos.add(this.vel);
        this.acc.set(0, 0);
    }

    show() {
        fill('#cccccc');
        ellipse(this.pos.x, this.pos.y, 4);
        textSize(12);  // Adjust size as needed
        textStyle(ITALIC);
        text(this.formula, this.pos.x + 10, this.pos.y);  // Display formula next to the particle
    }

    connect(particles) {
        for (let particle of particles) {
            let d = dist(this.pos.x, this.pos.y, particle.pos.x, particle.pos.y);
            if (d < 100) {
                stroke('rgba(127, 127, 127, 0.5)');
                line(this.pos.x, this.pos.y, particle.pos.x, particle.pos.y);
            }
        }
    }

    attract(x, y) {
        let mouse = createVector(x, y);
        let dir = p5.Vector.sub(mouse, this.pos);
        let d = dir.mag();
        dir.normalize();
        if (d < 100) {
            dir.mult(0.5);  // Adjust this for stronger/weaker attraction
            this.acc.add(dir);
        }
    }
}

windowResized();


document.addEventListener('DOMContentLoaded', function() {
    const targetText = ""ALGORITHM G"";
    const targetElement = document.querySelector('.typing');
    let index = 0;

    function typeText() {
        if (index < targetText.length) {
            targetElement.textContent += targetText[index];
            index++;
            setTimeout(typeText, 150);  // Adjust speed as needed
        } else {
            // Stop the blinking cursor after typing completes
            targetElement.classList.remove('typing');
        }
    }

    typeText();
});"
"1996504","Algorithm G website","style.css","/* styles.css */

@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@800&display=swap'); /* Extra bold weight */

body {
    font-family: 'Poppins', sans-serif;  
	  margin: 0;
    overflow-x: hidden;
    background-color: #f5f5f5;
   	text-align: center;
	    color: #333;  /* a slightly softer black */

}

canvas {
    position: fixed;
    top: 0;
    left: 0;
    z-index: -1;
	    opacity: 0.5;  /* Adjust as needed to ensure text readability */
}


.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 50px 20px;
}

hr {
    width: 180%;  /* or any desired width */
    border: 0;
    border-top: 1px solid #666;  /* adjust color as needed */
    margin: 40px auto;  /* adjust as needed */
}

@media (max-width: 768px) {  /* for smaller screens */
    .container {
        padding: 25px 10px;
    }
}

.main-title {
    font-size: calc(4rem + 3vw); /* Adjust as needed */
    text-transform: uppercase;
    color: #333; /* Deep shade of gray */
    padding-top: 50px; /* Adds space above the title */
    text-shadow: 3px 3px 3px rgba(0, 0, 0, 0.2); /* Initial shadow */
    transition: text-shadow 0.5s; /* Smooth transition */
    font-weight: 800;
    white-space: nowrap;
    overflow: visible;
    width: 100%;
    padding-right: 0;
    letter-spacing: normal; /* Adjust as needed */
    text-align: center; /* Ensure title is centered */
}

/* Adjusting for medium-sized screens */
@media (max-width: 768px) {
    .main-title {
        font-size: calc(2rem + 2vw); /* Adjust for mobile */
    }
}

/* Adjusting for smaller screens */
@media (max-width: 480px) {
    .main-title {
        font-size: calc(1.5rem + 1.5vw); /* Adjust as per your design */
    }
}



.section-title {
    font-size: calc(2rem + 1.5vw);  /* adjust as needed */
    font-weight: 600;  /* making titles a bit bolder */
    margin-top: 40px;
    margin-bottom: 20px;
    -webkit-background-clip: text;
	    color: #4d4d4d;
    background: none;  /* Remove the existing gradient background */
}

.main-title:hover {
    transform: scale(1.2); /* Slightly enlarge the text on hover */
}


.section {
      padding: 20px 0;
    background-color: #f9f9f9;  /* adjust as needed */  
	border: 1px solid #eee;  /* adjust as needed */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);  /* adjust as needed */
    padding: 20px 0;
    margin: 20px 0;
}

@media (max-width: 768px) {
    .main-title {
        font-size: calc(3rem + 2vw); /* Adjust for mobile */
    }
}

@keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0; }
    100% { opacity: 1; }
}

.typing::after {
    content: '|';  /* Cursor */
    animation: blink 1s infinite;
}


a {
    color: inherit;  /* adopts the parent's text color */
    text-decoration: none;  /* removes the underline */
    transition: color 0.3s;  /* smooth color transition for hover effect */
}

a:hover {
    color: #0077cc;  /* changes color when hovered; adjust color as desired */
}

a.highlight {
    background-color: #FFEBB7; /* always highlight with yellow background */
    padding: 2px 4px; /* optional: add a little padding for better appearance */
}

html {
    scroll-behavior: smooth;
}


.description {
    font-size: 2rem; /* adjust as needed */
    margin-bottom: 20px;
}

.list-item:hover {
    transform: scale(1.05);  /* slightly enlarge */
    transition: transform 0.3s;  /* smooth transition */
}

canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    overflow: hidden;  // Just to ensure no overflow
}


.list {
    margin-top: 20px;
    list-style-type: none;
    padding-left: 0;
}

.list-item {
    font-size: 2rem;
    margin-bottom: 20px;
	    color: #333;  /* a slightly softer black */
}

.footer {
    text-align: center;
    margin-top: 50px;
    font-size: 0.9rem;
}
"
"1996504","Algorithm G website","index.html","<!DOCTYPE html>
<html lang=""en"">

<script src=""https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js""></script>
	
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
	    <title>ALGORITHM G</title>
    <link rel=""stylesheet"" href=""style.css"">
  	<link href=""https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"" rel=""stylesheet"">

</head>

<body>
    <div class=""main-title typing""></div>
    <div class=""section-title"">Algorithm G is a strategic and creative advisor boutique,<br>growth hacking brands to be<br>future smart and deep tech ready</div>
  

			<hr>
			
        <div class=""section-title"">Key Capabilities</div>
        <ul class=""list"">
            <li class=""list-item"">Generative AI</li>
            <li class=""list-item"">Web3</li>
            <li class=""list-item"">Digital Growth</li>
            <li class=""list-item"">Venture Building</li>
        </ul>

			<hr>
			
        <div class=""section-title"">Primary Industries</div>
        <ul class=""list"">
            <li class=""list-item"">Fintech</li>
            <li class=""list-item"">Retail</li>
            <li class=""list-item"">Tech, Media & Telcos</li>
        </ul>
<hr>
        <div class=""section-title"">Advisory Services for Corporations</div>
        <div class=""description"">Algorithm G offers advisory and consultancy services to big corporations, including members of several major European Stock Exchanges</div>
<hr>
        <div class=""section-title"">Accelerator Products for Corporations</div>
        <ul class=""list"">
            <li class=""list-item"">
                <strong>GAIA© - Generative AI Accelerator</strong><br>
                Empower corporations with creative AI solutions (GPT, Midjourney, X to X,…), unlocking innovation and driving performance and growth
            </li>
            <li class=""list-item"">
                <br><strong>GOWA© - Genesis Optimization and Web3 Accelerator</strong><br>
                Propel corporations into the Web3 era, harnessing decentralised technologies (metaverse, NFT,…) for a competitive edge
            </li>
            <li class=""list-item"">
                <br><strong>GEPA© - Growth, Engagement and Performance Accelerator</strong><br>
                Accelerate corporations growth with performance marketing, engaging with a new audience
            </li>
        </ul>
<hr>
        <div class=""section-title"">Advisory Services for Startups</div>
        <ul class=""list"">
			
					<li class=""list-item"">		Algorithm G and its leadership offer advisory services to startups with prominent, disruptive and scalable ideas and technologies, taking part in the equity of:</li>
            <li class=""list-item""><strong>GG dApp</strong> - decentralised web3 gaming platform and launchpad</li>
					  <li class=""list-item""><strong>Hypernest</strong> - accelerator DAO to support web3 founders</li>
            <li class=""list-item""><strong>Intuitivo</strong> - collaborative EdTech platform</li>
            <li class=""list-item""><strong>Lympid</strong> - easiest access to DeFi</li>
            <li class=""list-item""><strong>Maison Pixel</strong> - pixelated-looking underwear </li>
            <li class=""list-item""><strong>TalentLayer</strong> - building better labor marketplaces</li>
        </ul>

        <div class=""description"">
            <br>
					  <strong>This portfolio represents an aggregated:</strong> <br><br>
            7-digit investment<br>
            7-digit turnover<br>
            8-digit valuation<br>
            +30 full-time talented inventors, entrepreneurs and builders from all over the world
        </div>
<hr>
        <div class=""section-title"">Leadership</div>
        <div class=""description"">Algorithm G ecosystem is managed by <a href=""https://www.linktr.ee/gperdigao"" target=""_blank"" rel=""noopener noreferrer"" class=""highlight"">Gonçalo Perdigão</a>
, <br>who engages with a pool of consultants, entrepreneurs and partners</div>

        <div class=""footer"">Designed and Developed by Algorithm G Lda © , 2023</div>
    </div>
<script src=""mySketch.js""></script>

</body>

</html>"
"1995854","Lemmings","mySketch","let currentLevel = 1;
let gameLost = false;

let availableBalls = 200;
let totalBalls = 200;
let ballsToPut;
let blocksAvailable = 100;
let Engine = Matter.Engine,
    World = Matter.World,
    Bodies = Matter.Bodies,
    Events = Matter.Events;
let gameWon = false;
let engine;
let world;
let lemmings = [];
let blocks = [];
let goalBody, goalLipLeft, goalLipRight;
let startPoint;
let score = 0;
let level = 1;

function isMobileDevice() {
    return windowWidth <= 800;
}

function setup() {
    createCanvas(windowWidth, windowHeight);
    initializeLevel(currentLevel);

	if (isMobileDevice) {
    goalWidth = width * 0.08;
    goalHeight = height * 0.15;
    goalLipThickness = goalWidth * 0.3;
}
else {
    goalWidth = width * 0.05;
    goalHeight = height * 0.1;
    goalLipThickness = goalWidth * 0.25;
}

    engine = Engine.create();
    world = engine.world;

  let topWall = Bodies.rectangle(width / 2, -10, width, 20, { isStatic: true });
  let bottomWall = Bodies.rectangle(width / 2, height + 10, width, 20, { isStatic: true });
  let leftWall = Bodies.rectangle(-10, height / 2, 20, height, { isStatic: true });
  let rightWall = Bodies.rectangle(width + 10, height / 2, 20, height, { isStatic: true });
  World.add(world, [topWall, bottomWall, leftWall, rightWall]);

  startTime = millis();
startPoint = { x: random(20, width - 20), y: 120 };  // Moves it down below the top bar

  goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);

  // The main ""cup"" body
  goalBody = Bodies.rectangle(goalPosX, height - 10, goalWidth, goalHeight - goalLipThickness, { 
    isStatic: true,
    label: 'goal'
  });

  // Left lip of the cup
  goalLipLeft = Bodies.rectangle(goalPosX - goalWidth/2, height - 10 - (goalHeight - goalLipThickness) / 2, goalLipThickness, goalHeight - goalLipThickness, { 
    isStatic: true,
    label: 'block'
  });

  // Right lip of the cup
  goalLipRight = Bodies.rectangle(goalPosX + goalWidth/2, height - 10 - (goalHeight - goalLipThickness) / 2, goalLipThickness, goalHeight - goalLipThickness, { 
    isStatic: true,
    label: 'block'
  });

  World.add(world, [goalBody, goalLipLeft, goalLipRight]);

Events.on(engine, 'collisionStart', (function(event) {
  let pairs = event.pairs;
  for (let i = 0; i < pairs.length; i++) {
    if ((pairs[i].bodyA === bottomWall && pairs[i].bodyB.label !== 'block') || 
        (pairs[i].bodyB === bottomWall && pairs[i].bodyA.label !== 'block')) {
      availableBalls--
    }
    if (pairs[i].bodyA.label === 'goal' && pairs[i].bodyB.label !== 'block') {
      score++;
      World.remove(world, pairs[i].bodyB);
    } else if (pairs[i].bodyB.label === 'goal' && pairs[i].bodyA.label !== 'block') {
      score++;
      World.remove(world, pairs[i].bodyA);
    }
  }
}).bind(this));


}

function areLemmingsStill() {
    for (let lemming of lemmings) {
        if (lemming.speed > 0.3) { 
            return false; // A lemming is still moving
        }
    }
    return true; // No lemmings are moving
}


function draw() {
  background(220);

	if (availableBalls === 0 && areLemmingsStill()) {
    gameWon = false;
    gameLost = true;
    noLoop();
}

	
if (ballsToPut == score) {
   gameWon = true;
   noLoop(); // Stop the draw loop
}

	if (gameWon) {
  textSize(32);
  text('You won level ' + level + ', press any key to level up', width / 2 - 200, height / 2);
  noLoop(); // Stop the draw loop.
} 

	if (gameLost) {
    textSize(32);
    text('Game over, press any key to restart', width / 2 - 250, height / 2);
    noLoop();
}

    Engine.update(engine);
	
// Top bar display
//fill(235, 235, 235);  // Light gray background
//rect(0, 0, windowWidth, 50);  // Top bar area

fill(0);  // Black text color
textSize(20);  // Increase the text size for better readability

// Adjusting the y-coordinate to 35 centers the text vertically within the rectangle.
text(""Level: "" + currentLevel, 10, 35);
text(""Target Balls: "" + ballsToPut, 250, 35);
text(""Balls Left: "" + availableBalls, 650, 35);
text(""Balls In: "" + score, 850, 35);
text(""Blocks Left: "" + blocksAvailable, 1150, 35);


  


if (frameCount % 30 == 0 && availableBalls > 0) {
   let lemming = Bodies.circle(startPoint.x, startPoint.y, 7.5, {
     friction: 0.001 
   });
   World.add(world, lemming);
   lemmings.push(lemming);
   availableBalls--;
}

    let lemmingSize;
    if (isMobileDevice()) {
        lemmingSize = width * 0.03;   // 3% of screen width for mobile
    } else {
        lemmingSize = 15;             // fixed size for desktop
    }

    // Display lemmings with adjusted size
    fill(0, 255, 0);
    for (let i = lemmings.length - 1; i >= 0; i--) {
        let lemming = lemmings[i];
        ellipse(lemming.position.x, lemming.position.y, lemmingSize);
    }
	
if (score < 100) {
  timeToReach100 = (millis() - startTime) / 1000; // Keep updating until 100 balls
}
	
  // Display entry point
  fill(100, 100, 255);
  ellipse(startPoint.x, startPoint.y, 40, 40);

  // Display tunnel (goal)
  fill(255, 50, 50);
  rectMode(CENTER);
  rect(goalBody.position.x, goalBody.position.y, goalWidth, goalHeight - goalLipThickness);
  
  // Display the lips of the cup
  fill(50, 50, 250);
  rect(goalLipLeft.position.x, goalLipLeft.position.y, goalLipThickness, goalHeight - goalLipThickness);
  rect(goalLipRight.position.x, goalLipRight.position.y, goalLipThickness, goalHeight - goalLipThickness);

  // Display blocks
  fill(50, 50, 250);
  for (let block of blocks) {
    rect(block.position.x, block.position.y, 40, 10);
  }

}
	
function mousePressed() {
    placeBlock();
}

function touchStarted() {
  placeBlock();
  return false; // To prevent any default action for this touch event
}

function placeBlock() {
    if (blocksAvailable > 0) {
        let block = Bodies.rectangle(mouseX, mouseY, 40, 10, { isStatic: true });
        World.add(world, block);
        blocks.push(block);
        blocksAvailable--;
    }
}

function initializeLevel(level) {
    ballsToPut = level;  // +1 ball for each level
    blocksAvailable = 101 - level;  // Blocks decrease by 1 each level
}


function levelUp() {
    level++;  // Increase the level by 1
    currentLevel = level; // Update the current level. This is used in displaying the level text.

    score = 0;
    availableBalls = 200;
    gameWon = false;

    // Update ballsToPut and blocksAvailable based on the new level
    initializeLevel(level);
    
    // Remove all the lemmings from the world and empty the lemmings array
    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];
    
    // Remove all blocks from the world and empty the blocks array
    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];
    
    // Move the door that releases the balls to a new position
    startPoint.x = random(20, width - 20);
    
    // Move the cup to a new position
    let goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);
    Matter.Body.setPosition(goalBody, { x: goalPosX, y: goalBody.position.y });
    Matter.Body.setPosition(goalLipLeft, { x: goalPosX - goalWidth/2, y: goalLipLeft.position.y });
    Matter.Body.setPosition(goalLipRight, { x: goalPosX + goalWidth/2, y: goalLipRight.position.y });

    loop();  // Restart the draw loop.
}



function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
}

function mousePressed() {
    if (gameWon) {
        levelUp();
    } else {
        placeBlock();
    }
}

function restartGame() {
    gameLost = false;
    gameWon = false;
    level = 1;
    score = 0;
    availableBalls = 200;
    blocksAvailable = 100;
    initializeLevel(level);

    for (let lemming of lemmings) {
        World.remove(world, lemming);
    }
    lemmings = [];

    for (let block of blocks) {
        World.remove(world, block);
    }
    blocks = [];

    startPoint.x = random(20, width - 20);
    let goalPosX = random(20 + goalWidth / 2, width - 20 - goalWidth / 2);
    Matter.Body.setPosition(goalBody, { x: goalPosX, y: goalBody.position.y });
    Matter.Body.setPosition(goalLipLeft, { x: goalPosX - goalWidth/2, y: goalLipLeft.position.y });
    Matter.Body.setPosition(goalLipRight, { x: goalPosX + goalWidth/2, y: goalLipRight.position.y });

    loop();
}


function keyPressed() {
    if (gameWon) {
        levelUp();
    }
    if (gameLost) {
        restartGame();
    }
}
"
"1995501","Flippers","mySketch","let ball;
let leftFlipper, rightFlipper;
let gravity;

function setup() {
  createCanvas(400, 600);
  
  // Comment out gravity for now
  // gravity = createVector(0, 0.2);

  // Create the ball at the center of the canvas
  ball = createSprite(width / 2, height / 2, 20, 20);
  
  // Comment out the velocity for now to see if the ball stays
  // let angle = radians(random(-45, -135));
  // ball.velocity.x = 2 * cos(angle);
  // ball.velocity.y = 2 * sin(angle);
  
  ball.shapeColor = color(255, 0, 0);

  // Create the flippers
  leftFlipper = createSprite(150, height - 50, 100, 10);
  leftFlipper.rotation = 15;
  rightFlipper = createSprite(250, height - 50, 100, 10);
  rightFlipper.rotation = -15;
}



function draw() {
  background(220);

  // Apply gravity to the ball
  //ball.velocity.add(gravity);

  // Bounce the ball off the edges
  if (ball.position.x < 0 || ball.position.x > width) {
    ball.velocity.x *= -1;
  }
  if (ball.position.y < 0) {
    ball.velocity.y *= -1;
  }

  // Flip the flippers
  if (keyIsDown(LEFT_ARROW)) {
    leftFlipper.rotation -= 5;
  } else {
    leftFlipper.rotation = 15;
  }

  if (keyIsDown(RIGHT_ARROW)) {
    rightFlipper.rotation += 5;
  } else {
    rightFlipper.rotation = -15;
  }

// Collide the ball with the flippers
if (ball.overlap(leftFlipper) || ball.overlap(rightFlipper)) {
    ball.velocity.y *= -1;
}

  // Draw the ball
ellipse(ball.position.x, ball.position.y, 20, 20);

// Draw the flippers
push();
translate(leftFlipper.position.x, leftFlipper.position.y);
rotate(radians(leftFlipper.rotation));
rect(-50, -5, 100, 10);
pop();

push();
translate(rightFlipper.position.x, rightFlipper.position.y);
rotate(radians(rightFlipper.rotation));
rect(-50, -5, 100, 10);
pop();

}

"
"1993446","Crypto Chaser","mySketch.js","let snake;
let rez = 40;  // doubled the size of each cell
let food;
let w;
let h;
let foodImg;
let headImg;
let gameOver = false;
let score = 0;  // added score
let eatSound;
let bgMusic;
let objects = ['food', 'key', 'block'];
let currentObject;
let keyImg, blockImg;  // Assuming you have images for these
let bgImage;  // Declare a variable for the background image
let bodyImg;  // Declare a variable for the snake body image

function preload() {
  foodImg = loadImage('food6.png');  // replace with path to your food image
  headImg = loadImage('snake3.png');  // replace with path to your snake head image
  eatSound = loadSound('coin.wav');
  bgMusic = loadSound('bgmusic.wav');
	keyImg = loadImage('key6.png');
  blockImg = loadImage('block6.png');
	bgImage = loadImage('bgscreen3.jpg');
	bodyImg = loadImage('body7.png');  // replace with the path to your snake body image
} 

function foodLocation() {
    let x = floor(random(w));
    let y = floor(random(h));
    currentObject = random(objects); // This will randomly select one of the three objects
    food = createVector(x, y);
}

function setup() {
    let cnv = createCanvas(880, 880);
    cnv.parent('game-section');
    background(255, 0, 0);  // Set a red background
    w = floor(width / rez);
    h = floor(height / rez);
    frameRate(5);
    startGame();
    bgMusic.loop();  // This will play the background music in a loop
	if (!localStorage.getItem('allTimeScore')) {
    localStorage.setItem('allTimeScore', '0');
}

	
}

	function displayAllTimeScore() {
    let allTimeScore = localStorage.getItem('allTimeScore');
    document.getElementById('all-time-score').innerText = allTimeScore;
}

function updateScore(newScore) {
    document.getElementById('current-score').innerText = newScore;
}

function updateAllTimeScore() {
    let allTimeScore = localStorage.getItem('allTimeScore');
    document.getElementById('all-time-score').innerText = allTimeScore;
}



function startGame() {
    snake = new Snake();
    foodLocation();
    gameOver = false;
    score = 0;  // reset score
    loop();
	  updateAllTimeScore(); // Update the displayed all-time score when starting a new game
}

function keyReleased() {
    if (gameOver) {
        startGame();
        return;  // Exit the function after restarting the game
    }

    // Only check for directional input if the game isn't over
    if (!gameOver) {
        if (keyCode === LEFT_ARROW && snake.xdir == 0) {
            snake.setDir(-1, 0);
        } else if (keyCode === RIGHT_ARROW && snake.xdir == 0) {
            snake.setDir(1, 0);
        } else if (keyCode === DOWN_ARROW && snake.ydir == 0) {
            snake.setDir(0, 1);
        } else if (keyCode === UP_ARROW && snake.ydir == 0) {
            snake.setDir(0, -1);
        }
    }
}


function draw() {
  scale(rez);
image(bgImage, 0, 0, w, h);
  
  if (snake.eat(food)) {
    foodLocation();
    eatSound.play();  // play the eat sound
  }
 
  // rendering logic for food, key, and block based on the currentObject
  if (currentObject === 'food') {
      image(foodImg, food.x, food.y, 1, 1);
  } else if (currentObject === 'key') {
      image(keyImg, food.x, food.y, 1, 1);
  } else if (currentObject === 'block') {
      image(blockImg, food.x, food.y, 1, 1);
  }

  snake.update();
  snake.show();

if (snake.endGame()) {
    gameOver = true;

    // Set a dark background for readability
    background(50, 50, 50);

    // Set the text properties
    fill('#FF00FF'); // Neon pink
    textSize(1);  // Increase the text size for better visibility
    textAlign(CENTER, CENTER);
    textFont('Press Start 2P'); // Use the retro font
    textStyle(BOLD);

    text('Lost in the digital void! Tap to restart.', w / 2, h / 2);
    noLoop();
		
    let allTimeScore = parseInt(localStorage.getItem('allTimeScore'));
    if (score > allTimeScore) {
        localStorage.setItem('allTimeScore', score.toString());
        updateAllTimeScore(); // Update the displayed all-time score
    }
}
}

class Snake {
constructor() {
    this.body = [];
    this.body[0] = createVector(floor(w / 2), floor(h / 2));
    this.xdir = 0;
    this.ydir = 0;
    this.len = 0;
}

  setDir(x, y) {
    this.xdir = x;
    this.ydir = y;
  }

  update() {
    let head = this.body[this.body.length-1].copy();
    this.body.shift();
    head.x += this.xdir;
    head.y += this.ydir;
    this.body.push(head);
  }

    grow(amount) {
        for (let i = 0; i < amount; i++) {
            let head = this.body[this.body.length-1].copy();
            this.body.push(head);
        }
    }

  endGame() {
    let x = this.body[this.body.length-1].x;
    let y = this.body[this.body.length-1].y;
    if (x > w-1 || x < 0 || y > h-1 || y < 0) {
      return true;
    }
    for (let i = 0; i < this.body.length-1; i++) {
      let part = this.body[i];
      if (part.x == x && part.y == y) {
        return true;
      }
    }
    return false;
  }

    eat(pos) {
        let x = this.body[this.body.length-1].x;
        let y = this.body[this.body.length-1].y;
        if (x == pos.x && y == pos.y) {
            if (currentObject === 'food') {
                this.grow(1);
                score += 1;
							updateScore(score);

            } else if (currentObject === 'key') {
                this.grow(2);
                score += 2;
							updateScore(score);

            } else if (currentObject === 'block') {
                this.grow(3);
                score += 3;
							updateScore(score);

            }
            return true;
        }
        return false;
    }

	
show() {
        for (let i = 0; i < this.body.length; i++) {
            if (i == this.body.length - 1) {  // If it's the head of the snake
                push();
                translate(this.body[i].x + 0.5, this.body[i].y + 0.5);
                
                // Rotation logic based on the snake's direction
                if (this.xdir == 1 && this.ydir == 0) rotate(HALF_PI);  // eyes facing right
                else if (this.xdir == -1 && this.ydir == 0) rotate(-HALF_PI);  // eyes facing left
                else if (this.xdir == 0 && this.ydir == 1) rotate(PI);  // eyes facing down
                // else eyes facing up (default)

                image(headImg, -0.5, -0.5, 1, 1);
                pop();
							
            } else {
            // Use the bodyImg for all other parts of the snake
            image(bodyImg, this.body[i].x, this.body[i].y, 1, 1);
                }
            }
        }
    }

window.connectToMetaMask = async function() {
    try {
        const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
        const account = accounts[0];
        console.log(""Connected to MetaMask account: "", account);
    } catch (error) {
        console.error(""User rejected connection:"", error);
    }
}"
"1993446","Crypto Chaser","style.css","body {
    font-family: 'Courier New', Courier, monospace;
    background-color: #2e2e2e;
    color: #0ff;
    text-align: center;
    padding: 2rem 0;
    background-image: url('data:image/png;base64,...');
}

.metamask-button {
    display: block;
    margin: 20px auto; /* Add space around the button */
    padding: 10px 20px; /* Button padding */
    background-color: orange; /* Background color */
    color: black; /* Text color */
    font-size: 16px; /* Font size */
    border: none; /* Remove border */
    border-radius: 5px; /* Rounded corners */
    cursor: pointer; /* Hand cursor on hover */
    text-align: center; /* Center text */
}

html {
    scroll-behavior: smooth;
}


.metamask-button:hover {
    background-color: #ff8c00; /* Slightly darker orange on hover */
}


.container {
    max-width: 90%; /* Adjust this to occupy more of the screen width */
    margin: 0 auto;
    padding: 2rem 2%; /* Slight padding on the sides */
    background-color: #333;
    border: 3px solid #0ff;
    border-radius: 5px;
	padding-top: 60px; /* Adjust this value as needed */
}

#game-title {
    font-family: 'Press Start 2P', cursive; /* Retro arcade game font */
    color: #00ff00; /* Neon green text */
    text-shadow: 0 0 10px #ff00ff; /* Neon pink shadow */
    font-size: 2.5rem; /* Adjust size as per your preference */
    margin: 20px 0;
}


#game-section {
    margin-top: 2rem;
    border: 2px dashed #0ff;
    padding: 1rem;
    background-color: transparent; /* Set to transparent */
    display: flex;
    justify-content: center; /* Center the canvas horizontally */
    align-items: center;     /* Center the canvas vertically */
    height: 900px;           /* Adjusted to contain the game canvas */
    overflow: hidden;        /* Hide anything that goes outside this box */
}


header, section, footer {
    border-bottom: 2px dashed #0ff;
    padding-bottom: 1rem;
    margin-bottom: 1rem;
}

header h1 {
    font-size: 3rem;
    margin: 0;
}

section h2 {
    font-size: 2rem;
    text-decoration: underline;
}

section p {
    font-size: 1.2rem;
}

.characters-section {
    background-color: #333;
    padding: 20px 0;
    border-top: 2px dashed #0ff;
    border-bottom: 2px dashed #0ff;
    margin-top: 1rem;
    margin-bottom: 1rem;
}

.character {
    display: inline-block;
    margin: 0 auto;
}

.character img {
    display: block;
    width: 150px; /* Adjust as needed */
    margin: 0 auto;
}

.character h3 {
    font-size: 1.5rem;
    margin-top: 1rem;
    color: #0ff;
}

.character p {
    font-size: 1rem;
    max-width: 400px;
    margin: 10px auto;
    color: #0ff;
}

.fragments-section {
    background-color: #333;
    padding: 20px 0;
    border-top: 2px dashed #0ff;
    border-bottom: 2px dashed #0ff;
    margin-top: 1rem;
    margin-bottom: 1rem;
}

.fragment {
    display: inline-block;
    margin: 0 10px;
    vertical-align: top; /* Aligns the fragments vertically */
}

.fragment img {
    display: block;
    width: 150px; /* Adjust as needed */
    margin: 0 auto;
}

.fragment h3 {
    font-size: 1.5rem;
    margin-top: 1rem;
    color: #0ff;
}

.fragment p {
    font-size: 1rem;
    max-width: 300px; /* Adjusted width for fragment descriptions */
    margin: 10px auto;
    color: #0ff;
}

.tokenomics h2, .tokenomics h3 {
    font-size: 2rem;
    text-align: center;
    margin-top: 20px;
}

.tokenomics ul {
    list-style-type: none; /* Removes default bullet points */
    padding-left: 0; /* Removes default padding */
}

.tokenomics li {
    margin-bottom: 10px; /* Adds a bit of space between list items */
}


.tokenomics li:before {
    content: ""•""; /* Adds a bullet point */
    position: absolute;
    left: 0;
    color: #0ff; /* Changes bullet point color */
    font-size: 1.5rem; /* Adjusts bullet point size */
}

.tokenomics {
    padding: 20px; /* Add some padding to the container to ensure content doesn't touch the borders */
}

.tokenomics ul {
    margin: 0; /* Reset the default margin */
}

.tokenomics li {
      font-size: 1.2rem;  /* Adjust to the desired size */  
	margin-bottom: 10px; /* Adds a bit of space between list items */
	margin-right: 10px;  /* Space between each item */
    padding-left: 1rem; /* Adds some padding to the left of each list item for better readability */
}

/* Style for all the links and buttons in the menu */
.horizontal-menu a, .horizontal-menu .metamask-button {
    flex: 1; /* Distribute space evenly */
    text-align: center; /* Center text inside each link/button */
    min-width: 90px; /* Set a minimum width */
    max-width: 140px; /* Set a maximum width */
    overflow: hidden; /* Handle overflow */
    white-space: nowrap; /* Prevent wrapping */
    text-overflow: ellipsis; /* Handle overflow with ellipsis */
    margin: 0 5px; /* Space out each button a bit */
}

.horizontal-menu {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;  /* Match the width of the container */
    max-width: 90%;  /* Match the max-width of the container */
    background-color: #2e2e2e;
    border: 2px solid #0ff;
    padding: 10px;
    border-radius: 5px;
    display: flex;
    align-items: center; /* Vertically center content */
    justify-content: space-between; /* Distribute space between menu items */
}

.horizontal-menu ul {
    list-style-type: none;
    padding: 0;
    display: flex;
    gap: 10px; /* Spacing between menu items */
    margin: 0; /* Remove default margin */
}

.horizontal-menu li {
    margin-bottom: 0;
}

.horizontal-menu a {
    color: #0ff;
    text-decoration: none;
    font-family: 'Courier New', Courier, monospace;
    font-size: 1.1rem;
    padding: 5px;
    border: 1px solid #0ff;
    border-radius: 5px;
    transition: background-color 0.3s, color 0.3s;
}

.horizontal-menu a:hover {
    background-color: #0ff;
    color: #2e2e2e;
}

.social-media {
    display: flex; /* Align social media links horizontally */
    gap: 10px; /* Spacing between social media links */
}

.metamask-button {
    display: inline-block; /* Change from block to inline-block for menu alignment */
    margin: 0 10px; /* Adjust for spacing between menu items */
    padding: 10px 20px; /* Button padding */
    background-color: orange; /* Background color */
   color: black; /* Text color */
    font-size: 1.1rem; /* Adjust to match other buttons */
    font-family: 'Courier New', Courier, monospace; /* Match the font of other buttons */
    border: 1px solid #0ff;
    border-radius: 5px; /* Rounded corners */
    cursor: pointer; /* Hand cursor on hover */
    transition: background-color 0.3s, color 0.3s; /* Transition effect for hover */
}

.metamask-button:hover {
    background-color: #ff8c00; /* Slightly darker orange on hover */
   color: black; /* Text color */
}

.score-section {
    background-color: #333;
    padding: 20px 0;
    border-top: 2px dashed #0ff;
    border-bottom: 2px dashed #0ff;
    margin-top: 1rem;
    margin-bottom: 1rem;
}

.score-display {
    font-size: 2rem;
    color: #0ff;
}

#score-display {
    font-family: 'Press Start 2P', cursive; /* Retro arcade game font */
    background-color: #2e2e2e; /* Dark background */
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 0 10px #00ff00; /* Neon green shadow */
    color: #00ff00; /* Neon green text */
    text-align: center;
    margin: 20px 0;
}

#score-display span {
    font-size: 1.5em;
    padding: 0 10px;
    box-shadow: 0 0 10px #ff00ff; /* Neon pink shadow for numbers */
    color: #ff00ff; /* Neon pink for numbers */
}

footer {
    border: none;
}
"
"1993446","Crypto Chaser","index.html","<!DOCTYPE html>
<html lang=""en"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>SnakeCoin: The Retro Crypto Game</title>
    <link rel=""stylesheet"" href=""style.css"">
    <script src=""https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js""></script>
   	<script src=""https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js""></script>
	<script src=""https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.5.2/dist/web3.min.js""></script>
	<link href=""https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"" rel=""stylesheet"">

</head>
<body>

<div class=""horizontal-menu"">
    <ul>
        <li><a href=""#game-section"">Play</a></li>
        <li><a href=""#characters-section"">Satoshi</a></li>
        <li><a href=""#fragments-section"">Fragments</a></li>
        <li><a href=""#tokenomics"">Tokenomics</a></li>
        <li><a href=""#rewards-section"">Rewards</a></li>
        <li><a href=""#future-evolution"">Roadmap</a></li>
    </ul>
    <div class=""social-media"">
        <a href=""https://t.me/ggdappchat"" target=""_blank"">Telegram</a>
        <a href=""https://twitter.com/gg_dapp"" target=""_blank"">Twitter</a>
        <a href=""https://ggdapp.medium.com/"" target=""_blank"">Medium</a>
        <a href=""https://ggdapp.com/wp-content/uploads/2023/01/discord.png"" target=""_blank"">Discord</a>
    </div>
    <button class=""metamask-button"">MetaMask</button>

</div>


<div class=""container"">
<header>
    <h1 id=""game-title"">Crypto Chaser: '80s arcade, modern rewards</h1>
</header>


	<section>
    <h2>Unlock daily $ rewards and snag ultra-rare NFTs. Dive in now!</h2>
 </section>
	
<section>
    <h2>The Epic Odyssey in the Digital Cosmos</h2>
    <p>
        Imagine a universe, vast and infinite, where cryptos, the lifeblood of the digital age, lay fragmented and forgotten. But hope is not lost.
    </p>
    <p>
        Enter Satoshi, a visionary coder with an unyielding passion for crypto. Driven by the desire to restore harmony, he crafts ""Crypto Chaser"", a unique algorithm designed to navigate this realm, seeking out and stitching together the scattered crypto fragments.
    </p>
    <p>
        Embrace the role of Satoshi. Steer the ""Crypto Chaser"" with precision and purpose. Traverse the digital cosmos, outsmart its treacherous obstacles, and reclaim the lost crypto fragments. The fate of the digital world rests in your hands. Are you ready for the challenge?
    </p>
</section>

	<!-- Characters Section -->
<section class=""characters-section"" id=""characters-section"">
    <h2>Meet Satoshi</h2>

    <div class=""character"">
        <img id=""satoshi-img"" src=""snake3.png"" alt=""Satoshi"">
        <p>The visionary coder who crafted the ""Crypto Chaser"" algorithm. Satoshi embarks on a quest to stitch together the scattered crypto fragments.</p>
    </div>
</section>

<!-- Crypto Fragments Section -->
<section class=""fragments-section"" id=""fragments-section"">

    <h2>Crypto Fragments of the Digital Cosmos</h2>
    
    <div class=""fragment"">
        <img src=""food6.png"" alt=""Basic Crypto Fragment"">
        <h3>Token Fragment</h3>
        <p>The common token fragments found throughout the digital realm. Essential for Satoshi's collection. Worth <strong>1 point</strong>.</p>
    </div>
    
    <div class=""fragment"">
        <img src=""key6.png"" alt=""Key Fragment"">
        <h3>Key Fragment</h3>
        <p>Rare fragments representing the deeper secrets of the crypto world. They unlock hidden pathways in the digital cosmos. Worth <strong>2 points</strong>.</p>
    </div>
    
    <div class=""fragment"">
        <img src=""block6.png"" alt=""Block Fragment"">
        <h3>Block Fragment</h3>
        <p>The building blocks of the blockchain. Collecting these fortifies Satoshi's crypto collection against glitches. Worth <strong>3 points</strong>.</p>
    </div>
</section>

<p id=""score-display"">Your best score = <span id=""all-time-score"">0</span>       Your last score = <span id=""current-score"">0</span></p>


    <!-- Game Canvas Embed -->
    <section id=""game-section"">
        <!-- The p5.js canvas will be appended here by the setup function in mySketch.js -->
    </section>

	<!-- Tokenomics Section -->
<section class=""tokenomics"" id=""tokenomics"">

    <h2>Tokenomics</h2>
    <h3>Supply and Price</h3>
	  <ul>
        <li>Supply: 50M tokens  //  Token Price: $0.01 </li>
        <li><em>(values estimated at IDO)</em></li>
    </ul>

    <h3>Distribution</h3>
    <ul>
        <li>LP Locked = 40%  //  Rewards = 40%  //  Marketing = 10%  //  Team = 10%</li>
    </ul>

    <h3>Tax 5/5</h3>
    <ul>
        <li>Ultra-rare NFT purchases: 1%  //  Liquidity pool: 1%  //  Burning: 1%  //  Marketing: 1%  //  Team treasury: 1%</li>
        <li><em>(5% on both buy & sell)</em></li>
    </ul>
</section>
	
	<section class=""rewards-section"" id=""rewards-section"">

    <h2><strong>Rewards System</strong></h2>
    
    <div class=""intro"">
        <h3>🔥 Begin Your Journey!</h3>
        <p><strong>Start Strong</strong>: In our initial phase, every point you earn equals 1 token.</p>
        <p><strong>Daily Wins</strong>: Play and earn daily, but remember, there's a cap on the tokens you can redeem each day to keep things fair for everyone. The initial cap is 500 tokens. </p>
    </div>
    
    <div class=""community-growth"">
        <h3>🌟 As Our Community Grows...</h3>
        <p><strong>Adapting for All</strong>: As more players join the Crypto Chaser family, we'll adjust the point-to-token ratio. This means the conversion might change from 1:1 to 2:1 or even more.</p>
        <p><strong>More Players, More Fun</strong>: With each milestone we hit in player numbers, there might be small tweaks in the redemption limits. It's all about balancing the game for everyone.</p>
    </div>

    <div class=""special-events"">
        <h3>🎉 Special Events & More!</h3>
        <p><strong>Double Reward Days</strong>: Keep an eye out for bonus events where you can earn more tokens!</p>
        <p><strong>Loyal Player? Get More</strong>: The longer and more actively you play, the better your rewards.</p>
    </div>

    <div class=""fair-play"">
        <h3>🛡️ Fair Play, Always!</h3>
        <p><strong>Transparent Changes</strong>: If there are any changes in the rewards, we'll tell you upfront. Your trust is our priority.</p>
        <p><strong>We Listen</strong>: Have feedback or ideas? We're all ears. Help us make Crypto Chaser even better!</p>
    </div>

    <p class=""closing-statement"">Join the game, chase the cryptos, and let's make some memories!</p>
</section>

	
	
<section>
<section id=""future-evolution"">

    <h2>Roadmap</h2>
    <ol>
        <h3>🎮 Engaging Levels:</h3> 
			      <p>Dive deeper into the digital realm with increasingly intricate grids, optimized for both desktop and mobile gameplay. Watch as the Crypto Chaser zips faster and faces more cunning digital bugs as you advance.</p>
	
        <h3>🎁 Ultra-rare NFTs:</h3> 
							<p>Satoshi's quest in the digital world is sprinkled with unique surprises. Discover ultra-rare NFTs, reminiscent of coveted treasures like Apes and CryptoPunks, financed by the game's transaction proceeds. These gems will sporadically emerge in the game arena, waiting for a lucky player to claim them at no cost. However, to ensure both commitment and fairness, only those with a minimum of 10,000 tokens in their wallets stand a chance to seize these prized possessions. The rarest treasures await the most dedicated players!<p>
        
        <h3>💰 Real Token Redemption:</h3> 
							<p>Prove your prowess, and once we transition out of our beta phase, the game will merge with the blockchain. Players will have the thrilling opportunity to earn genuine Ethereum and Polygon tokens, heralding a true play-to-earn experience. An exhilarating gaming adventure with tangible rewards!<p>
    </ol>
</section>


	
    <!-- Footer Text -->
    <footer>
        ❤️ By Algorithm G Studios, 2023 with GG dApp - the origin of $GGTK ❤️
    </footer>
</div>

<!-- Include your game script -->
<script src=""mySketch.js""></script>

</body>
</html>
"
"1993019","Pixel Pong","mySketch","// Global Variables
let ball;
let leftPaddle;
let rightPaddle;
let leftScore = 0;
let rightScore = 0;
let gameState = ""menu"";
let lastHitTime = 0;
let originalWidth = 480;
let originalHeight = 360;
let bgImage;

const HIT_COOLDOWN = 500;
const BALL_SPEED_INCREMENT = 0.1;
const MAX_BALL_SPEED = 7;
const MIN_CURVE_ANGLE = -15;
const MAX_CURVE_ANGLE = 15;

function preload() {
    bgImage = loadImage('pong_background.png');
}

function setup() {
    createCanvas(originalWidth, originalHeight);

    // Initialize ball and paddles
    initializeBall();
    initializePaddles();

    if (localStorage.getItem('leftScore')) {
        leftScore = parseInt(localStorage.getItem('leftScore'));
    }
    if (localStorage.getItem('rightScore')) {
        rightScore = parseInt(localStorage.getItem('rightScore'));
    }
}

function draw() {
    if (gameState === ""menu"") {
        displayInitialScreen();
    } else if (gameState === ""play"") {
        displayGameArena();
    }
}


function displayGameArena() {
    background(220);
    image(bgImage, 0, 0, width, height);

    // Ball and paddle movement logic
    moveBall();
    movePaddles();
    checkCollisions();

    // Drawing ball and paddles
    ellipse(ball.x, ball.y, ball.size);
    rect(leftPaddle.x, leftPaddle.y, leftPaddle.width, leftPaddle.height);
    rect(rightPaddle.x, rightPaddle.y, rightPaddle.width, rightPaddle.height);

    textSize(32);
    textAlign(CENTER, CENTER);
    text(leftScore, width / 4, 50);
    text(rightScore, 3 * width / 4, 50);
}

function displayInitialScreen() {
    background(0);

    textSize(20);
    // Comment out the next line if the font isn't available
    // textFont('Press Start 2P'); 
    textAlign(CENTER, CENTER);
    fill(255);
    text('Pixel Pong', width / 2, height / 6);

    // Game title and description
    // ...

    let playButton = createButton('< < < Play Now > > >');
    applyButtonStyles(playButton);
    playButton.position(width / 2 - 100, 3 * height / 4);
    playButton.mousePressed(startGame);

    let resetButton = createButton('Reset Scoreboard');
    applyButtonStyles(resetButton);
    resetButton.position(width / 2 - 100, 3 * height / 4 + 50);
    resetButton.mousePressed(resetScores);
}

function applyButtonStyles(button) {
    button.style('background-color', '#FFFFFF');
    button.style('color', '#000000');
    button.style('border', 'none');
    button.style('padding', '10px 40px');
    button.style('cursor', 'pointer');
    button.style('font-size', '18px');
    button.style('font-family', 'Press Start 2P');
}

function initializePaddles() {
    leftPaddle = {
        x: 10,
        y: height / 2 - 20,
        width: 10,
        height: 40,
        speed: 4
    };

    rightPaddle = {
        x: width - 20,
        y: height / 2 - 20,
        width: 10,
        height: 40,
        speed: 4
    };
}

function moveBall() {
    ball.x += ball.speedX;
    ball.y += ball.speedY;
}

function movePaddles() {
    if (keyIsDown(UP_ARROW)) {
        leftPaddle.y -= leftPaddle.speed;
    }
    if (keyIsDown(DOWN_ARROW)) {
        leftPaddle.y += leftPaddle.speed;
    }
    // Add movement for rightPaddle if needed
}

function startGame() {
    removeElements(); // Remove buttons from initial screen
    gameState = ""play"";
    initializeBall();

    leftPaddle = {
        x: 10,
        y: height / 2 - 20,
        width: 10,
        height: 40,
        speed: 4
    };

    rightPaddle = {
        x: width - 20,
        y: height / 2 - 20,
        width: 10,
        height: 40,
        speed: 4
    };
}

function initializeBall() {
    ball = {
        x: width / 2,
        y: height / 2,
        size: 10,
        speedX: random([3, -3]),
        speedY: random([2, -2])
    };
}

function resetScores() {
    leftScore = 0;
    rightScore = 0;
    localStorage.removeItem('leftScore');
    localStorage.removeItem('rightScore');
}


function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    // Call the display function again to reposition the elements
    if (gameState === ""menu"") {
        displayInitialScreen();
    }
}


function keyPressed() {
    if (keyCode === UP_ARROW) {
        rightPaddle.y -= rightPaddle.speed;
    } else if (keyCode === DOWN_ARROW) {
        rightPaddle.y += rightPaddle.speed;
    }

    let keyLower = key.toLowerCase();
    if (keyLower === 'w') {
        leftPaddle.y -= leftPaddle.speed;
    } else if (keyLower === 's') {
        leftPaddle.y += leftPaddle.speed;
    }
}


function displayMenu() {
    background(220);

    // Game description
    createElement('h2', 'Pixel Pong');
    createElement('p', 'A retro-style game where you test your reflexes against a friend or a bot!');

    // Game rules and commands
    createElement('h3', 'Rules:');
    createElement('p', ""Make sure the ball doesn't pass your paddle. Every miss scores a point for the opponent!"");
    createElement('h3', 'Commands:');
    createElement('p', ""Player 1: 'W' for up and 'S' for down. Player 2: Arrow keys."");

    // Options
    let radio = createRadio();
    radio.option('Play against a friend');
    radio.option('Play against a bot');
    radio.position(10, 250);
    radio.style('width', '300px');

    let button = createButton('Play');
    button.position(320, 250);
    button.mousePressed(() => {
        let val = radio.value();
        if (val === 'Play against a friend') {
            playMode = 'friend';
        } else if (val === 'Play against a bot') {
            playMode = 'bot';
        }
        startGame();
    });
}

"
"1976881","Gear with me","mySketch","let prevSec;
let easing = 0.05;
let targetAngle, angle = 0;
let gear1, gear2, gear3;

function setup() {
  createCanvas(windowWidth, windowHeight);
  angleMode(DEGREES);
  prevSec = second();

  // Initialize gears
  gear1 = new Gear(0, 150, 0.1, 60); // Connected to the hour hand
  gear2 = new Gear(0, 50, 2, 40);  // Connected to the minute hand
  gear3 = new Gear(0, -50, 6, 20);   // Connected to the second hand
}

function draw() {
  background(0);
  translate(width / 2, height / 2);
  rotate(-90);

  let hr = hour();
  let mn = minute();
  let sc = second();

  // Smooth transition of second hand
  if (prevSec != sc) {
    prevSec = sc;
    targetAngle = sc * 6;
  }
  let dTheta = targetAngle - angle;
  angle += dTheta * easing;

  strokeWeight(8);
  noFill();

  // Draw the second hand
  stroke(255, 100, 150);
  let secondAngle = map(sc, 0, 60, 0, 360);
  arc(0, 0, 300, 300, 0, secondAngle);

  // Draw the minute hand
  stroke(150, 100, 255);
  let minuteAngle = map(mn, 0, 60, 0, 360);
  arc(0, 0, 280, 280, 0, minuteAngle);

  // Draw the hour hand
  stroke(150, 255, 100);
  let hourAngle = map(hr % 12, 0, 12, 0, 360);
  arc(0, 0, 260, 260, 0, hourAngle);

  // Update and display gears
  gear1.update(hourAngle);
  gear1.display();

  gear2.update(minuteAngle);
  gear2.display();

  gear3.update(secondAngle);
  gear3.display();

  push();
  rotate(secondAngle);
  stroke(255, 100, 150);
  line(0, 0, 100, 0);
  pop();

  push();
  rotate(minuteAngle);
  stroke(150, 100, 255);
  line(0, 0, 75, 0);
  pop();

  push();
  rotate(hourAngle);
  stroke(150, 255, 100);
  line(0, 0, 50, 0);
  pop();

  stroke(255);
  point(0, 0);
}

class Gear {
  constructor(x, y, speed, size) {
    this.x = x;
    this.y = y;
    this.speed = speed;
    this.size = size;
    this.angle = 0;
  }

  update(connectedAngle) {
    this.angle = connectedAngle * this.speed;
  }

  display() {
    push();
    translate(this.x, this.y);
    rotate(this.angle);
    stroke(255);
    for (let i = 0; i < 12; i++) {
      line(this.size, 0, this.size + 10, 0);
      rotate(360 / 12);
    }
    pop();
  }
}
"
"1976879","What time is it?","mySketch","let angle = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  angleMode(DEGREES); // Change the mode to DEGREES
}

function draw() {
  background(0);
  translate(width / 2, height / 2); // Move the origin to the center
  rotate(-90); // Rotate 90 degrees counter-clockwise
  
  let hr = hour();
  let mn = minute();
  let sc = second();
  
  strokeWeight(8);
  noFill();
  
  // Draw the second hand
  stroke(255, 100, 150); // Red
  let secondAngle = map(sc, 0, 60, 0, 360);
  arc(0, 0, 300, 300, 0, secondAngle);
  
  // Draw the minute hand
  stroke(150, 100, 255); // Blue
  let minuteAngle = map(mn, 0, 60, 0, 360);
  arc(0, 0, 280, 280, 0, minuteAngle);
  
  // Draw the hour hand
  stroke(150, 255, 100); // Green
  let hourAngle = map(hr % 12, 0, 12, 0, 360);
  arc(0, 0, 260, 260, 0, hourAngle);
  
  push();
  rotate(secondAngle);
  stroke(255, 100, 150); // Red
  line(0, 0, 100, 0);
  pop();
  
  push();
  rotate(minuteAngle);
  stroke(150, 100, 255); // Blue
  line(0, 0, 75, 0);
  pop();
  
  push();
  rotate(hourAngle);
  stroke(150, 255, 100); // Green
  line(0, 0, 50, 0);
  pop();
  
  stroke(255);
  point(0, 0);
}
"
"1976872","Pendulum","mySketch.js","let pendulums = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  for (let i = 0; i < 3; i++) {
    pendulums[i] = new Pendulum(width / 4 * (i + 1), height / 4, 200);
  }
}

function draw() {
  background(220);
  for (let pendulum of pendulums) {
    pendulum.update();
    pendulum.checkCollision();
    pendulum.display();
  }
}

function mousePressed() {
  for (let pendulum of pendulums) {
    pendulum.clicked(mouseX, mouseY);
  }
}

function mouseReleased() {
  for (let pendulum of pendulums) {
    pendulum.stopDragging();
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

class Pendulum {
  constructor(x, y, l) {
    this.origin = createVector(x, y);
    this.position = createVector(x, y + l);
    this.r = this.origin.dist(this.position);
    this.angle = PI/2;
    this.aVelocity = 0.0;
    this.aAcceleration = 0.0;
    this.damping = 0.995;
    this.dragging = false;
  }

  update() {
    if (!this.dragging) {
      let gravity = 0.4;
      this.aAcceleration = (gravity / this.r) * cos(this.angle);
      this.aVelocity += this.aAcceleration;
      this.aVelocity *= this.damping;
      this.angle += this.aVelocity;
    } else {
      this.r = dist(this.origin.x, this.origin.y, mouseX, mouseY);
      this.angle = atan2(mouseY - this.origin.y, mouseX - this.origin.x);
    }

    this.position = p5.Vector.add(this.origin, createVector(this.r * cos(this.angle), this.r * sin(this.angle)));
  }

  checkCollision() {
    for (let other of pendulums) {
      if (other != this) {
        let distance = dist(this.position.x, this.position.y, other.position.x, other.position.y);
        if (distance < 48) { 
          let angle = atan2(this.position.y - other.position.y, this.position.x - other.position.x);
          this.aVelocity += 0.1 * cos(angle);
          other.aVelocity -= 0.1 * cos(angle);
        }
      }
    }
  }

  display() {
    stroke(0);
    if (this.dragging) {
      fill(255);
    } else {
      fill(175);
    }
    line(this.origin.x, this.origin.y, this.position.x, this.position.y);
    ellipse(this.position.x, this.position.y, 48, 48);
  }

  clicked(mx, my) {
    let d = dist(mx, my, this.position.x, this.position.y);
    if (d < 24) {
      this.dragging = true;
      this.aVelocity = 0;
    }
  }

  stopDragging() {
    this.dragging = false;
  }
}
"
"1976851","Colorful Shadow Puppetry","mySketch","let shadows = [];

function setup() {
  createCanvas(800, 800);
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0);
  shadows.push(new Shadow(mouseX, mouseY));

  for (let i = shadows.length - 1; i >= 0; i--) {
    shadows[i].update();
    shadows[i].show();
    if (shadows[i].finished()) {
      shadows.splice(i, 1);
    }
  }
}

class Shadow {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.alpha = 255;
    this.color = color(random(0, 360), 100, 100);
    this.size = random(20, 80);
  }

  finished() {
    return this.alpha < 0;
  }

  update() {
    this.alpha -= 5;
    this.size += 1;
  }

  show() {
    noStroke();
    fill(this.color, this.alpha);
    ellipse(this.x, this.y, this.size);
  }
}
"
"1976849","Kaleidoscope","mySketch","let segments = 0;
let rotAngle = 0.0;

function setup() {
  createCanvas(800, 800);
  colorMode(HSB, 360, 100, 100); // Use hue, saturation, brightness
  angleMode(DEGREES);
  noStroke();
}

function draw() {
  background(0);
  translate(width / 2, height / 2);

  // The number of reflections depends on the mouse's horizontal position
  segments = map(mouseX, 0, width, 5, 10, true);
  rotAngle = 360.0 / segments;

  for (let i = 0; i < segments; i++) {
    push();
    rotate(i * rotAngle);
    createSegment();
    pop();
  }
}

function createSegment() {
  beginShape();
  for (let i = 0; i <= 180; i++) {
    let rad = map(i, 0, 180, 0, 150);
    let x = rad * cos(i);
    let y = rad * sin(i);
    let col = map(mouseY, 0, height, 0, 360); // The hue depends on the mouse's vertical position
    fill(col, 100, 100);
    vertex(x, y);
  }
  endShape(CLOSE);
}
"
"1975903","Finding Pi","mySketch","let points = [];
let circleRadius;
let totalPoints = 0;
let circlePoints = 0;

function setup() {
  createCanvas(400, 400);
  circleRadius = width / 2;
  background(0);
  stroke(255);
  noFill();
  ellipse(width / 2, height / 2, circleRadius * 2, circleRadius * 2);
  rectMode(CENTER);
  rect(width / 2, height / 2, circleRadius * 2, circleRadius * 2);
}

function draw() {
  let pointVector = createVector(random(width), random(height));
  points.push(pointVector);
  totalPoints++;

  stroke(0, 255, 0);
  if (dist(pointVector.x, pointVector.y, width / 2, height / 2) < circleRadius) {
    circlePoints++;
    stroke(255, 0, 0);
  }

  point(pointVector.x, pointVector.y);  // Corrected here

  let piApprox = 4 * (circlePoints / totalPoints);
  noStroke();
  fill(0);
  rect(50, 15, 100, 20);
  fill(255);
  text(`Pi: ${piApprox.toFixed(6)}`, 10, 20);
}
"
"1975902","Convex Hull Algorithm","mySketch","let points = [];
let hull = [];
let counter = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  let buffer = 20;
  for (let i = 0; i < 100; i++) {
    points.push(createVector(random(buffer, width - buffer), random(buffer, height - buffer)));
  }
  points.sort((a, b) => a.x - b.x);
  hull.push(points[0]);
  hull.push(points[1]);
  points.splice(0, 2);
  
  frameRate(2); // Setting the frame rate to 2 frames per second
}

function grahamScan() {
  if (counter < points.length) {
    let index = -1;
    for (let i = 0; i < hull.length; i++) {
      let p = hull[i];
      let q = hull[(i + 1) % hull.length];
      let r = points[counter];
      let val = (q.x - p.x) * (r.y - q.y) - (q.y - p.y) * (r.x - q.x);
      if (val > 0) {
        index = i;
      }
    }
    if (index != -1) {
      hull.splice(index + 1, 0, points[counter]);
    }
    counter++;
  }
}

function draw() {
  background(0);
  stroke(255);
  strokeWeight(8);
  for (let p of points) {
    point(p.x, p.y);
  }
  grahamScan();
  stroke(0, 255, 0);
  strokeWeight(2);
  noFill();
  beginShape();
  for (let v of hull) {
    vertex(v.x, v.y);
  }
  endShape(CLOSE);
}
"
"1975898","Breadth-First Search","mySketch","let grid;
let startNode;
let endNode;
let queue = [];
let path = [];
let w, h;
let cols = 40;
let rows = 40;

function setup() {
  createCanvas(400, 400);
  w = width / cols;
  h = height / rows;
  frameRate(10); // Slow down frame rate to 10 frames per second
  grid = new Array(cols);
  for (let i = 0; i < cols; i++) {
    grid[i] = new Array(rows);
  }

  // Create nodes
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      grid[i][j] = new Node(i, j);
    }
  }

  // Set start and end nodes
  startNode = grid[0][0];
  endNode = grid[cols - 1][rows - 1];
  startNode.isWall = false;
  endNode.isWall = false;

  queue.push(startNode);
  startNode.visited = true;
}

function draw() {
  background(255);

  // BFS
  if (queue.length > 0) {
    let currentNode = queue.shift();

    if (currentNode === endNode) {
      console.log(""Path found!"");
      noLoop();
    }

    let neighbors = currentNode.getNeighbors(grid);
    for (let i = 0; i < neighbors.length; i++) {
      let neighbor = neighbors[i];
      if (!neighbor.visited && !neighbor.isWall) {
        queue.push(neighbor);
        neighbor.visited = true;
        neighbor.parent = currentNode;
      }
    }
  } else {
    console.log(""No path found!"");
    noLoop();
    return;
  }

  // Draw grid
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      if (grid[i][j].visited) {
        grid[i][j].show(color(100, 220, 100)); // visited nodes in light green
      } else {
        grid[i][j].show(color(255));
      }
    }
  }

  // Draw path
  path = [];
  let temp = queue[0];
  while (temp.parent) {
    path.push(temp);
    temp = temp.parent;
  }

  for (let i = 0; i < path.length; i++) {
    path[i].show(color(0, 0, 255)); // current path in blue
  }
}

class Node {
  constructor(i, j) {
    this.i = i;
    this.j = j;
    this.isWall = random(1) < 0.3;
    this.visited = false;
    this.parent = undefined;
  }

  show(col) {
    fill(this.isWall ? color(0) : col);
    noStroke();
    rect(this.i * w, this.j * h, w - 1, h - 1);
  }

  getNeighbors(grid) {
    let neighbors = [];
    let i = this.i;
    let j = this.j;
    if (i < cols - 1) neighbors.push(grid[i + 1][j]);
    if (i > 0) neighbors.push(grid[i - 1][j]);
    if (j < rows - 1) neighbors.push(grid[i][j + 1]);
    if (j > 0) neighbors.push(grid[i][j - 1]);
    return neighbors;
  }
}
"
"1975897","Truchet Tiling","mySketch","let tileSize = 40;

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);
  noLoop();
}

function draw() {
  for(let x = 0; x < width; x += tileSize) {
    for(let y = 0; y < height; y += tileSize) {
      push();
      translate(x, y);
      let choice = random(1);
      if(choice < 0.5) {
        arc(0, 0, tileSize, tileSize, 0, HALF_PI);
        arc(tileSize, tileSize, tileSize, tileSize, PI, PI + HALF_PI);
      } else {
        arc(0, tileSize, tileSize, tileSize, HALF_PI, PI);
        arc(tileSize, 0, tileSize, tileSize, PI + HALF_PI, 0);
      }
      pop();
    }
  }
}
"
"1975896","Bubble Sort","mySketch","let values = [];
let i = 0;
let j = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  values = new Array(floor(width / 10));
  for (let i = 0; i < values.length; i++) {
    values[i] = random(height);
  }
}

function draw() {
  background(0);
  
  // Bubble Sort
  if (i < values.length) {
    for (let j = 0; j < values.length - i - 1; j++) {
      let a = values[j];
      let b = values[j + 1];
      if (a > b) {
        swap(values, j, j + 1);
      }
    }
  } else {
    console.log(""Finished"");
    noLoop();
  }
  i++;

  // Draw the values
  for (let i = 0; i < values.length; i++) {
    stroke(0);
    fill(255);
    rect(i * 10, height - values[i], 10, values[i]);
  }
}

function swap(arr, a, b) {
  let temp = arr[a];
  arr[a] = arr[b];
  arr[b] = temp;
}
"
"1975893","Fluid motion","mySketch","let inc = 0.1;
let scl = 10;
let cols, rows;
let zoff = 0;
let fr;
let flowfield;
let particles = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 255);
  cols = floor(width / scl);
  rows = floor(height / scl);
  fr = createP('');
  flowfield = new Array(cols * rows);
  for (let i = 0; i < 3000; i++) {
    particles[i] = new Particle();
  }
  background(255);
}

function draw() {
  let yoff = 0;
  for (let y = 0; y < rows; y++) {
    let xoff = 0;
    for (let x = 0; x < cols; x++) {
      let index = x + y * cols;
      let angle = noise(xoff, yoff, zoff) * TWO_PI * 4;
      let v = p5.Vector.fromAngle(angle);
      v.setMag(1);
      flowfield[index] = v;
      xoff += inc;
    }
    yoff += inc;
    zoff += 0.0003;
  }
  for (let i = 0; i < particles.length; i++) {
    particles[i].follow(flowfield);
    particles[i].update();
    particles[i].edges();
    particles[i].show();
    particles[i].interact();
  }
}

class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.maxspeed = 4;
    this.prevPos = this.pos.copy();
    this.hue = random(255);
  }

  update() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxspeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  follow(vectors) {
    let x = floor(this.pos.x / scl);
    let y = floor(this.pos.y / scl);
    let index = x + y * cols;
    let force = vectors[index];
    this.applyForce(force);
  }

  applyForce(force) {
    this.acc.add(force);
  }

  show() {
    stroke(this.hue, 255, 255, 5);
    strokeWeight(1);
    line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
    this.updatePrev();
  }

  updatePrev() {
    this.prevPos.x = this.pos.x;
    this.prevPos.y = this.pos.y;
  }

  edges() {
    if (this.pos.x > width) {
      this.pos.x = 0;
      this.updatePrev();
    }
    if (this.pos.x < 0) {
      this.pos.x = width;
      this.updatePrev();
    }
    if (this.pos.y > height) {
      this.pos.y = 0;
      this.updatePrev();
    }
    if (this.pos.y < 0) {
      this.pos.y = height;
      this.updatePrev();
    }
  }

  interact() {
    let mouseDist = dist(mouseX, mouseY, this.pos.x, this.pos.y);
    if (mouseDist < 100) {
      this.pos = createVector(random(width), random(height));
      this.updatePrev();
    }
  }
}
"
"1975892","Soundify","mySketch","let mic;
let particles = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  mic = new p5.AudioIn();
  mic.start();
  
  for(let i = 0; i < 200; i++) {
    particles[i] = new Particle();
  }
}

function draw() {
  background(0);
  
  let vol = mic.getLevel();

  for(let i = 0; i < particles.length; i++) {
    particles[i].update(vol);
    particles[i].show(vol);
  }
}

class Particle {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.vel = createVector(random(-1, 1), random(-1, 1));
    this.acc = createVector(0, 0);
    this.color = [random(255), random(255), random(255)];
  }

  update(vol) {
    this.acc.add(this.vel);
    this.pos.add(this.acc);
    this.acc.mult(0);
    this.vel.limit(vol * 25);  // Adjust movement speed with volume
    
    if (this.pos.x > width || this.pos.x < 0) this.vel.x *= -1;
    if (this.pos.y > height || this.pos.y < 0) this.vel.y *= -1;
  }

  show(vol) {
    noStroke();
    fill(this.color[0], this.color[1], this.color[2], 100);
    ellipse(this.pos.x, this.pos.y, vol * 200, vol * 200);  // Adjust size with volume
  }
}
"
"1975890","Firework Fest","mySketch","let fireworks = [];
let gravity;

function setup() {
  createCanvas(windowWidth, windowHeight);
  strokeWeight(4);
  background(0);
  gravity = createVector(0, 0.2);
}

function draw() {
  colorMode(RGB);
  background(0, 0, 0, 25);
  if (fireworks.length < 1 || random() < 0.03) {
    fireworks.push(new Firework());
  }
  for (let i = fireworks.length - 1; i >= 0; i--) {
    fireworks[i].update();
    fireworks[i].show();
    if (fireworks[i].done()) {
      fireworks.splice(i, 1);
    }
  }
}

function mousePressed() {
  fireworks.push(new Firework(mouseX, mouseY));
}

class Particle {
  constructor(pos, firework, hue) {
    this.pos = pos.copy();
    this.firework = firework;
    this.lifespan = 255;
    this.hue = hue;
    if (this.firework) {
      this.vel = createVector(0, random(-12, -8));
    } else {
      this.vel = p5.Vector.random2D();
      this.vel.mult(random(2, 10));
    }
    this.acc = createVector(0, 0);
  }

  applyForce(force) {
    this.acc.add(force);
  }

  update() {
    if (!this.firework) {
      this.vel.mult(0.9);
      this.lifespan -= 4;
    }
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  done() {
    return this.lifespan < 0;
  }

  show() {
    colorMode(HSB);
    if (!this.firework) {
      strokeWeight(2);
      stroke(this.hue, 255, 255, this.lifespan);
    } else {
      strokeWeight(4);
      stroke(this.hue, 255, 255);
    }
    point(this.pos.x, this.pos.y);
  }
}

class Firework {
  constructor(x, y) {
    this.hue = random(255);
    this.firework = new Particle(createVector(x, y), true, this.hue);
    this.exploded = false;
    this.particles = [];
  }

  done() {
    return this.exploded && this.particles.length === 0;
  }

  explode() {
    for (let i = 0; i < 100; i++) {
      let p = new Particle(this.firework.pos, false, this.hue);
      this.particles.push(p);
    }
  }

  update() {
    if (!this.exploded) {
      this.firework.applyForce(gravity);
      this.firework.update();
      if (this.firework.vel.y >= 0) {
        this.exploded = true;
        this.explode();
      }
    }
    for (let i = this.particles.length - 1; i >= 0; i--) {
      this.particles[i].applyForce(gravity);
      this.particles[i].update();
      if (this.particles[i].done()) {
        this.particles.splice(i, 1);
      }
    }
  }

  show() {
    if (!this.exploded) {
      this.firework.show();
    }
    for (let i = 0; i < this.particles.length; i++) {
      this.particles[i].show();
    }
  }
}
"
"1975889","Attraction Fest","mySketch","let particles = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
}

function draw() {
  background(0, 10); // Slowly fade out the background

  let mousePos = createVector(mouseX, mouseY);

  // Create new particles
  if (frameCount % 10 == 0) {
    particles.push(new Particle(random(width), random(height), random(255), random(255), random(255)));
  }

  // Update and display particles
  for (let i = particles.length-1; i >= 0; i--) {
    let p = particles[i];
    p.seek(mousePos);
    p.update();
    p.display();
    if (p.isDead()) {
      // Remove dead particles
      particles.splice(i, 1);
    }
  }
}

class Particle {
  constructor(x, y, r, g, b) {
    this.pos = createVector(x, y);
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.r = r;
    this.g = g;
    this.b = b;
    this.alpha = 255;
  }

  update() {
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.set(0, 0); // Reset acceleration
    this.alpha -= 2; // Fade out over time
  }

  display() {
    noStroke();
    fill(this.r, this.g, this.b, this.alpha);
    ellipse(this.pos.x, this.pos.y, 10, 10);
  }

  isDead() {
    return this.alpha < 0;
  }

  seek(target) {
    let force = p5.Vector.sub(target, this.pos);
    force.setMag(0.5); // Set force magnitude
    this.applyForce(force);
  }

  applyForce(force) {
    this.acc.add(force);
  }
}
"
"1975888","Fade away Fest","mySketch","let particles = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
}

function draw() {
  background(0, 10); // Slowly fade out the background

  // Create new particles
  for (let i = 0; i < 5; i++) {
    particles.push(new Particle(mouseX, mouseY, random(255), random(255), random(255)));
  }

  // Update and display particles
  for (let i = particles.length-1; i >= 0; i--) {
    let p = particles[i];
    p.update();
    p.display();
    if (p.isDead()) {
      // Remove dead particles
      particles.splice(i, 1);
    }
  }
}

class Particle {
  constructor(x, y, r, g, b) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.vel.mult(random(2, 5)); // Set initial velocity
    this.alpha = 255;
    this.r = r;
    this.g = g;
    this.b = b;
  }

  update() {
    this.alpha -= 2; // Fade out over time
    this.pos.add(this.vel);
  }

  display() {
    noStroke();
    fill(this.r, this.g, this.b, this.alpha);
    ellipse(this.pos.x, this.pos.y, 10, 10);
  }

  isDead() {
    return this.alpha < 0;
  }
}
"
"1975887","Fade away","mySketch","let particles = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(0);
}

function draw() {
  background(0, 10); // Slowly fade out the background

  // Create new particles
  for (let i = 0; i < 5; i++) {
    particles.push(new Particle(mouseX, mouseY));
  }

  // Update and display particles
  for (let i = particles.length-1; i >= 0; i--) {
    let p = particles[i];
    p.update();
    p.display();
    if (p.isDead()) {
      // Remove dead particles
      particles.splice(i, 1);
    }
  }
}

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.vel.mult(random(2, 5)); // Set initial velocity
    this.alpha = 255;
  }

  update() {
    this.alpha -= 2; // Fade out over time
    this.pos.add(this.vel);
  }

  display() {
    noStroke();
    fill(255, this.alpha);
    ellipse(this.pos.x, this.pos.y, 10, 10);
  }

  isDead() {
    return this.alpha < 0;
  }
}
"
"1975884","Gravity effects","mySketch","let balls = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  frameRate(1); // Make the simulation run slower
}

function draw() {
  background(200);

  // Add new balls every second
  if (frameCount % 1 == 0) { // Since we reduced the frame rate to 1, we need to adjust this too
    for (let i = 0; i < 3; i++) {
      balls.push(new Ball(random(width), random(height), color(255, 0, 0), 10));
      balls.push(new Ball(random(width), random(height), color(0, 255, 0), 10));
    }
  }

  // Update and display balls
  for (let i = 0; i < balls.length; i++) {
    let ball = balls[i];

    for (let j = i+1; j < balls.length; j++) {
      let other = balls[j];

      let force = p5.Vector.sub(other.pos, ball.pos);
      let distance = force.mag();
      let radiiSum = ball.radius + other.radius;

      if (distance < radiiSum) {
        // Balls are touching, merge them
        if (ball.col == other.col) {
          // Same color balls attract each other
          ball.merge(other);
          balls.splice(j, 1); // Remove the other ball
          j--;
        } else {
          // Different color balls repel each other
          force.mult(-1);
        }
      }
      
      force.setMag(0.01 * ball.radius); // Set force magnitude proportional to size of the ball
      ball.applyForce(force);
    }

    ball.update();
    ball.display();
    ball.boundaries();
    
    if (ball.merges >= 10) {
      // Ball has merged 10 times, remove it
      balls.splice(i, 1);
      i--;
    }
  }
}

class Ball {
  constructor(x, y, col, radius) {
    this.pos = createVector(x, y);
    this.vel = createVector(0, 0);
    this.acc = createVector(0, 0);
    this.col = col;
    this.radius = radius;
    this.merges = 0;
  }

  applyForce(force) {
    this.acc.add(force);
  }

  update() {
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.set(0, 0); // Reset acceleration
  }

  display() {
    fill(this.col);
    noStroke();
    ellipse(this.pos.x, this.pos.y, this.radius * 2, this.radius * 2);
  }
  
  merge(other) {
    this.merges++;
    this.radius += other.radius * 0.5;
    if(this.merges < 10) {
      balls.push(new Ball(this.pos.x, this.pos.y, this.col, this.radius));
    }
  }
  
  boundaries() {
    if (this.pos.x > width - this.radius) {
      this.pos.x = width - this.radius;
      this.vel.x *= -1;
    } else if (this.pos.x < this.radius) {
      this.pos.x = this.radius;
      this.vel.x *= -1;
    }
    if (this.pos.y > height - this.radius) {
      this.pos.y = height - this.radius;
      this.vel.y *= -1;
    } else if (this.pos.y < this.radius) {
      this.pos.y = this.radius;
      this.vel.y *= -1;
    }
  }
}
"
"1975881","Fractal Forests","mySketch","let particles = [];

function setup() {
    createCanvas(windowWidth, windowHeight);
    for (let i = 0; i < 100; i++) {
        particles[i] = new Particle(random(width), random(height));
    }
}

function draw() {
    background(0);
    for (let i = 0; i < particles.length; i++) {
        particles[i].update();
        particles[i].display();
    }
}

class Particle {
    constructor(x, y) {
        this.pos = createVector(x, y);
        this.vel = createVector(random(-1, 1), random(-1, 1));
    }

    update() {
        this.pos.add(this.vel);
    }

    display() {
        fill(255);
        noStroke();
        ellipse(this.pos.x, this.pos.y, 10, 10);
    }
}
"
"1975880","Boids","mySketch","let boids = [];

function setup() {
  createCanvas(720, 400);
  for (let i = 0; i < 100; i++) {
    boids[i] = new Boid(random(width), random(height));
  }
}

function draw() {
  background(51);
  for (let i = 0; i < boids.length; i++) {
    boids[i].run(boids);
  }
}

class Boid {
  constructor(x, y) {
    this.acceleration = createVector(0, 0);
    this.velocity = p5.Vector.random2D();
    this.position = createVector(x, y);
    this.r = 3.0;
    this.maxspeed = 3;
    this.maxforce = 0.05;
  }

  run(boids) {
    this.flock(boids);
    this.update();
    this.borders();
    this.render();
  }

  applyForce(force) {
    this.acceleration.add(force);
  }

  flock(boids) {
    let sep = this.separate(boids);
    let ali = this.align(boids);
    let coh = this.cohesion(boids);
    sep.mult(2.5);
    ali.mult(1.0);
    coh.mult(1.0);
    this.applyForce(sep);
    this.applyForce(ali);
    this.applyForce(coh);
  }

  update() {
    this.velocity.add(this.acceleration);
    this.velocity.limit(this.maxspeed);
    this.position.add(this.velocity);
    this.acceleration.mult(0);
  }

  seek(target) {
    let desired = p5.Vector.sub(target, this.position);
    desired.normalize();
    desired.mult(this.maxspeed);
    let steer = p5.Vector.sub(desired, this.velocity);
    steer.limit(this.maxforce);
    return steer;
  }

  render() {
    fill(255, 50);
    stroke(255);
    ellipse(this.position.x, this.position.y, 16, 16);
  }

  borders() {
    if (this.position.x < -this.r) this.position.x = width + this.r;
    if (this.position.y < -this.r) this.position.y = height + this.r;
    if (this.position.x > width + this.r) this.position.x = -this.r;
    if (this.position.y > height + this.r) this.position.y = -this.r;
  }

  separate(boids) {
    let desiredseparation = 25.0;
    let steer = createVector(0, 0);
    let count = 0;
    for (let i = 0; i < boids.length; i++) {
      let d = p5.Vector.dist(this.position, boids[i].position);
      if ((d > 0) && (d < desiredseparation)) {
        let diff = p5.Vector.sub(this.position, boids[i].position);
        diff.normalize();
        diff.div(d);
        steer.add(diff);
        count++;
      }
    }
    if (count > 0) {
      steer.div(count);
    }

    if (steer.mag() > 0) {
      steer.normalize();
      steer.mult(this.maxspeed);
      steer.sub(this.velocity);
      steer.limit(this.maxforce);
    }
    return steer;
  }

  align(boids) {
    let neighbordist = 50;
    let sum = createVector(0, 0);
    let count = 0;
    for (let i = 0; i < boids.length; i++) {
      let d = p5.Vector.dist(this.position, boids[i].position);
      if ((d > 0) && (d < neighbordist)) {
        sum.add(boids[i].velocity);
        count++;
      }
    }
    if (count > 0) {
      sum.div(count);
      sum.normalize();
      sum.mult(this.maxspeed);
      let steer = p5.Vector.sub(sum, this.velocity);
      steer.limit(this.maxforce);
      return steer;
    } else {
      return createVector(0, 0);
    }
  }

  cohesion(boids) {
    let neighbordist = 50;
    let sum = createVector(0, 0);
    let count = 0;
    for (let i = 0; i < boids.length; i++) {
      let d = p5.Vector.dist(this.position, boids[i].position);
      if ((d > 0) && (d < neighbordist)) {
        sum.add(boids[i].position);
        count++;
      }
    }
    if (count > 0) {
      sum.div(count);
      return this.seek(sum);
    } else {
      return createVector(0, 0);
    }
  }
}
"
"1975649","Interactive Light Show","mySketch","let angle = 0;
let rotateTorus = false;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  colorMode(HSB, 360, 100, 100);
  noStroke();
}

function draw() {
  background(0);
  let locX = mouseX - height / 2;
  let locY = mouseY - width / 2;

  // Set point lights with different colors
  pointLight(0, 100, 100, locX, locY, 200);
  pointLight(100, 100, 100, -locX, -locY, -200);

  // Visual representation of point lights
  push();
  translate(locX, locY, 200);
  fill(0, 100, 100);
  sphere(50); // Increased sphere size
  pop();

  push();
  translate(-locX, -locY, -200);
  fill(100, 100, 100);
  sphere(50); // Increased sphere size
  pop();

  // Rotate the torus
  if (rotateTorus) {
    rotateX(frameCount * 0.01);
    rotateY(frameCount * 0.01);
  }

  // Draw the torus
  normalMaterial();
  torus(100, 25);

  angle += 0.03;
}

function mousePressed() {
  rotateTorus = !rotateTorus;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"1975648","3d particle system","mySketch","let particles = [];

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  colorMode(HSB);
}

function draw() {
  background(0);
  rotateX(PI/4);
  rotateY(millis() / 5000);
  
  if (random(1) < 0.1 && particles.length < 500) {
    particles.push(new Particle(0, 0, 0));
  }
  
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].show();
    
    if (particles[i].finished()) {
      particles.splice(i, 1);
    }
  }
}

class Particle {
  constructor(x, y, z) {
    this.pos = createVector(x, y, z);
    this.vel = p5.Vector.random3D();
    this.vel.mult(random(0.5, 2));
    this.acc = createVector(0, 0, 0);
    this.lifespan = 255;
    this.hue = random(360);
  }
  
  finished() {
    return this.lifespan < 0;
  }
  
  applyForce(force) {
    this.acc.add(force);
  }
  
  update() {
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
    
    if (this.vel.mag() < 1) {
      this.lifespan -= 5;
    }
    
    this.vel.limit(5);
    this.hue += 0.1;
    if (this.hue > 360) {
      this.hue = 0;
    }
  }
  
  show() {
    noStroke();
    fill(this.hue, 255, 255, this.lifespan);
    push();
    translate(this.pos.x, this.pos.y, this.pos.z);
    sphere(4);
    pop();
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"1975647","3d fractal tree","mySketch","let angle;
let slider;

function setup() {
  createCanvas(windowWidth, windowHeight);
  slider = createSlider(0, TWO_PI, PI / 4, 0.01);
  colorMode(HSB);
}

function draw() {
  background(51);
  angle = map(mouseX, 0, width, 0, TWO_PI);
  let len = 150;
  let weight = 15;
  
  translate(width / 2, height);
  stroke(255);
  
  branch(len, weight);
}

function branch(len, weight) {
  strokeWeight(weight);
  let colorHue = map(len, 0, 200, 0, 255);
  stroke(colorHue, 255, 255);
  
  line(0, 0, 0, -len);
  translate(0, -len);
  
  if(len > 4) {
    push();
    rotate(angle);
    branch(len * 0.67, weight * 0.67);
    pop();
    
    push();
    rotate(-angle);
    branch(len * 0.67, weight * 0.67);
    pop();
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"1975646","3d spiral","mySketch","let angle = 0;
let w = 24;
let ma;
let maxD;
let rotationSpeed = 0.01;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  ma = atan(cos(QUARTER_PI));
  maxD = dist(0, 0, 200, 200);
}

function draw() {
  background(100);
  ortho(-400, 400, 400, -400, 0, 1000);

  rotateX(-QUARTER_PI);
  rotateY(ma);

  let offset = 0;
  for (let z = 0; z < height; z += w) {
    for (let x = 0; x < width; x += w) {
      push();
      let d = dist(x, z, width / 2, height / 2);
      let offset = map(d, 0, maxD, -PI, PI);
      let a = angle + offset;
      let h = floor(map(sin(a), -1, 1, 100, 300));
      translate(x - width / 2, 0, z - height / 2);
      normalMaterial();
      box(w - 2, h, w - 2);
      pop();
    }
  }

  angle -= rotationSpeed;
}

function touchMoved() {
  // Change rotation speed based on touch or mouse movement
  rotationSpeed = map(mouseX, 0, width, 0.01, 0.05);

  return false; // This prevents the default browser behavior for the touchmove event
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"1975645","3d box","mySketch","let angle = 0;
let colorR = 255;
let colorG = 0;
let colorB = 0;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
}

function draw() {
  background(200);
  
  rotateX(angle);
  rotateY(angle);
  rotateZ(angle);

  fill(colorR, colorG, colorB);
  box(100);
  
  angle += 0.01;
}

function touchStarted() {
  // Change color when touched or clicked
  colorR = random(255);
  colorG = random(255);
  colorB = random(255);
  
  return false; // This prevents the default browser behavior for the touch event
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"1975615","Shooting balls","mySketch.js","let Engine = Matter.Engine,
    World = Matter.World,
    Bodies = Matter.Bodies;

let engine;
let world;
let projectiles = [];
let obstacles = [];
let score = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  engine = Engine.create();
  world = engine.world;
}

function draw() {
  background(0);
  Engine.update(engine);

  // Create a new obstacle every 60 frames
  if (frameCount % 60 === 0) {
    let o = new Obstacle(random(width), 0, random(10, 50));
    obstacles.push(o);
  }

  // Display all projectiles
  for (let i = projectiles.length - 1; i >= 0; i--) {
    projectiles[i].show();
    if (projectiles[i].isOffScreen()) {
      projectiles[i].removeFromWorld();
      projectiles.splice(i, 1);
    }
  }

  // Display all obstacles and check for collisions
  for (let i = obstacles.length - 1; i >= 0; i--) {
    obstacles[i].show();
    if (obstacles[i].isOffScreen()) {
      obstacles[i].removeFromWorld();
      obstacles.splice(i, 1);
    } else {
      for (let j = projectiles.length - 1; j >= 0; j--) {
        if (obstacles[i].body.circleRadius + projectiles[j].body.circleRadius >
            dist(obstacles[i].body.position.x, obstacles[i].body.position.y,
                 projectiles[j].body.position.x, projectiles[j].body.position.y)) {
          obstacles[i].removeFromWorld();
          obstacles.splice(i, 1);
          projectiles[j].removeFromWorld();
          projectiles.splice(j, 1);
          score++;
          break;
        }
      }
    }
  }

  // Display the score
  fill(255);
  textSize(32);
  text(""Score: "" + score, 10, 50);
}

function touchStarted() {
  let p = new Projectile(width / 2, height, 10, mouseX, mouseY);
  projectiles.push(p);
  return false;
}

function Projectile(x, y, r, targetX, targetY) {
  let options = {
    restitution: 0.5
  };
  this.body = Bodies.circle(x, y, r, options);
  this.r = r;
  World.add(world, this.body);

  let angle = atan2(targetY - y, targetX - x);
  Matter.Body.setVelocity(this.body, {x: 20 * cos(angle), y: 20 * sin(angle)}); // Increased velocity

  this.show = function() {
    let pos = this.body.position;
    push();
    translate(pos.x, pos.y);
    fill(0, 255, 0);
    ellipse(0, 0, this.r * 2);
    pop();
  };

  this.isOffScreen = function() {
    let pos = this.body.position;
    return (pos.y < 0);
  };

  this.removeFromWorld = function() {
    World.remove(world, this.body);
  };
}

function Obstacle(x, y, r) {
  let options = {
    restitution: 0.5
  };
  this.body = Bodies.circle(x, y, r, options);
  this.r = r;
  World.add(world, this.body);

  this.show = function() {
    let pos = this.body.position;
    push();
    translate(pos.x, pos.y);
    fill(255, 0, 0);
    ellipse(0, 0, this.r * 2);
    pop();
  };

  this.isOffScreen = function() {
    let pos = this.body.position;
    return (pos.y > height);
  };

  this.removeFromWorld = function() {
    World.remove(world, this.body);
  };
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"1975605","Fourier noises","mySketch","let time = 0;
let wave = [];
let slider;
let osc;

function setup() {
  createCanvas(windowWidth, windowHeight);
  slider = createSlider(1, 10, 5);
  osc = new p5.Oscillator();
  osc.setType('sine');
  osc.freq(1);
  osc.amp(0.5);
  osc.start();
}

function draw() {
  background(0);
  translate(width / 4, height / 2);

  let x = 0;
  let y = 0;

  for (let i = 0; i < slider.value(); i++) {
    let prevx = x;
    let prevy = y;

    let n = i * 2 + 1;
    let radius = 75 * (4 / (n * PI));
    x += radius * cos(n * time);
    y += radius * sin(n * time);

    stroke(255, 100);
    noFill();
    ellipse(prevx, prevy, radius * 2);

    fill(255);
    stroke(255);
    line(prevx, prevy, x, y);
    ellipse(x, y, 8);
  }

  wave.unshift(y);

  translate(200, 0);
  line(x - 200, y, 0, wave[0]);

  beginShape();
  noFill();
  for (let i = 0; i < wave.length; i++) {
    vertex(i, wave[i]);
  }
  endShape();

  let freq = map(y, -height / 2, height / 2, 400, 1000);
  osc.freq(freq);

  time += 0.05;

  if (wave.length > width / 2) {
    wave.pop();
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"1975595","Bounce around","mySketch.js","let engine;
let world;
let circles = [];
let oscs = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  engine = Matter.Engine.create();
  world = engine.world;
}

function draw() {
  background(0);
  Matter.Engine.update(engine);
  for (let i = 0; i < circles.length; i++) {
    circles[i].show();
    if (circles[i].isOffScreen()) {
      circles[i].removeFromWorld();
      circles.splice(i, 1);
      oscs[i].stop();
      oscs.splice(i, 1);
      i--;
    }
  }
}

function touchStarted() {
  let r = random(10, 50);
  let c = new Circle(mouseX, mouseY, r);
  circles.push(c);
  let osc = new p5.Oscillator();
  osc.setType('sine');
  osc.freq(map(mouseY, 0, height, 400, 1000));
  osc.amp(0.5);
  osc.start();
  oscs.push(osc);
  return false;
}

function Circle(x, y, r) {
  let options = {
    friction: 0,
    restitution: 0.95
  };
  this.body = Matter.Bodies.circle(x, y, r, options);
  this.r = r;
  this.x = x;
  this.y = y;
  this.color = [random(0, 255), random(0, 255), random(0, 255)];
  
  Matter.World.add(world, this.body);

  this.isOffScreen = function() {
    let pos = this.body.position;
    return (pos.y > height + 100);
  };

  this.removeFromWorld = function() {
    Matter.World.remove(world, this.body);
  };

  this.show = function() {
    let pos = this.body.position;
    push();
    translate(pos.x, pos.y);
    fill(this.color);
    ellipse(0, 0, this.r * 2);
    pop();
  };
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"1975592","Circle sounds","mySketch.js","let osc;
let backgroundColor;

function setup() {
  createCanvas(windowWidth, windowHeight);
  backgroundColor = color(255, 0, 0);

  // Initialize the oscillator
  osc = new p5.Oscillator('sine');
}

function draw() {
  background(backgroundColor);
  fill(255);
  circle(mouseX, mouseY, 80);
}

function touchStarted() {
  // Change the background color
  backgroundColor = color(random(255), random(255), random(255));

  // Play a sound
  osc.start();
  osc.freq(random(200, 800));
  osc.amp(0.5, 0.1);

  // Prevent default touch actions
  return false;
}

function touchEnded() {
  // Stop the sound
  osc.amp(0, 0.5);

  // Prevent default touch actions
  return false;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
"
"1975261","Tessellations","mySketch","let grid;
let cols, rows;
let cellSize = 20;
let colors;

function setup() {
  createCanvas(800, 800);
  cols = width / cellSize;
  rows = height / cellSize;

  colors = [color(255, 0, 0), color(0, 255, 0), color(0, 0, 255)];

  grid = new Array(cols);
  for (let i = 0; i < cols; i++) {
    grid[i] = new Array(rows);
    for (let j = 0; j < rows; j++) {
      grid[i][j] = random(colors);
    }
  }
}

function draw() {
  background(220);

  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      fill(grid[i][j]);
      stroke(0);
      rect(i * cellSize, j * cellSize, cellSize, cellSize);
    }
  }
}

function mousePressed() {
  let x = floor(mouseX / cellSize);
  let y = floor(mouseY / cellSize);

  if (x >= 0 && x < cols && y >= 0 && y < rows) {
    grid[x][y] = random(colors);
  }
}
"
"1975259","Harmonograph","mySketch","let t = 0;

let slider1, slider2, slider3, slider4;

function setup() {
  createCanvas(800, 800);
  slider1 = createSlider(1, 10, 5, 0.1);
  slider2 = createSlider(1, 10, 5, 0.1);
  slider3 = createSlider(0, TWO_PI, PI / 2, 0.01);
  slider4 = createSlider(0, TWO_PI, PI / 2, 0.01);
}

function draw() {
  background(0);
  translate(width / 2, height / 2);
  stroke(255);
  noFill();

  beginShape();
  for (let t = 0; t < 1000; t += 0.01) {
    let x = sin(t * slider1.value() + slider3.value()) * 200;
    let y = sin(t * slider2.value() + slider4.value()) * 200;
    vertex(x, y);
  }
  endShape();
}
"
"1975257","Gray-Scott model","mySketch","let grid, next;
let dA = 1.0;
let dB = 0.5;
let feed = 0.055;
let k = 0.062;

function setup() {
  createCanvas(200, 200);
  grid = [];
  next = [];
  for (let x = 0; x < width; x++) {
    grid[x] = [];
    next[x] = [];
    for (let y = 0; y < height; y++) {
      grid[x][y] = {a: 1, b: 0};
      next[x][y] = {a: 1, b: 0};
    }
  }
  for (let i = 90; i < 110; i++) {
    for (let j = 90; j < 110; j++) {
      grid[i][j].b = 1;
    }
  }
}

function draw() {
  background(51);
  loadPixels();
  for (let x = 1; x < width - 1; x++) {
    for (let y = 1; y < height - 1; y++) {
      let a = grid[x][y].a;
      let b = grid[x][y].b;
      next[x][y].a = a + 
        (dA * laplaceA(x, y)) - 
        (a * b * b) + 
        (feed * (1 - a));
      next[x][y].b = b + 
        (dB * laplaceB(x, y)) + 
        (a * b * b) - 
        ((k + feed) * b);
      next[x][y].a = constrain(next[x][y].a, 0, 1);
      next[x][y].b = constrain(next[x][y].b, 0, 1);
      
      let pix = (x + y * width) * 4;
      let c = floor((next[x][y].a - next[x][y].b) * 255);
      c = constrain(c, 0, 255);
      pixels[pix + 0] = c;
      pixels[pix + 1] = c;
      pixels[pix + 2] = c;
      pixels[pix + 3] = 255;
    }
  }
  updatePixels();
  swap();
}

function swap() {
  let temp = grid;
  grid = next;
  next = temp;
}

function laplaceA(x, y) {
  let sumA = 0;
  sumA += grid[x][y].a * -1;
  sumA += grid[x - 1][y].a * 0.2;
  sumA += grid[x + 1][y].a * 0.2;
  sumA += grid[x][y + 1].a * 0.2;
  sumA += grid[x][y - 1].a * 0.2;
  sumA += grid[x - 1][y - 1].a * 0.05;
  sumA += grid[x + 1][y - 1].a * 0.05;
  sumA += grid[x + 1][y + 1].a * 0.05;
  sumA += grid[x - 1][y + 1].a * 0.05;
  return sumA;
}

function laplaceB(x, y) {
  let sumB = 0;
  sumB += grid[x][y].b * -1;
  sumB += grid[x - 1][y].b * 0.2;
  sumB += grid[x + 1][y].b * 0.2;
  sumB += grid[x][y + 1].b * 0.2;
  sumB += grid[x][y - 1].b * 0.2;
  sumB += grid[x - 1][y - 1].b * 0.05;
  sumB += grid[x + 1][y - 1].b * 0.05;
  sumB += grid[x + 1][y + 1].b * 0.05;
  sumB += grid[x - 1][y + 1].b * 0.05;
  return sumB;
}
"
"1975252","Gravitational Attraction","mySketch","let bodies = [];
let nBodies = 100;
let G; // Gravitational constant
let slider;

function setup() {
  createCanvas(600, 600);
  G = 1;
  slider = createSlider(0.1, 10, 1, 0.1);
  for (let i = 0; i < nBodies; i++) {
    bodies[i] = createVector(random(width), random(height));
  }
}

function draw() {
  background(51);
  G = slider.value();
  for (let i = 0; i < nBodies; i++) {
    let acceleration = createVector(0, 0);
    for (let j = 0; j < nBodies; j++) {
      if (i !== j) {
        let force = p5.Vector.sub(bodies[j], bodies[i]);
        let distance = force.mag();
        force.normalize();
        force.mult(G / (distance * distance));
        acceleration.add(force);
      }
    }
    bodies[i].add(acceleration);
    if (bodies[i].x > width) bodies[i].x = 0;
    if (bodies[i].x < 0) bodies[i].x = width;
    if (bodies[i].y > height) bodies[i].y = 0;
    if (bodies[i].y < 0) bodies[i].y = height;
    fill(255);
    circle(bodies[i].x, bodies[i].y, 10); // Here I replaced `point()` with `circle()` and provided a radius of 10
  }
}
"
"1975250","Mandelbrot Set","mySketch","function setup() {
  createCanvas(400, 400);
  pixelDensity(1);
}

function draw() {
  let maxIter = 100;
  
  loadPixels();
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      let a = map(x, 0, width, -2, 2);
      let b = map(y, 0, height, -2, 2);
      let ca = a;
      let cb = b;

      let n = 0;
      while (n < maxIter) {
        let aa = a * a - b * b;
        let bb = 2 * a * b;
        a = aa + ca;
        b = bb + cb;
        if (abs(a * a + b * b) > 16) {
          break;
        }
        n++;
      }

      let bright = map(sqrt(n), 0, sqrt(maxIter), 0, 1);
      let pix = (x + y * width) * 4;
      pixels[pix + 0] = bright * 255;
      pixels[pix + 1] = bright * 70; // This value is adjusted to get a pink-ish color
      pixels[pix + 2] = bright * 150; // This value is adjusted to get a pink-ish color
      pixels[pix + 3] = 255;
    }
  }
  updatePixels();
}
"
"1975247","Lindenmayer system","mySketch","let angle;
let axiom = ""F"";
let sentence = axiom;
let len = 100;
let slider;

let rules = [];
rules[0] = {
  a: ""F"",
  b: ""FF+[+F-F-F]-[-F+F+F]""
};

function generate() {
  len *= 0.5;
  let nextSentence = """";
  for (let i = 0; i < sentence.length; i++) {
    let current = sentence.charAt(i);
    let found = false;
    for (let j = 0; j < rules.length; j++) {
      if (current == rules[j].a) {
        found = true;
        nextSentence += rules[j].b;
        break;
      }
    }
    if (!found) {
      nextSentence += current;
    }
  }
  sentence = nextSentence;
  turtle();
}

function turtle() {
  background(51);
  resetMatrix();
  translate(width / 2, height);
  stroke(255, 100);
  for (let i = 0; i < sentence.length; i++) {
    let current = sentence.charAt(i);

    if (current == ""F"") {
      line(0, 0, 0, -len);
      translate(0, -len);
    } else if (current == ""+"") {
      rotate(angle);
    } else if (current == ""-"") {
      rotate(-angle);
    } else if (current == ""["") {
      push();
    } else if (current == ""]"") {
      pop();
    }
  }
}

function setup() {
  createCanvas(400, 400);
  angle = radians(25);
  background(51);
  turtle();
  let button = createButton(""generate"");
  button.mousePressed(generate);
  slider = createSlider(0, TWO_PI, PI / 4, 0.01);
}

function draw() {
  angle = slider.value();
  background(51);
  turtle();
}
"
"1975244","Julia Set","mySketch","let slider;

function setup() {
  createCanvas(600, 600);
  pixelDensity(1);
  slider = createSlider(-2, 2, 0, 0.01);
}

function draw() {
  let ca = slider.value();
  let cb = slider.value();
  loadPixels();

  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      let a = map(x, 0, width, -2, 2);
      let b = map(y, 0, height, -2, 2);

      let n = 0;
      while (n < 100) {
        let aa = a * a - b * b;
        let bb = 2 * a * b;
        a = aa + ca;
        b = bb + cb;
        if (abs(a + b) > 16) {
          break;
        }
        n++;
      }

      let bright = map(n, 0, 100, 0, 1);
      bright = map(sqrt(bright), 0, 1, 0, 255);

      if (n === 100) {
        bright = 255;
      }

      let pix = (x + y * width) * 4;
      pixels[pix + 0] = bright;
      pixels[pix + 1] = bright;
      pixels[pix + 2] = bright;
      pixels[pix + 3] = 255;
    }
  }
  updatePixels();
}
"
"1975243","Cellular Automata","mySketch","let grid;
let cols;
let rows;
let resolution = 10;

function make2DArray(cols, rows) {
  let arr = new Array(cols);
  for (let i = 0; i < arr.length; i++) {
    arr[i] = new Array(rows);
  }
  return arr;
}

function setup() {
  createCanvas(600, 400);
  cols = width / resolution;
  rows = height / resolution;

  grid = make2DArray(cols, rows);
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      grid[i][j] = floor(random(2));
    }
  }
}

function draw() {
  background(0);

  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let x = i * resolution;
      let y = j * resolution;
      if (grid[i][j] == 1) {
        fill(255);
        stroke(0);
        rect(x, y, resolution - 1, resolution - 1);
      }
    }
  }

  let next = make2DArray(cols, rows);

  // Compute next based on grid
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let state = grid[i][j];
      // Count live neighbors!
      let sum = 0;
      let neighbors = countNeighbors(grid, i, j);

      if (state == 0 && neighbors == 3) {
        next[i][j] = 1;
      } else if (state == 1 && (neighbors < 2 || neighbors > 3)) {
        next[i][j] = 0;
      } else {
        next[i][j] = state;
      }
    }
  }

  grid = next;
}

function countNeighbors(grid, x, y) {
  let sum = 0;
  for (let i = -1; i < 2; i++) {
    for (let j = -1; j < 2; j++) {
      let col = (x + i + cols) % cols;
      let row = (y + j + rows) % rows;
      sum += grid[col][row];
    }
  }
  sum -= grid[x][y];
  return sum;
}
"
"1975242","Fourier Series/ Epicycle","mySketch","let time = 0;
let wave = [];
let slider;

function setup() {
  createCanvas(800, 400);
  slider = createSlider(1, 10, 5);
}

function draw() {
  background(0);
  translate(200, 200);

  let x = 0;
  let y = 0;

  for (let i = 0; i < slider.value(); i++) {
    prevx = x;
    prevy = y;

    let n = i * 2 + 1;
    let radius = 75 * (4 / (n * PI));
    x += radius * cos(n * time);
    y += radius * sin(n * time);

    stroke(255, 100);
    noFill();
    ellipse(prevx, prevy, radius * 2);

    fill(255);
    stroke(255);
    line(prevx, prevy, x, y);
    ellipse(x, y, 8);
  }

  wave.unshift(y);

  translate(200, 0);
  line(x - 200, y, 0, wave[0]);

  beginShape();
  noFill();
  for (let i = 0; i < wave.length; i++) {
    vertex(i, wave[i]);
  }
  endShape();

  time += 0.05;

  if (wave.length > 250) {
    wave.pop();
  }
}
"
"1975241","Red and Green festival","mySketch","let particles = [];

class Particle {
  constructor(x, y, color) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.color = color;
    this.size = 10;
    this.aggregations = 0;
  }

  update() {
    particles.forEach(particle => {
      if (particle !== this && particle.color === this.color) {
        let force = p5.Vector.sub(this.pos, particle.pos);
        let distanceSq = force.magSq();
        force.normalize();
        force.mult(500 * this.size / distanceSq); // Attraction force proportional to size
        if (distanceSq < (this.size + particle.size) ** 2) { // If particles are too close
          force.mult(-1); // Apply repulsion
        }
        this.vel.add(force);
      }
    });

    this.vel.limit(2);
    this.pos.add(this.vel);

    // Contain within boundaries
    if (this.pos.x < this.size / 2) {
      this.pos.x = this.size / 2;
      this.vel.x *= -1;
    } else if (this.pos.x > width - this.size / 2) {
      this.pos.x = width - this.size / 2;
      this.vel.x *= -1;
    }
    if (this.pos.y < this.size / 2) {
      this.pos.y = this.size / 2;
      this.vel.y *= -1;
    } else if (this.pos.y > height - this.size / 2) {
      this.pos.y = height - this.size / 2;
      this.vel.y *= -1;
    }
  }

  show() {
    noStroke();
    fill(this.color === 'red' ? 'rgb(255, 0, 0)' : 'rgb(0, 255, 0)');
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  checkAggregation() {
    particles.forEach(particle => {
      if (particle !== this && particle.color === this.color) {
        let distance = p5.Vector.dist(this.pos, particle.pos);
        if (distance < (this.size / 2 + particle.size / 2)) {
          this.aggregations++;
          this.size += 2; // Increase size with each aggregation
          if (this.aggregations >= 10) {
            this.explode();
          }
        }
      }
    });
  }

  explode() {
    // Remove this particle from the array
    particles = particles.filter(particle => particle !== this);
  }
}

function setup() {
  createCanvas(800, 800);
}

function draw() {
  background(0);
  
  if (random() < 0.03) { // Occasionally add new particles
    let x = random(width);
    let y = random(height);
    let color = random() < 0.5 ? 'red' : 'green';
    particles.push(new Particle(x, y, color));
  }

  particles.forEach(particle => {
    particle.update();
    particle.show();
    particle.checkAggregation();
  });
}
"
"1975235","Red repulsion","mySketch","let particles = [];

class Particle {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.size = 10;
    this.aggregations = 0;
  }

update() {
  particles.forEach(particle => {
    if (particle !== this) {
      let force = p5.Vector.sub(this.pos, particle.pos);
      let distanceSq = force.magSq();
      force.normalize();
      force.mult(500 * this.size / distanceSq); // Attraction force proportional to size
      if (distanceSq < (this.size + particle.size) ** 2) { // If particles are too close
        force.mult(-1); // Apply repulsion
      }
      this.vel.add(force);
    }
  });

  this.vel.limit(2);
  this.pos.add(this.vel);

  // Contain within boundaries
  if (this.pos.x < this.size / 2) {
    this.pos.x = this.size / 2;
    this.vel.x *= -1;
  } else if (this.pos.x > width - this.size / 2) {
    this.pos.x = width - this.size / 2;
    this.vel.x *= -1;
  }
  if (this.pos.y < this.size / 2) {
    this.pos.y = this.size / 2;
    this.vel.y *= -1;
  } else if (this.pos.y > height - this.size / 2) {
    this.pos.y = height - this.size / 2;
    this.vel.y *= -1;
  }
}


  show() {
    noStroke();
    fill(255, 0, 0);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

checkAggregation() {
  particles.forEach(particle => {
    if (particle !== this) {
      let distance = p5.Vector.dist(this.pos, particle.pos);
      if (distance < (this.size / 2 + particle.size / 2)) {
        this.aggregations++;
        this.size += 2; // Increase size with each aggregation
        if (this.aggregations >= 10) {
          this.explode();
        }
      }
    }
  });
}

  explode() {
    // Remove this particle from the array
    particles = particles.filter(particle => particle !== this);
  }
}

function setup() {
  createCanvas(800, 800);
  stroke(255);
  noFill();
  rect(0, 0, width, height);
}

function draw() {
  background(0);
  
  if (random() < 0.3) { // Occasionally add new particles
    let x = random(width);
    let y = random(height);
    particles.push(new Particle(x, y));
  }

  particles.forEach(particle => {
    particle.update();
    particle.show();
    particle.checkAggregation();
  });
  
  noFill();
  stroke(255);
  rect(0, 0, width, height); // Draw the white boundary
}
"
"1975233","Anti-gravity explosion","mySketch","let particles = [];

class Particle {
  constructor(x, y, color) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D();
    this.color = color;
    this.aggregations = 0;
    this.sizes = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55];
    this.size = this.sizes[this.aggregations];
  }

  update() {
    particles.forEach(particle => {
      if (particle !== this) {
        let force = p5.Vector.sub(this.pos, particle.pos);
        let distanceSq = force.magSq();
        force.normalize();

        if (this.color === 'red' && particle.color === 'red') {
          force.mult(500 * this.size / distanceSq); // Attraction force proportional to size
        } else {
          force.mult(-500 * this.size / distanceSq); // Repulsion force proportional to size
        }
        this.vel.add(force);
      }
    });

    this.vel.limit(2);
    this.pos.add(this.vel);

    // Reflect off boundaries
    if (this.pos.x < 0 || this.pos.x > width) {
      this.vel.x *= -1;
    }
    if (this.pos.y < 0 || this.pos.y > height) {
      this.vel.y *= -1;
    }
  }

  show() {
    noStroke();
    if (this.color === 'red') fill(255, 0, 0);
    else fill(0, 255, 0);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  checkAggregation() {
    particles.forEach(particle => {
      if (particle !== this && particle.color === 'red' && this.color === 'red') {
        let distance = p5.Vector.dist(this.pos, particle.pos);
        if (distance < this.size / 2) {
          this.aggregations++;
          if (this.aggregations < this.sizes.length) {
            this.size = this.sizes[this.aggregations]; // Update size based on number of aggregations
          }
          if (this.aggregations >= 10) {
            this.explode();
          }
        }
      }
    });
  }

  explode() {
    // Remove this particle from the array
    particles = particles.filter(particle => particle !== this);
  }
}

function setup() {
  createCanvas(800, 800);
}

function draw() {
  background(0);
  
  if (random() < 0.03) { // Occasionally add new particles
    let x = random(width);
    let y = random(height);
    let color = random() < 0.5 ? 'red' : 'green';
    particles.push(new Particle(x, y, color));
  }

  particles.forEach(particle => {
    particle.update();
    particle.show();
    particle.checkAggregation();
  });
}
"
"1975232","Stuck particles","mySketch","let particles = [];
let stuck = [];

function setup() {
  createCanvas(800, 800);
  background(0);
  particles.push(new Particle(width / 2, height / 2, true));
}

function draw() {
  background(0);

  let total = 2;
  for (let i = 0; i < total; i++) {
    particles.push(new Particle(random(width), random(height), false));
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    let particle = particles[i];

    particle.update();
    particle.show();

    if (particle.isStuck(stuck)) {
      particle.size += 2; // Increase the size of the particle when it gets stuck
      stuck.push(particle);
      particles.splice(i, 1);
    }
  }
}

class Particle {
  constructor(x, y, stuck) {
    this.x = x;
    this.y = y;
    this.stuck = stuck;
    this.size = 2;
  }

  update() {
    this.x += random(-1, 1);
    this.y += random(-1, 1);
  }

  show() {
    noStroke();
    if (this.stuck) fill(255, 0, 0);
    else fill(255);
    ellipse(this.x, this.y, this.size);
  }

  isStuck(others) {
    for (let other of others) {
      let d = dist(this.x, this.y, other.x, other.y);
      if (d < this.size / 2) {
        this.stuck = true;
        return true;
      }
    }
    return false;
  }
}
"
"1975231","Diffusion-Limited Aggregation","mySketch","let particles = [];
let stuck = [];

function setup() {
  createCanvas(800, 800);
  background(0);
  particles.push(new Particle(width / 2, height / 2, true));
}

function draw() {
  background(0);

  let total = 2;
  for (let i = 0; i < total; i++) {
    particles.push(new Particle(random(width), random(height), false));
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    let particle = particles[i];

    particle.update();
    particle.show();

    if (particle.isStuck(stuck)) {
      stuck.push(particle);
      particles.splice(i, 1);
    }
  }
}

class Particle {
  constructor(x, y, stuck) {
    this.x = x;
    this.y = y;
    this.stuck = stuck;
  }

  update() {
    this.x += random(-1, 1);
    this.y += random(-1, 1);
  }

  show() {
    noStroke();
    if (this.stuck) fill(255, 0, 0);
    else fill(255);
    ellipse(this.x, this.y, 2);
  }

  isStuck(others) {
    for (let other of others) {
      let d = dist(this.x, this.y, other.x, other.y);
      if (d < 2) {
        this.stuck = true;
        return true;
      }
    }
    return false;
  }
}
"
"1975227","i-Time Tables","mySketch","function setup() {
  createCanvas(800, 800);
  angleMode(DEGREES); // Change the angle mode to DEGREES
  colorMode(HSB, 255); // Change the color mode to HSB and set the maximum hue value to 255
}

function draw() {
  background(0);
  translate(width / 2, height / 2);
  
  let totalPoints = 200;
  let radius = width / 2 - 50;
  
  // Use the mouse position to control the multiplication factor
  let factor = map(mouseX, 0, width, 0, 2);
  
  // Draw the points on the circle
  for (let i = 0; i < totalPoints; i++) {
    let angle = map(i, 0, totalPoints, 0, 360);
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    point(x, y);
  }
  
  // Draw the lines between the points
  for (let i = 0; i < totalPoints; i++) {
    let startAngle = map(i, 0, totalPoints, 0, 360);
    let endAngle = map((i * factor) % totalPoints, 0, totalPoints, 0, 360);
    
    let startX = radius * cos(startAngle);
    let startY = radius * sin(startAngle);
    
    let endX = radius * cos(endAngle);
    let endY = radius * sin(endAngle);
    
    // Color each line differently
    stroke((i + frameCount) % 255, 255, 255);
    line(startX, startY, endX, endY);
  }
}
"
"1975225","Times Tables on a Circle","mySketch","let factor = 0;

function setup() {
  createCanvas(800, 800);
  angleMode(DEGREES); // Change the angle mode to DEGREES
  colorMode(HSB);
}

function draw() {
  background(0);
  translate(width / 2, height / 2);
  stroke(255);
  
  let totalPoints = 200;
  let radius = width / 2 - 50;
  
  // Draw the points on the circle
  for (let i = 0; i < totalPoints; i++) {
    let angle = map(i, 0, totalPoints, 0, 360);
    let x = radius * cos(angle);
    let y = radius * sin(angle);
    point(x, y);
  }
  
  // Draw the lines between the points
  for (let i = 0; i < totalPoints; i++) {
    let startAngle = map(i, 0, totalPoints, 0, 360);
    let endAngle = map((i * factor) % totalPoints, 0, totalPoints, 0, 360);
    
    let startX = radius * cos(startAngle);
    let startY = radius * sin(startAngle);
    
    let endX = radius * cos(endAngle);
    let endY = radius * sin(endAngle);
    
    stroke(i, 255, 255);
    line(startX, startY, endX, endY);
  }
  
  factor += 0.005;
}
"
"1975223","Sierpinski chaos triangle","mySketch","let points = [];
let current;

function setup() {
  createCanvas(800, 800);
  background(0);
  colorMode(HSB);
  current = createVector(random(width), random(height));
}

function draw() {
  if (points.length > 0) {
    for (let i = 0; i < 100; i++) {
      let next = random(points);
      stroke(next.color);
      strokeWeight(2);
      current.x = lerp(current.x, next.x, 0.5);
      current.y = lerp(current.y, next.y, 0.5);
      point(current.x, current.y);
    }
  }
}

function mousePressed() {
  let point = createVector(mouseX, mouseY);
  point.color = color(random(360), 255, 255);
  points.push(point);
}
"
"1975221","Mandelbrot set","mySketch","let zoom = 1;
let panX = 0;
let panY = 0;

function setup() {
  createCanvas(800, 800);
  pixelDensity(1);
}

function draw() {
  loadPixels();
  
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      let a = map(x, 0, width, -2.5 * zoom + panX, 2.5 * zoom + panX);
      let b = map(y, 0, height, -2.5 * zoom + panY, 2.5 * zoom + panY);
      
      let ca = a;
      let cb = b;
      
      let n = 0;
      let maxIter = 100;
      
      while (n < maxIter) {
        let aa = a * a - b * b;
        let bb = 2 * a * b;
        a = aa + ca;
        b = bb + cb;
        if (abs(a + b) > 16) {
          break;
        }
        n++;
      }
      
      let hue = sqrt(map(n, 0, maxIter, 0, 1)) * 360; // Map the number of iterations to a hue value
      
      let pix = (x + y * width) * 4;
      if (n === maxIter) {
        pixels[pix + 0] = 0;
        pixels[pix + 1] = 0;
        pixels[pix + 2] = 0;
      } else {
        let c = color(hue, 100, 100); // Convert the hue to an RGB color
        pixels[pix + 0] = red(c);
        pixels[pix + 1] = green(c);
        pixels[pix + 2] = blue(c);
      }
      pixels[pix + 3] = 255;
    }
  }
  updatePixels();
}

function mouseDragged() {
  panX += (pmouseX - mouseX) / (width / 4) * zoom;
  panY += (pmouseY - mouseY) / (height / 4) * zoom;
  redraw();
}

function mouseWheel(event) {
  zoom *= pow(1.001, event.delta);
  redraw();
}
"
"1975219","Lissajous curve","mySketch","let t = 0;

function setup() {
  createCanvas(800, 800);
  background(0);
  colorMode(HSB, 255); // Change the color mode to HSB and set the maximum hue value to 255
}

function draw() {
  background(0, 0.01); // Semi-transparent background (creates trails)
  translate(width / 2, height / 2); // Move the origin to the center of the canvas

  let a = mouseX / 50; // Use the mouse position to control the frequency of the oscillation along the x axis
  let b = mouseY / 50; // Use the mouse position to control the frequency of the oscillation along the y axis
  let x = 300 * sin(a * t); // Increase the scaling factor to make the curve larger
  let y = 300 * sin(b * t); // Increase the scaling factor to make the curve larger
  
  stroke(frameCount % 255, 255, 255); // Use frameCount to shift the hue over time, creating a rainbow effect
  strokeWeight(6);
  point(x, y);

  t += 0.01; // Increase time
}
"
"1975217","Fibonacci spiral","mySketch","let fibs = [0, 1];

function setup() {
  createCanvas(800, 800);
  background(0);
  angleMode(DEGREES); // Change the mode to DEGREES
  colorMode(HSB);
  noFill();
  
  // Generate the first 30 Fibonacci numbers
  for (let i = 2; i < 30; i++) {
    fibs[i] = fibs[i - 1] + fibs[i - 2];
  }
}

function draw() {
  background(0);
  
  // Draw the Fibonacci Spiral
  translate(width / 2, height / 2); // Move the origin to the center of the canvas
  let numSpirals = map(mouseX, 0, width, 1, 30); // Map the mouse x position to the number of spirals
  for (let i = 0; i < numSpirals; i++) {
    let radius = fibs[i] * 10; // Scale up the size for better visibility
    stroke(i * 8, 255, 255); // Color each circle differently
    strokeWeight(3); // Make the lines thicker
    if (i % 4 === 0) {
      arc(-radius / 2, -radius / 2, radius, radius, 0, 90);
    } else if (i % 4 === 1) {
      arc(radius / 2, -radius / 2, radius, radius, 90, 180);
    } else if (i % 4 === 2) {
      arc(radius / 2, radius / 2, radius, radius, 180, 270);
    } else if (i % 4 === 3) {
      arc(-radius / 2, radius / 2, radius, radius, 270, 360);
    }
  }
}
"
"1975215","Swirling effect","mySketch","let flowfield;
let particles = [];
let zoff = 0;
let clickCount = 0;

function setup() {
  createCanvas(800, 800);
  colorMode(HSB, 255);
  background(0);
  flowfield = new FlowField(20);
  for (let i = 0; i < 500; i++) {
    particles.push(new Particle(random(width), random(height), random(255)));
  }
}

function draw() {
  background(0, 0.05); // Semi-transparent background (creates trails)
  
  // Update and display particles
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].follow(flowfield);
    particles[i].update();
    particles[i].edges();
    particles[i].show();
  }

  // Update flow field
  flowfield.update();
}

function mousePressed() {
  clickCount++;
  
  // Reset the sketch when the mouse is clicked for the third time
  if (clickCount % 5 == 0) {
    particles = [];
    background(0);
  } else {
    // Add new particles when the mouse is pressed
    for (let i = 0; i < 50; i++) {
      particles.push(new Particle(mouseX, mouseY, random(255)));
    }
  }
}

function FlowField(res) {
  this.res = res;
  this.cols = width / this.res;
  this.rows = height / this.res;
  this.field = new Array(this.cols * this.rows);
  
  this.update = function() {
    let yoff = 0;
    for (let y = 0; y < this.rows; y++) {
      let xoff = 0;
      for (let x = 0; x < this.cols; x++) {
        let index = x + y * this.cols;
        let angle = noise(xoff, yoff, zoff) * TWO_PI * 4; // Increase the range of the noise function
        let v = p5.Vector.fromAngle(angle);
        this.field[index] = v;
        xoff += 0.1;
      }
      yoff += 0.1;
    }
    zoff += 0.01;
  }
  
  this.lookup = function(lookup) {
    let column = int(lookup.x / this.res);
    let row = int(lookup.y / this.res);
    let index = column + row * this.cols;
    return this.field[index];
  }
}

function Particle(x, y, hue) {
  this.pos = createVector(x, y);
  this.vel = createVector(0, 0);
  this.acc = createVector(0, 0);
  this.hue = hue;

  this.update = function() {
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  this.follow = function(flowfield) {
    let index = floor(this.pos.x / flowfield.res) + floor(this.pos.y / flowfield.res) * flowfield.cols;
    let force = flowfield.field[index];
    this.applyForce(force);
  }

  this.applyForce = function(force) {
    this.acc.add(force);
  }

  this.edges = function() {
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }

  this.show = function() {
    stroke(this.hue, 255, 255, 100);
    strokeWeight(2);
    point(this.pos.x, this.pos.y);
  }
}
"
"1975211","Follow light painting","mySketch","let flowfield;
let particles = [];
let zoff = 0;

function setup() {
  createCanvas(800, 800);
  colorMode(HSB, 255);
  background(0);
  flowfield = new FlowField(20);
}

function draw() {
  background(0, 0.1); // Semi-transparent background (creates trails)

  // Update and display particles
  for (let i = particles.length - 1; i >= 0; i--) {
    if (particles[i].isFinished()) {
      particles.splice(i, 1);
    } else {
      particles[i].follow(flowfield);
      particles[i].update();
      particles[i].show();
    }
  }
  
  // Create new particles
  if (frameCount % 5 == 0) { // Create new particles every 5 frames
    let p = new Particle(width / 2, height / 2, random(255));
    particles.push(p);
  }

  // Update flow field
  flowfield.update();
}

function FlowField(res) {
  this.res = res;
  this.cols = width / this.res;
  this.rows = height / this.res;
  this.field = new Array(this.cols * this.rows);
  
  this.update = function() {
    let yoff = 0;
    for (let y = 0; y < this.rows; y++) {
      let xoff = 0;
      for (let x = 0; x < this.cols; x++) {
        let index = x + y * this.cols;
        let angle = noise(xoff, yoff, zoff) * TWO_PI * 4; // Increase the range of the noise function
        let v = p5.Vector.fromAngle(angle);
        this.field[index] = v;
        xoff += 0.1;
      }
      yoff += 0.1;
    }
    zoff += 0.01;
  }
  
  this.lookup = function(lookup) {
    let column = int(lookup.x / this.res);
    let row = int(lookup.y / this.res);
    let index = column + row * this.cols;
    return this.field[index];
  }
}

function Particle(x, y, hue) {
  this.pos = createVector(x, y);
  this.vel = createVector(0, 0);
  this.acc = createVector(0, 0);
  this.hue = hue;
  this.lifespan = 255;

  this.update = function() {
    let mouse = createVector(mouseX, mouseY);
    let dir = p5.Vector.sub(mouse, this.pos);
    dir.setMag(0.5);
    this.acc = dir;
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
    this.lifespan -= 0.5;
  }

this.follow = function(flowfield) {
    let x = constrain(floor(this.pos.x / flowfield.res), 0, flowfield.cols - 1);
    let y = constrain(floor(this.pos.y / flowfield.res), 0, flowfield.rows - 1);
    let index = x + y * flowfield.cols;
    let force = flowfield.field[index];
    this.applyForce(force);
}

  this.applyForce = function(force) {
    let f = force.copy();
    f.mult(0.02);
    this.acc.add(f);
  }

  this.show = function() {
    stroke(this.hue, 255, 255, this.lifespan);
    strokeWeight(4);
    point(this.pos.x, this.pos.y);
  }

  this.isFinished = function() {
    return this.lifespan < 0;
  }
}
"
"1975208","Forces","mySketch","let flowfield;
let particles = [];
let zoff = 0;

function setup() {
  createCanvas(800, 800);
  colorMode(HSB, 255);
  background(0);
  flowfield = new FlowField(20);
}

function draw() {
  background(0, 0.1); // Semi-transparent background (creates trails)
  
  // Update and display particles
  for (let i = particles.length - 1; i >= 0; i--) {
    if (particles[i].isFinished()) {
      particles.splice(i, 1);
    } else {
      particles[i].follow(flowfield);
      particles[i].update();
      particles[i].edges();
      particles[i].show();
    }
  }
  
  // Create new particles
  if (mouseIsPressed) {
    for (let i = 0; i < 5; i++) { // Create multiple particles at once
      particles.push(new Particle(mouseX, mouseY, random(255)));
    }
  }
  
  // Update flow field
  flowfield.update();
}

function FlowField(res) {
  this.res = res;
  this.cols = width / this.res;
  this.rows = height / this.res;
  this.field = new Array(this.cols * this.rows);
  
  this.update = function() {
    let yoff = 0;
    for (let y = 0; y < this.rows; y++) {
      let xoff = 0;
      for (let x = 0; x < this.cols; x++) {
        let index = x + y * this.cols;
        let angle = noise(xoff, yoff, zoff) * TWO_PI * 4; // Increase the range of the noise function
        let v = p5.Vector.fromAngle(angle);
        this.field[index] = v;
        xoff += 0.1;
      }
      yoff += 0.1;
    }
    zoff += 0.01;
  }
  
  this.lookup = function(lookup) {
    let column = int(lookup.x / this.res);
    let row = int(lookup.y / this.res);
    let index = column + row * this.cols;
    return this.field[index];
  }
}

function Particle(x, y, hue) {
  this.pos = createVector(x, y);
  this.vel = p5.Vector.random2D().mult(2); // Increase the initial speed
  this.acc = createVector(0, 0);
  this.hue = hue;
  this.lifespan = 255;
  
  this.applyForce = function(force) {
    this.acc.add(force);
  }
  
  this.update = function() {
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
    this.lifespan -= 0.5;
  }
  
  this.follow = function(flowfield) {
    let index = floor(this.pos.x / flowfield.res) + floor(this.pos.y / flowfield.res) * flowfield.cols;
    let force = flowfield.field[index];
    this.applyForce(force);
  }
  
  this.edges = function() {
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;
  }
  
  this.show = function() {
    noStroke();
    fill(this.hue, 255, 255, this.lifespan / 2); // Make particles slightly transparent
    ellipse(this.pos.x, this.pos.y, 8); // Increase the size of the particles
  }
  
  this.isFinished = function() {
    return this.lifespan < 0;
  }
}
"
"1975205","Snooker chaos","mySketch","let balls = [];

function setup() {
  createCanvas(800, 800);
}

function draw() {
  background(0);
  for (let i = 0; i < balls.length; i++) {
    balls[i].move();
    balls[i].display();
    balls[i].checkCollision();
  }
}

function mousePressed() {
  let r = random(10, 50);
  let b = new Ball(mouseX, mouseY, r);
  balls.push(b);
}

function Ball(x, y, r) {
  this.pos = createVector(x, y);
  this.r = r;
  this.vel = createVector(random(-2, 2), random(-2, 2));
  this.color = color(random(255), random(255), random(255));

  this.move = function() {
    this.pos.add(this.vel);

    // Bounce off the walls
    if (this.pos.x > width - this.r || this.pos.x < this.r) {
      this.vel.x *= -1;
    }
    if (this.pos.y > height - this.r || this.pos.y < this.r) {
      this.vel.y *= -1;
    }
  }

  this.display = function() {
    fill(this.color);
    noStroke();
    ellipse(this.pos.x, this.pos.y, this.r * 2);
  }

  this.checkCollision = function() {
    for (let other of balls) {
      if (other !== this) {
        let d = dist(this.pos.x, this.pos.y, other.pos.x, other.pos.y);
        if (d < this.r + other.r) {
          let collision = p5.Vector.sub(this.pos, other.pos);
          collision.normalize();
          collision.mult(2);
          this.vel.add(collision);
        }
      }
    }
  }
}
"
"1975197","Particle cat","mySketch","let img;
let particles = [];

function preload() {
  img = loadImage('cat.png');
}

function setup() {
  createCanvas(800, 800);
  pixelDensity(1);
  img.loadPixels();
}

function draw() {
  background(0, 50); // Semi-transparent background (creates trails)
  
  // Draw the cat image in the background with some transparency
  tint(255, 128); // Apply transparency to the image
  image(img, 0, 0, width, height); // Draw the image to fit the entire canvas
  
  // Generate new particles
  for (let i = 0; i < 5; i++) {
    let x = mouseX + random(-5, 5);
    let y = mouseY + random(-5, 5);
    let color = img.get(int(x), int(y));
    let particle = new Particle(x, y, color);
    particles.push(particle);
  }
  
  // Update and show particles
  for (let i = particles.length - 1; i >= 0; i--) {
    if (particles[i].alpha <= 0) {
      particles.splice(i, 1);
    } else {
      particles[i].update();
      particles[i].show();
    }
  }
}

function Particle(x, y, color) {
  this.pos = createVector(x, y);
  this.vel = p5.Vector.random2D().mult(random(1, 2));
  this.acc = createVector(0, 0);
  this.alpha = 255;
  this.color = color;

  this.update = function() {
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
    this.alpha -= 2;
  }

  this.show = function() {
    noStroke();
    fill(this.color[0], this.color[1], this.color[2], this.alpha / 2); // Make particles slightly transparent
    ellipse(this.pos.x, this.pos.y, 16);
  }
}
"
"1975185","Mesmerizing pattern","mySketch","let t; // time variable

function setup() {
  createCanvas(800, 800);
  noFill();
  t = 0;
}

function draw() {
  background(0, 10); // Semi-transparent background (creates trails)

  // Create a new point with noise-function
  let x1 = noise(t + 15) * width;
  let y1 = noise(t) * height;

  let x2 = noise(t + 25) * width;
  let y2 = noise(t + 10) * height;

  let x3 = noise(t + 35) * width;
  let y3 = noise(t + 20) * height;

  let x4 = noise(t + 45) * width;
  let y4 = noise(t + 30) * height;

  // Draw the bezier curve
  stroke((t * 100) % 256, 255, 255); // Color changes over time
  bezier(x1, y1, x2, y2, x3, y3, x4, y4);

  t += 0.01; // Increment the time variable
}
"
"1975183","Pebble into a pond","mySketch","let circles = [];

function setup() {
  createCanvas(800, 800);
  colorMode(HSB, 255);
  noStroke();
}

function draw() {
  background(0);

  for (let i = circles.length - 1; i >= 0; i--) {
    circles[i].grow();
    circles[i].show();

    if (circles[i].isFinished()) {
      circles.splice(i, 1);
    }
  }
}

function mouseClicked() {
  let hue = random(255);
  circles.push(new Circle(mouseX, mouseY, hue));
}

function Circle(x, y, hue) {
  this.x = x;
  this.y = y;
  this.hue = hue;
  this.radius = 1;
  this.lifespan = 255;

  this.grow = function() {
    if (this.lifespan > 0) {
      this.radius += 2;
      this.lifespan -= 1;
    }
  }

  this.show = function() {
    fill(this.hue, 255, 255, this.lifespan);
    ellipse(this.x, this.y, this.radius * 2);
  }

  this.isFinished = function() {
    return this.lifespan <= 0;
  }
}
"
"1975182","Fireworks effect","mySketch","let particles = [];

function setup() {
  createCanvas(800, 800);
  colorMode(HSB, 255);
}

function draw() {
  background(0);
  
  // Create new particles at mouse position
  if (mouseIsPressed) {
    for (let i = 0; i < 5; i++) {
      let p = new Particle(mouseX, mouseY, random(0, 255));
      particles.push(p);
    }
  }
  
  // Update and show particles
  for (let i = particles.length - 1; i >= 0; i--) {
    if (particles[i].finished()) {
      // If the particle's life has ended, remove it
      particles.splice(i, 1);
    } else {
      particles[i].update(); // Update particle position
      particles[i].show(); // Draw particle
    }
  }
}

function Particle(x, y, hue) {
  this.pos = createVector(x, y); // Position
  this.vel = p5.Vector.random2D(); // Velocity
  this.acc = createVector(0, 0); // Acceleration
  this.lifespan = 255; // Lifespan
  
  // Color
  this.hue = hue;
  
  // Update position and velocity
  this.update = function() {
    this.vel.add(this.acc);
    this.pos.add(this.vel);
    this.acc.mult(0);
    this.lifespan -= 1; // Decrease lifespan
  }

  // Draw particle
  this.show = function() {
    stroke(this.hue, 255, 255, this.lifespan);
    strokeWeight(2);
    point(this.pos.x, this.pos.y);
  }

  // Check if particle's life has ended
  this.finished = function() {
    return this.lifespan < 0;
  }
}
"
"1975181","Interactive fractal tree","mySketch","let angle;

function setup() {
  createCanvas(800, 800);
  colorMode(HSB);
}

function draw() {
  background(0);
  angle = map(mouseX, 0, width, 0, PI); // Change angle based on mouse's x position
  let len = 150; // Length of the trunk
  stroke(255);
  translate(width / 2, height); // Start the tree from the bottom of the screen
  branch(len);
}

function branch(len) {
  let sw = map(len, 2, 150, 1, 10); // Change stroke weight based on branch length
  strokeWeight(sw);
  
  let h = map(len, 2, 150, 0, 255); // Change hue based on branch length
  stroke(h, 255, 255);
  
  line(0, 0, 0, -len); // Draw the branch
  translate(0, -len); // Move to the end of the branch
  
  len *= 0.67; // Each branch is 2/3rds the size of the previous one
  
  if (len > 2) { // If the length is greater than 2, branch again
    push(); // Save the current state of transformation (i.e., where we are now)
    rotate(angle); // Rotate by a certain angle
    branch(len); // Draw a new branch to the right
    pop(); // Go back to where we were before we rotated
    push(); // Save the current state of transformation
    rotate(-angle); // Rotate by a certain angle in the other direction
    branch(len); // Draw a new branch to the left
    pop(); // Go back to where we were before we rotated
  }
}
"
"1975161","Moiré effect","mySketch","let angle = 0;  // Rotation angle
let spacing = 10;  // Space between lines

function setup() {
  createCanvas(800, 800);
  background(0);
  stroke(255);  // Set line color to white
}

function draw() {
  background(0);
  
  // Draw first set of lines
  for (let x = 0; x < width; x += spacing) {
    line(x, 0, x, height);
  }
  
  push();  // Save current transformation matrix
  translate(width / 2, height / 2);  // Move origin to center of canvas
  rotate(angle);  // Rotate by angle
  
  // Draw second set of lines
  for (let x = -width / 2; x < width / 2; x += spacing) {
    line(x, -height / 2, x, height / 2);
  }
  
  pop();  // Restore transformation matrix
  
  angle += 0.01;  // Increment angle
}

function mousePressed() {
  // When mouse is pressed, reset angle to 0 and change line spacing
  angle = 0;
  spacing = random(5, 20);
}
"
"1975153","Perlin Magic","mySketch","let scl = 20;
let cols, rows;

let zoff = 0;

let particles = [];

let flowfield;

let attractors = []; // Array to hold attractor points

function setup() {
  createCanvas(800, 800);
  colorMode(HSB, 255);
  cols = floor(width / scl);
  rows = floor(height / scl);
  flowfield = new Array(cols * rows);
  for (let i = 0; i < 500; i++) {
    particles[i] = new Particle();
  }
  background(51);
}

function draw() {
  let yoff = 0;
  for (let y = 0; y < rows; y++) {
    let xoff = 0;
    for (let x = 0; x < cols; x++) {
      let index = x + y * cols;
      let angle = noise(xoff, yoff, zoff) * TWO_PI * 4;
      let v = p5.Vector.fromAngle(angle);
      v.setMag(1);
      flowfield[index] = v;
      xoff += 0.1;
    }
    yoff += 0.1;
  }
  zoff += 0.01;

  for (let i = 0; i < particles.length; i++) {
    particles[i].follow(flowfield);
    particles[i].update();
    particles[i].edges();
    particles[i].show();
  }

  // If mouse is pressed, create new particles at mouse position
  if (mouseIsPressed) {
    particles.push(new Particle(mouseX, mouseY, random(255)));
  }

  // Apply attraction force
  attractors.forEach(attractor => {
    particles.forEach(particle => {
      particle.attract(attractor);
    });
  });
}

// When mouse is clicked, create a new attractor at mouse position
function mouseClicked() {
  attractors.push(createVector(mouseX, mouseY));
}

function Particle(x, y, hue) {
  if (x && y) {
    // If position is given, use that
    this.pos = createVector(x, y);
  } else {
    // Else, start at random position
    this.pos = createVector(random(width), random(height));
  }
  this.vel = createVector(0, 0);
  this.acc = createVector(0, 0);
  this.maxspeed = 2;

  // If hue is given, use that
  this.hue = hue || random(255);

  this.prevPos = this.pos.copy();

  this.update = function() {
    this.vel.add(this.acc);
    this.vel.limit(this.maxspeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  this.follow = function(flowfield) {
    let x = floor(this.pos.x / scl);
    let y = floor(this.pos.y / scl);
    let index = x + y * cols;
    let force = flowfield[index];
    this.applyForce(force);
  }

  this.applyForce = function(force) {
    this.acc.add(force);
  }

  this.show = function() {
    stroke(this.hue, 255, 255, 25);
    this.hue = this.hue + 1 % 255;
    strokeWeight(1);
    line(this.pos.x, this.pos.y, this.prevPos.x, this.prevPos.y);
    this.updatePrev();
  }

  this.updatePrev = function() {
    this.prevPos.x = this.pos.x;
    this.prevPos.y = this.pos.y;
  }

  this.edges = function() {
    if (this.pos.x > width) {
      this.pos.x = 0;
      this.updatePrev();
    }
    if (this.pos.x < 0) {
      this.pos.x = width;
      this.updatePrev();
    }
    if (this.pos.y > height) {
      this.pos.y = 0;
      this.updatePrev();
    }
    if (this.pos.y < 0) {
      this.pos.y = height;
      this.updatePrev();
    }
  }

  // Attraction to a point
  this.attract = function(target) {
    let force = p5.Vector.sub(target, this.pos); // A vector pointing from the position to the target
    let dsquared = force.magSq(); // Distance squared
    dsquared = constrain(dsquared, 25, 500); // Limiting the distance to eliminate ""extreme"" results for very close or very far objects
    const G = 50; // Gravitational constant
    let strength = G / dsquared; // Calculate gravitation magnitude
    force.setMag(strength);
    this.acc.add(force);
  }
}
"
"1975142","Snake","mySketch.js","let snake;
let rez = 40;  // doubled the size of each cell
let food;
let w;
let h;
let foodImg;
let headImg;
let gameOver = false;
let score = 0;  // added score

function preload() {
  foodImg = loadImage('food.png');  // replace with path to your food image
  headImg = loadImage('snake.png');  // replace with path to your snake head image
}

function setup() {
  createCanvas(800, 800);  // doubled the size of the canvas
  w = floor(width / rez);
  h = floor(height / rez);
  frameRate(5);
  startGame();
}

function startGame() {
  snake = new Snake();
  foodLocation();
  gameOver = false;
  score = 0;  // reset score
  loop();
}

function foodLocation() {
  let x = floor(random(w));
  let y = floor(random(h));
  food = createVector(x, y);
}

function keyPressed() {
  if (keyCode === LEFT_ARROW) {
    snake.setDir(-1, 0);
  } else if (keyCode === RIGHT_ARROW) {
    snake.setDir(1, 0);
  } else if (keyCode === DOWN_ARROW) {
    snake.setDir(0, 1);
  } else if (keyCode === UP_ARROW) {
    snake.setDir(0, -1);
  }

  if (gameOver) {
    startGame();
  }
}

function draw() {
  scale(rez);
  background(220);
  if (snake.eat(food)) {
    foodLocation();
    score++;  // increment score when the snake eats food
  }
  snake.update();
  snake.show();

  if (snake.endGame()) {
    gameOver = true;
    textSize(1);
    fill(0);
    text('Game Over', w / 2, h / 2);
    noLoop();
  }

  image(foodImg, food.x, food.y, 1, 1);
  
  // Display score
  fill(0);
  textSize(0.5);
  text('Score: ' + score, 1, 1);
}

class Snake {
  constructor() {
    this.body = [];
    this.body[0] = createVector(floor(w / 2), floor(h / 2));
    this.xdir = 0;
    this.ydir = 0;
    this.len = 0;
  }

  setDir(x, y) {
    this.xdir = x;
    this.ydir = y;
  }

  update() {
    let head = this.body[this.body.length-1].copy();
    this.body.shift();
    head.x += this.xdir;
    head.y += this.ydir;
    this.body.push(head);
  }

  grow() {
    let head = this.body[this.body.length-1].copy();
    this.len++;
    this.body.push(head);
  }

  endGame() {
    let x = this.body[this.body.length-1].x;
    let y = this.body[this.body.length-1].y;
    if (x > w-1 || x < 0 || y > h-1 || y < 0) {
      return true;
    }
    for (let i = 0; i < this.body.length-1; i++) {
      let part = this.body[i];
      if (part.x == x && part.y == y) {
        return true;
      }
    }
    return false;
  }

  eat(pos) {
    let x = this.body[this.body.length-1].x;
    let y = this.body[this.body.length-1].y;
    if (x == pos.x && y == pos.y) {
      this.grow();
      return true;
    }
    return false;
  }

     show() {
    for (let i = 0; i < this.body.length; i++) {
      fill(0);
      noStroke();
      if (i == this.body.length - 1) {
        push();
        translate(this.body[i].x + 0.5, this.body[i].y + 0.5);
        if (this.xdir == 0 && this.ydir == 1) rotate(0);  // eyes facing up
        else if (this.xdir == -1 && this.ydir == 0) rotate(3 * PI / 2);  // eyes facing left
        else if (this.xdir == 0 && this.ydir == -1) rotate(PI);  // eyes facing down
        else if (this.xdir == 1 && this.ydir == 0) rotate(PI / 2);  // eyes facing right
        image(headImg, -0.5, -0.5, 1, 1);
        pop();
      } else {
        rect(this.body[i].x, this.body[i].y, 1, 1);
      }
    }
  }
}"
"1975142","Snake","style.css","html,
body {
	margin: 0;
	padding: 0;
}"
"1975142","Snake","index.html","<!DOCTYPE html>
<html lang=""en"">

<head>
	<meta charset=""utf-8"" />
	<!-- keep the line below for OpenProcessing compatibility -->
	<script src=""https://openprocessing.org/openprocessing_sketch.js""></script>
	<script src=""https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.js""></script>
	<script src=""https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/addons/p5.sound.min.js""></script>
	<script src=""mySketch.js""></script>
	<link rel=""stylesheet"" type=""text/css"" href=""style.css"">
</head>

<body>   
	
</body>

</html>"
"1975117","Breakout","mySketch","let paddle;
let ball;
let bricks = [];
let score = 0;
let gameOver = false;

let paddleImg;
let ballImg;
let brickImg;

function preload() {
  paddleImg = loadImage('paddle.png'); // replace with your paddle image path
  ballImg = loadImage('ball.png'); // replace with your ball image path
  brickImg = loadImage('brick.png'); // replace with your brick image path
}

function setup() {
  createCanvas(800, 800);
  paddle = new Paddle();
  ball = new Ball();
  for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 5; j++) {
      bricks.push(new Brick(i * 80 + 80, j * 30 + 50));
    }
  }
}

function draw() {
  background(0);
  // Draw a red square around the canvas
  stroke(255, 0, 0); 
  noFill();
  rect(0, 0, width, height);
  
  paddle.show();
  paddle.move();
  ball.show();
  ball.move();
  for (let i = bricks.length - 1; i >= 0; i--) {
    bricks[i].show();
    if (ball.hits(bricks[i])) {
      score += 10;
      if (score == bricks.length * 10) {
        score = 1000;
        bricks = bricks.concat(new Array(50).fill().map((_, i) => new Brick((i % 10) * 80 + 80, Math.floor(i / 10) * 30 + 50)));
      }
      ball.direction.y *= -1;
      bricks.splice(i, 1);
    }
  }
  fill(255);
  textSize(24);
  text(""Score: "" + score, 10, 30);
  if (ball.y > height) {
    gameOver = true;
    fill(255, 0, 0);
    textSize(24);
    text(""GAME OVER"", width / 2, height / 2);
    noLoop();
  }
if (gameOver && keyIsPressed && key === ' ') {
  gameOver = false;
  score = 0;
  bricks = new Array(50).fill().map((_, i) => new Brick((i % 10) * 80 + 80, Math.floor(i / 10) * 30 + 50));
  ball = new Ball();
  loop();
}
}

function Paddle() {
  this.width = 200; // Increased the width of the paddle
  this.height = 20;
  this.x = (width - this.width) / 2;
  this.speed = 5;
  this.show = function() {
    image(paddleImg, this.x, height - this.height, this.width, this.height);
  }
  this.move = function() {
    if (keyIsDown(LEFT_ARROW)) this.x -= this.speed;
    if (keyIsDown(RIGHT_ARROW)) this.x += this.speed;
    this.x = constrain(this.x, 0, width - this.width);
  }
}

function Ball() {
  this.x = width / 2;
  this.y = height / 2;
  this.size = 20;
  this.direction = createVector(1, 1);
  this.speed = 3;
  this.show = function() {
    image(ballImg, this.x, this.y, this.size, this.size);
  }
  this.move = function() {
    this.x += this.direction.x * this.speed;
    this.y += this.direction.y * this.speed;
    if (this.x < 0 || this.x > width) this.direction.x *= -1;
    if (this.y < 0 || this.y > height - paddle.height && this.x > paddle.x && this.x < paddle.x + paddle.width) this.direction.y *= -1;
  }
  this.hits = function(brick) {
    let d = dist(this.x, this.y, brick.x, brick.y);
    return (d < this.size / 2 + brick.width / 2 && d < this.size / 2 + brick.height / 2);
  }
}

function keyPressed() {
  if (gameOver && key === ' ') {
    gameOver = false;
    score = 0;
    bricks = new Array(50).fill().map((_, i) => new Brick((i % 10) * 80 + 80, Math.floor(i / 10) * 30 + 50));
    ball = new Ball();
    loop();
  }
}

function Brick(x, y) {
  this.x = x;
  this.y = y;
  this.width = 60;
  this.height = 20;
  this.show = function() {
    image(brickImg, this.x, this.y, this.width, this.height);
  }
}"
"1974503","The Space Sprint","mySketch","let spaceship;
let asteroids = [];
let bullets = [];
let spaceshipImg;
let asteroidImg;
let gameOver = false; 
let score = 0; 
let gameStarted = false;


function preload() {
  // Use the path to your images here
  spaceshipImg = loadImage('spaceship2.png');
  asteroidImg = loadImage('asteroid2.png');
  bulletImg = loadImage('bullet.png');
	bgImg = loadImage('background.jpeg');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  resetGame(); // Call resetGame in setup to initialize game state
}

function resetGame() {
  spaceship = new Spaceship();
  asteroids = []; // Clear the asteroids array
  for(let i=0; i<10; i++){
    asteroids.push(new Asteroid());
  }
}

function draw() {
  
  if (!gameStarted) {
    background(0);
    fill(255);
    textAlign(CENTER);
    textSize(32);
    text(""Welcome to The Space Sprint!"", width / 2, height / 2 - 200);
    textSize(24);
    text(""by Gonçalo Perdigão"", width / 2, height / 2 - 160);
		textSize(16);
    text(""In a close galaxy, brave pilot Alex and his spaceship, Stellar Dash,"", width / 2, height / 2 - 90);
    text(""decided to navigate the notorious Asteroid Belt of Orion. Weaving and"", width / 2, height / 2 - 60);
    text(""blasting through the field, they became a legendary duo. Each asteroid"", width / 2, height / 2 - 30);
    text(""destroyed was a score, a testament to their courage."", width / 2, height / 2);

  } else {
	
    image(bgImg, 0, 0, width, height); // Draw the background image first
  
    spaceship.render();
    spaceship.turn();
    spaceship.update();
  
    fill(255);
    textSize(32);
    text(""Score: "" + score, 100, 50); 
	
    for(let i=0; i<asteroids.length; i++){
      if(spaceship.hits(asteroids[i])){
          console.log('game over');
          noLoop();
          gameOver = true;  // Set gameOver to true when the game ends
      }
      asteroids[i].render();
      asteroids[i].update();
      asteroids[i].edges();
    }
	
    for(let i=bullets.length-1; i>=0; i--){
      bullets[i].render();
      bullets[i].update();
      if(bullets[i].offscreen()){
        bullets.splice(i, 1);
      } else {
        for(let j=asteroids.length-1; j>=0; j--){
          if(bullets[i].hits(asteroids[j])){
            if(asteroids[j].r > 10){
              let newAsteroids = asteroids[j].breakup();
              asteroids = asteroids.concat(newAsteroids);
              score += 10;
            }
            asteroids.splice(j, 1);
            bullets.splice(i, 1);
            break;
          }
        }
      }
    }
  }
}


function keyReleased() {
  spaceship.setRotation(0);
  spaceship.boosting(false);
}

function mousePressed() {
   if (!gameStarted) {
    gameStarted = true;
  } else {
    if (gameOver) {  // If the game is over, restart the game when the mouse is clicked
      gameOver = false;
      resetGame();  // Reset the game state
      loop();  // Restart the draw loop
    } else {
      bullets.push(new Bullet(spaceship.pos, spaceship.heading));
    }
  }
}


function keyPressed() {
  if (keyCode === 32) {  // 32 is the keyCode for the spacebar
    bullets.push(new Bullet(spaceship.pos, spaceship.heading));
  }
}

class Spaceship {
  constructor() {
    this.pos = createVector(width / 2, height / 2);
    this.r = 40;
    this.heading = 0;
    this.rotation = 0;
    this.vel = createVector(0, 0);
    this.isBoosting = false;
  }

  boosting(b) {
    this.isBoosting = b;
  }

  update() {
    if (mouseIsPressed) {
      this.boost();
    }
    this.pos.add(this.vel);
    this.vel.mult(0.99);
  }

  boost() {
    let force = p5.Vector.fromAngle(this.heading);
    force.mult(0.1);
    this.vel.add(force);
  }

  hits(asteroid) {
    let d = dist(this.pos.x, this.pos.y, asteroid.pos.x, asteroid.pos.y);
    return d < this.r + asteroid.r;
  }

render() {
    push();
    translate(this.pos.x, this.pos.y);
    rotate(this.heading + PI / 2);  // Add this line to rotate the spaceship. PI/2 is added to align the spaceship image correctly
    imageMode(CENTER);
    image(spaceshipImg, 0, 0, this.r * 2, this.r * 2);
    pop();
}
	
  turn() {
    this.heading = p5.Vector.sub(createVector(mouseX, mouseY), this.pos).heading();
  }
	
  edges() {
    if (this.pos.x > width + this.r) {
      this.pos.x = -this.r;
    } else if (this.pos.x < -this.r) {
      this.pos.x = width + this.r;
    }
    if (this.pos.y > height + this.r) {
      this.pos.y = -this.r;
    } else if (this.pos.y < -this.r) {
      this.pos.y = height + this.r;
    }
  }
}

class Asteroid {
  constructor(pos, r) {
    if (pos) {
      this.pos = pos.copy();
    } else {
      this.pos = createVector(random(width), random(height))
    }
    if (r) {
      this.r = r * 0.5;
    } else {
      this.r = random(15, 50);
    }
    this.vel = p5.Vector.random2D();
    this.total = floor(random(5, 15));
    this.offset = [];
    for (let i = 0; i < this.total; i++) {
      this.offset[i] = random(-this.r * 0.5, this.r * 0.5);
    }
  }

	  breakup() {
    let newA = [];
    newA[0] = new Asteroid(this.pos, this.r);
    newA[1] = new Asteroid(this.pos, this.r);
    return newA;
  }
	
  render() {
    push();
    translate(this.pos.x, this.pos.y);
    imageMode(CENTER);
    image(asteroidImg, 0, 0, this.r * 2, this.r * 2);
    pop();
  }

  update() {
    this.pos.add(this.vel);
  }

  edges() {
    if (this.pos.x > width + this.r) {
      this.pos.x = -this.r;
    } else if (this.pos.x < -this.r) {
      this.pos.x = width + this.r;
    }
    if (this.pos.y > height + this.r) {
      this.pos.y = -this.r;
    } else if (this.pos.y < -this.r) {
      this.pos.y = height + this.r;
    }
  }
}

class Bullet {
  constructor(pos, heading) {
    this.pos = pos.copy();
    this.vel = p5.Vector.fromAngle(heading);
    this.vel.mult(5);
    this.r = 5;  // Define radius for the bullet
  }

  update() {
    this.pos.add(this.vel);
  }

  render() {
    push();
    translate(this.pos.x, this.pos.y);
    rotate(this.heading);
    imageMode(CENTER);
    image(bulletImg, 0, 0, this.r * 2, this.r * 2);
    pop();
  }

  hits(asteroid) {
    let d = dist(this.pos.x, this.pos.y, asteroid.pos.x, asteroid.pos.y);
    return d < this.r + asteroid.r;  // Use bullet's radius for collision detection
  }

  offscreen() {
    if (this.pos.x > width || this.pos.x < 0) {
      return true;
    }
    if (this.pos.y > height || this.pos.y < 0) {
      return true;
    }
    return false;
  }
}"
